<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Games101-P13-16 Ray Tracing</title>
      <link href="/2023/04/23/Games101-P13-16/"/>
      <url>/2023/04/23/Games101-P13-16/</url>
      
        <content type="html"><![CDATA[<ul><li>P13 Overview<ul><li>Recursive (Whitted-Style) Ray Tracing<ul><li>Ray-Surface Intersection 光线和面求交：球体、隐式表面、三角面，及缺点</li></ul></li><li>Accelerating Ray-Surface Intersection 加速<ul><li>Ray Intersection with Axis-Aligned Box</li></ul></li></ul></li><li><p>P14 Overview</p><ul><li><p>Using AABBs to accelerate ray tracing</p><ul><li>Uniform grids</li><li>Spatial partitions 空间划分</li></ul></li><li><p>Basic radiometry</p></li></ul></li></ul><span id="more"></span><h1 id="P13-Ray-Tracing-1"><a href="#P13-Ray-Tracing-1" class="headerlink" title="P13 Ray Tracing 1"></a>P13 Ray Tracing 1</h1><ul><li>Why ray tracing?<ul><li>光栅化渲染不能完美诠释global effects(下图都算global effect)<ul><li><img src="/2023/04/23/Games101-P13-16/截屏2023-04-23 22.54.49.png" alt="截屏2023-04-23 22.54.49" style="zoom:50%;"></li></ul></li><li>光栅化速度快，可实现近似，但质量较低</li><li>光栅化是Real-time；光线追踪是Offline</li></ul></li><li>Features of ray-tracing<ul><li>accurate</li><li>slow </li></ul></li></ul><h2 id="Basic-Ray-Tracing-Algorithm"><a href="#Basic-Ray-Tracing-Algorithm" class="headerlink" title="Basic Ray-Tracing Algorithm"></a>Basic Ray-Tracing Algorithm</h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><ul><li>Light光线<ul><li>光线延直线传播（本课中）</li><li>光线相交时不会发生碰撞（本课中）</li><li>光线从光源发射出，经反射、折射后进入人眼</li></ul></li></ul><h3 id="Ray-Casting"><a href="#Ray-Casting" class="headerlink" title="Ray Casting"></a>Ray Casting</h3><p><img src="/2023/04/23/Games101-P13-16/截屏2023-04-23 23.15.03.png" alt="截屏2023-04-23 23.15.03" style="zoom:50%;"></p><ul><li>概述<ul><li>摄像机与屏幕像素连线，并穿透屏幕并打在红圈处</li><li>连接红圈和光源，判断红圈处点是否在阴影中</li><li>若不在阴影中，则该光线有效，可进行进一步计算该点处光的能量</li></ul></li></ul><h4 id="Generating-Eye-Rays"><a href="#Generating-Eye-Rays" class="headerlink" title="Generating Eye Rays"></a>Generating Eye Rays</h4><ul><li>Pinhole Camera Model 针孔相机模型<ul><li>Step1: 每一个像素的光线射入，与场景相交，求出最近交点<img src="/2023/04/23/Games101-P13-16/截屏2023-04-23 23.23.10.png" alt="截屏2023-04-23 23.23.10" style="zoom: 40%;"><ul><li>对于光线和多个物体相交的情况：因遮挡，只考虑最近（直接避免光追中的深度测试）</li></ul></li><li>Step2: 交点与光源连线，若不在阴影中就计算着色<img src="/2023/04/23/Games101-P13-16/截屏2023-04-23 23.25.16.png" alt="截屏2023-04-23 23.25.16" style="zoom:40%;"></li><li>Step3: 写入对应像素</li></ul></li></ul><h3 id="Recursive-Whitted-Style-Ray-Tracing"><a href="#Recursive-Whitted-Style-Ray-Tracing" class="headerlink" title="Recursive (Whitted-Style) Ray Tracing"></a>Recursive (Whitted-Style) Ray Tracing</h3><p><img src="/2023/04/23/Games101-P13-16/截屏2023-04-24 10.09.39.png" alt="截屏2023-04-24 10.09.39" style="zoom:33%;"></p><ul><li><p>对于透明物体，发生折射+反射</p><ul><li><img src="/2023/04/23/Games101-P13-16/截屏2023-04-24 10.27.20.png" alt="截屏2023-04-24 10.27.20" style="zoom:50%;"></li><li><img src="/2023/04/23/Games101-P13-16/截屏2023-04-24 10.31.17.png" alt="截屏2023-04-24 10.31.17" style="zoom:50%;"></li></ul></li><li><p>所有被打到的点（红圈处），都计算着色，最终相加，得出像素最终颜色</p></li></ul><h4 id="Ray-Surface-Intersection-光线和面求交"><a href="#Ray-Surface-Intersection-光线和面求交" class="headerlink" title="Ray-Surface Intersection 光线和面求交"></a>Ray-Surface Intersection 光线和面求交</h4><h5 id="光线和球体求交"><a href="#光线和球体求交" class="headerlink" title="光线和球体求交"></a>光线和球体求交</h5><ul><li>光线：起点+方向<ul><li><img src="/2023/04/23/Games101-P13-16/截屏2023-04-24 10.44.35.png" alt="截屏2023-04-24 10.44.35" style="zoom:33%;"></li></ul></li><li>联立方程求交点：<ul><li>光线：$r(t) = \boldsymbol o+t \boldsymbol d , (0 \leq t &lt; \infty)$</li><li>球：$\boldsymbol p: (\boldsymbol{p} -c)^2 - R^2 = 0$</li><li><img src="/2023/04/23/Games101-P13-16/截屏2023-04-24 13.30.30.png" alt="截屏2023-04-24 13.30.30" style="zoom:33%;"></li></ul></li></ul><h5 id="光线和隐式表面求交"><a href="#光线和隐式表面求交" class="headerlink" title="光线和隐式表面求交"></a>光线和隐式表面求交</h5><ul><li>将光线函数表示带入隐式表面公式<ul><li><img src="/2023/04/23/Games101-P13-16/截屏2023-04-24 13.35.58.png" alt="截屏2023-04-24 13.35.58" style="zoom:33%;"></li></ul></li></ul><h5 id="与三角面求交"><a href="#与三角面求交" class="headerlink" title="与三角面求交"></a>与三角面求交</h5><p><img src="/2023/04/23/Games101-P13-16/截屏2023-04-24 13.49.32.png" alt="截屏2023-04-24 13.49.32"></p><ul><li>补：<strong>判断空间中任意点是否在（封闭）物体内</strong>：<ul><li>从该点向任意方向做一条光线，检测光线和该物体交点个数</li><li>若交点为奇数，则点在物体内；若交点为偶数，则点在物体外</li></ul></li><li><strong>光线与三角面求交计算过程</strong><ul><li>光线和三角形所在面求交<ul><li>平面的定义：向量+一个点</li><li>平面上的点$\boldsymbol p$和法线$\boldsymbol N$满足向量$\boldsymbol{p’p}\perp \boldsymbol N$，则点乘为0：<img src="/2023/04/23/Games101-P13-16/截屏2023-04-25 19.23.25.png" alt="截屏2023-04-25 19.23.25"></li><li>联立光线&amp;平面方程求交：<img src="/2023/04/23/Games101-P13-16/截屏2023-04-25 19.31.08.png" alt="截屏2023-04-25 19.31.08" style="zoom:33%;"></li></ul></li><li>判断交点在不在三角形内（叉乘）</li></ul></li><li>Möller Trumbore Algorithm：光线方程 = 重心坐标方程（可表示三角形平面内任意一点）<ul><li><img src="/2023/04/23/Games101-P13-16/截屏2023-04-25 19.43.30.png" alt="截屏2023-04-25 19.43.30" style="zoom:33%;"></li></ul></li></ul><h5 id="缺点问题"><a href="#缺点问题" class="headerlink" title="缺点问题"></a>缺点问题</h5><ul><li>测试每一个三角形与光线的交点，找到最接近的交点（即最小t）</li><li>Naive algorithm = #pixels ⨉ # traingles，每一个像素都要遍历场景中所有三角面，慢</li></ul><h4 id="Accelerating-Ray-Surface-Intersection-加速"><a href="#Accelerating-Ray-Surface-Intersection-加速" class="headerlink" title="Accelerating Ray-Surface Intersection 加速"></a>Accelerating Ray-Surface Intersection 加速</h4><h5 id="Ray-Intersection-with-Axis-Aligned-Box"><a href="#Ray-Intersection-with-Axis-Aligned-Box" class="headerlink" title="Ray Intersection with Axis-Aligned Box"></a>Ray Intersection with Axis-Aligned Box</h5><ul><li>Bounding Volumes 包围体积(盒)<ul><li><strong style="color:red;">将复杂物体用简单物体包围，若光线不与包围盒相交，则肯定不会与物体相交</strong></li><li><img src="/2023/04/23/Games101-P13-16/截屏2023-04-25 20.00.10.png" alt="截屏2023-04-25 20.00.10" style="zoom:33%;"></li></ul></li><li>Axis-Aligned Bounding Box (AABB 轴对⻬包围盒)<ul><li>理解：三个对立面的交集<img src="/2023/04/23/Games101-P13-16/截屏2023-04-25 20.03.53.png" alt="截屏2023-04-25 20.03.53" style="zoom:33%;"></li></ul></li><li><p><strong>光线与AABB求交</strong>：</p><ul><li><img src="/2023/04/23/Games101-P13-16/截屏2023-04-25 20.13.40.png" alt="截屏2023-04-25 20.13.40" style="zoom:40%;"></li><li>Key Ideas <ul><li>光线射入AABB：光线<strong>射入所有</strong>对立面</li><li>光线射出AABB：光线<strong>射出任意一个</strong>对立面</li></ul></li><li>计算过程<ul><li><img src="/2023/04/23/Games101-P13-16/截屏2023-04-25 20.23.43.png" alt="截屏2023-04-25 20.23.43" style="zoom:50%;"></li><li>有交点，当且仅当$t_{enter} &lt; t_{exit}$ &amp;&amp; $t_{exit} &gt;= 0$</li><li>若$t$为负<ul><li>$t_{exit} &lt; 0$：AABB在光线反方向，没有交点</li><li>$t_{enter} &lt; 0$ &amp;&amp; $t_{exit} &gt;= 0$：光线起点在AABB里</li></ul></li></ul></li></ul></li><li><p>Why Axis-Aligned? - 计算简单</p><ul><li><img src="/2023/04/23/Games101-P13-16/截屏2023-04-25 20.33.35.png" alt="截屏2023-04-25 20.33.35" style="zoom:50%;"></li></ul></li></ul><h1 id="P14-Ray-Tracing-2-Acceleration-amp-Radiometry"><a href="#P14-Ray-Tracing-2-Acceleration-amp-Radiometry" class="headerlink" title="P14 Ray Tracing 2 (Acceleration &amp; Radiometry)"></a>P14 Ray Tracing 2 (Acceleration &amp; Radiometry)</h1><h2 id="Using-AABBs-to-accelerate-ray-tracing"><a href="#Using-AABBs-to-accelerate-ray-tracing" class="headerlink" title="Using AABBs to accelerate ray tracing"></a>Using AABBs to accelerate ray tracing</h2><h3 id="Uniform-Spatial-Partitions-Grids"><a href="#Uniform-Spatial-Partitions-Grids" class="headerlink" title="Uniform Spatial Partitions (Grids)"></a>Uniform Spatial Partitions (Grids)</h3><ul><li><p>思路：将光线与物体求交换为光线与盒子求交</p></li><li><p>场景预处理</p><ul><li><p><img src="/2023/04/23/Games101-P13-16/截屏2023-04-25 22.18.54.png" alt="截屏2023-04-25 22.18.54" style="zoom:50%;"></p></li><li><p>进行<strong>光线追踪</strong><img src="/2023/04/23/Games101-P13-16/截屏2023-04-25 22.24.21.png" alt="截屏2023-04-25 22.24.21" style="zoom:50%;"></p></li><li><p>效率问题：寻找合适的格子数<img src="/2023/04/23/Games101-P13-16/pinjie01.jpg" alt="pinjie01"></p><p><img src="/2023/04/23/Games101-P13-16/截屏2023-04-25 22.33.59.png" alt="截屏2023-04-25 22.33.59" style="zoom:40%;"></p></li></ul></li><li><p>Grid可以很好地处理在大小和空间上均匀分布的大量对象集合，但是（<strong>问题</strong>）</p><ul><li>不适用于物体分布不均的场景，会存在“Teapot in a stadium” problem。为检测小物体则需要密集的格子，浪费性能</li></ul></li></ul><h3 id="Spatial-Partitions-空间划分-光线追踪前"><a href="#Spatial-Partitions-空间划分-光线追踪前" class="headerlink" title="Spatial Partitions 空间划分(光线追踪前)"></a>Spatial Partitions 空间划分(光线追踪前)</h3><ul><li>解决物体分布不均导致的格子需求不同的问题</li><li>Spatial Partitioning Examples<ul><li><img src="/2023/04/23/Games101-P13-16/截屏2023-04-25 22.58.33.png" alt="截屏2023-04-25 22.58.33" style="zoom:50%;"></li></ul></li></ul><h4 id="KD-Trees"><a href="#KD-Trees" class="headerlink" title="KD-Trees"></a>KD-Trees</h4>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
            <tag> 光线追踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P10-12 Geometry</title>
      <link href="/2023/04/15/Games101-P10-12/"/>
      <url>/2023/04/15/Games101-P10-12/</url>
      
        <content type="html"><![CDATA[<ul><li>P10&amp;11 Overview<ul><li>Introduce to geometry<ul><li>Examples of geometry</li><li>Various representations of geometry<ul><li>Implicit</li><li>Explicit</li></ul></li></ul></li></ul></li><li><p>P11 Overview</p><ul><li><p>Curves</p><ul><li>Bézier Curves</li><li>De Casteljau’s algorithm</li><li>B-splines, etc.</li></ul></li><li><p>Surfaces</p><ul><li>Bezier surfaces</li><li>Triangles &amp; quads<ul><li>Subdivision, simplification, regularization</li></ul></li></ul></li></ul></li><li><p>P12 Overview</p><ul><li>Mesh Subdivision (upsampling)</li><li>Mesh Simplification (downsampling)</li><li>Mesh Regularization (same #triangles)</li></ul></li></ul><span id="more"></span><h1 id="P10-amp-11-Geometry-Implicit-amp-Explicit"><a href="#P10-amp-11-Geometry-Implicit-amp-Explicit" class="headerlink" title="P10&amp;11 Geometry (Implicit&amp;Explicit)"></a>P10&amp;11 Geometry (Implicit&amp;Explicit)</h1><ul><li>难点：存储；渲染</li><li>过于精细不适宜三角面表示</li></ul><h2 id="几何的表示形式"><a href="#几何的表示形式" class="headerlink" title="几何的表示形式"></a>几何的表示形式</h2><p><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 13.29.06.png" alt="截屏2023-04-15 13.29.06" style="zoom:33%;"></p><h3 id="几何的隐式-Implicit-表示"><a href="#几何的隐式-Implicit-表示" class="headerlink" title="几何的隐式(Implicit)表示"></a>几何的隐式(Implicit)表示</h3><h4 id="Intro-隐式函数"><a href="#Intro-隐式函数" class="headerlink" title="Intro - 隐式函数"></a>Intro - 隐式函数</h4><ul><li>已知几何的点满足一定关系，未知点的具体位置<ul><li>eg：三维空间中单位球 $x^2+y^2+z^2=1$</li><li>通用：$f(x,y,z) = 0$</li><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 13.34.32.png" alt="截屏2023-04-15 13.34.32" style="zoom:40%;"></li></ul></li><li>缺点：采样难，所表现的形状不直观<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 13.37.00.png" alt="截屏2023-04-15 13.37.00" style="zoom:33%;"></li></ul></li><li>优点：便于检测点是否在物体表面上/内/外<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 13.37.52.png" alt="截屏2023-04-15 13.37.52" style="zoom:33%;"></li></ul></li></ul><h4 id="Algebraic-Surfaces"><a href="#Algebraic-Surfaces" class="headerlink" title="Algebraic Surfaces"></a>Algebraic Surfaces</h4><ul><li>可表述参数化模型，而无法表述复杂的又不可参数化描述的模型<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 13.55.20.png" alt="截屏2023-04-15 13.55.20" style="zoom: 50%;"></li></ul></li></ul><h4 id="Constructive-Solid-Geometry"><a href="#Constructive-Solid-Geometry" class="headerlink" title="Constructive Solid Geometry"></a>Constructive Solid Geometry</h4><ul><li>通过一系列基本几何的布尔运算，来定义新的几何<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 13.59.13.png" alt="截屏2023-04-15 13.59.13" style="zoom:50%;"></li></ul></li></ul><h4 id="Distance-Functions"><a href="#Distance-Functions" class="headerlink" title="Distance Functions"></a>Distance Functions</h4><ul><li>距离函数：对空间中任何一个点，到想要的几何形体表面的最小距离（内负外正）。将两个物体的空间函数blend后，推算出得到的新的函数所表示的几何形体<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 14.10.46.png" alt="截屏2023-04-15 14.10.46" style="zoom:50%;"></li></ul></li><li>理想：blend后得到二者位置的中间状态，SDF为0处表示物体边缘<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 14.54.33.png" alt="截屏2023-04-15 14.54.33" style="zoom:33%;"></li><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 15.12.26.png" alt="截屏2023-04-15 15.12.26"></li></ul></li><li>大神作品：<a href="https://iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm">https://iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm</a></li></ul><h4 id="Level-Set-Methods-水平集"><a href="#Level-Set-Methods-水平集" class="headerlink" title="Level Set Methods 水平集"></a>Level Set Methods 水平集</h4><ul><li><p>与距离函数类似，只是表示形式不同</p></li><li><p><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 15.30.03.png" alt="截屏2023-04-15 15.30.03" style="zoom:50%;"></p><ul><li><p>封闭形式的方程很难描述复杂的形状</p></li><li><p>替代方案：存储一个近似函数的值网格</p></li><li><p>表面处，值为0</p></li><li><p>提供对形状的更明确的控制（如纹理）</p></li></ul></li><li><p>水平集的三维应用</p><ul><li>Level Sets from Medical Data<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 15.36.59.png" alt="截屏2023-04-15 15.36.59" style="zoom:50%;"></li></ul></li><li>Level Sets in Physical Simulation，如水滴融合<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 15.38.52.png" alt="截屏2023-04-15 15.38.52" style="zoom:50%;"><ul><li><a href="http://physbam.stanford.edu">http://physbam.stanford.edu</a></li></ul></li></ul></li></ul></li></ul><h4 id="Fractals-分形"><a href="#Fractals-分形" class="headerlink" title="Fractals 分形"></a>Fractals 分形</h4><ul><li>自相似，理解为递归</li></ul><h4 id="Pros-amp-Cons-隐式表示利弊分析"><a href="#Pros-amp-Cons-隐式表示利弊分析" class="headerlink" title="Pros &amp; Cons 隐式表示利弊分析"></a>Pros &amp; Cons 隐式表示利弊分析</h4><ul><li>Pros<ul><li>函数描述几何形体，紧凑</li><li>容易查询，如inside object, distance to surface</li><li>good for ray-to-surface intersection</li><li>对于简单的物体，描述精确，且无采样造成的错误</li><li>容易处理拓扑结构的变化（例如，流体）</li></ul></li><li>Cons<ul><li>很难模拟复杂的形状</li></ul></li></ul><h3 id="几何的显式-Explicit-表示"><a href="#几何的显式-Explicit-表示" class="headerlink" title="几何的显式(Explicit)表示"></a>几何的显式(Explicit)表示</h3><h4 id="Intro-显式表示"><a href="#Intro-显式表示" class="headerlink" title="Intro - 显式表示"></a>Intro - 显式表示</h4><p><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 16.32.06.png" alt="截屏2023-04-15 16.32.06" style="zoom:33%;"></p><ul><li>所有点直接给出，或通过参数映射<ul><li>给出一个函数$f$，可将$uv$映射到$xyz$</li><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 13.39.50.png" alt="截屏2023-04-15 13.39.50" style="zoom:33%;"></li></ul></li><li>优点：采样简单，可直接通过已知的$uv$的出对应的$xyz$<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 13.48.06.png" alt="截屏2023-04-15 13.48.06" style="zoom:33%;"></li></ul></li><li>缺点：难以判断点是否在物体表面上/内/外<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 13.52.05.png" alt="截屏2023-04-15 13.52.05" style="zoom:33%;"></li></ul></li><li>按需选择表示方法</li></ul><h4 id="Point-Cloud-点云"><a href="#Point-Cloud-点云" class="headerlink" title="Point Cloud 点云"></a>Point Cloud 点云</h4><p><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 16.39.57.png" alt="截屏2023-04-15 16.39.57" style="zoom: 40%;"></p><h4 id="Polygon-Mesh"><a href="#Polygon-Mesh" class="headerlink" title="Polygon Mesh"></a>Polygon Mesh</h4><p><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 16.46.23.png" alt="截屏2023-04-15 16.46.23" style="zoom:40%;"></p><ul><li>如何表示用三角形面形成的物体：The Wavefront Object File (.obj) Format<ul><li>是一种存储vertices, normals, texture, coordinates和它们之间联系的文本文件<ul><li>如图，表示一个立方体的八个点（v点，vn法线，vt纹理坐标，f面联系 v/vt/vn）<img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 16.49.26.png" alt="截屏2023-04-15 16.49.26" style="zoom:50%;"></li></ul></li></ul></li></ul><h1 id="P11-Geometry-Curves-and-Surfaces"><a href="#P11-Geometry-Curves-and-Surfaces" class="headerlink" title="P11 Geometry (Curves and Surfaces)"></a>P11 Geometry (Curves and Surfaces)</h1><h2 id="Curves"><a href="#Curves" class="headerlink" title="Curves"></a>Curves</h2><ul><li>应用<ul><li>摄影机运动路径</li><li>动画路径</li><li>字体设计（矢量）</li></ul></li></ul><h3 id="Bézier-Curves"><a href="#Bézier-Curves" class="headerlink" title="Bézier Curves"></a>Bézier Curves</h3><ul><li>用一系列控制点，去定义一条曲线；属于显式的几何表示方法<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 17.07.15.png" alt="截屏2023-04-15 17.07.15" style="zoom:33%;"></li></ul></li></ul><h5 id="计算贝塞尔曲线：de-Casteljau-Algorithm德卡斯特里奥算法"><a href="#计算贝塞尔曲线：de-Casteljau-Algorithm德卡斯特里奥算法" class="headerlink" title="计算贝塞尔曲线：de Casteljau Algorithm德卡斯特里奥算法"></a>计算贝塞尔曲线：de Casteljau Algorithm德卡斯特里奥算法</h5><ul><li><p>计算思路：递归</p><ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 20.07.32.png" alt="截屏2023-04-15 20.07.32" style="zoom:40%;"></li></ul></li><li><p>计算步骤</p><ul><li><p>三个点：</p><ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 17.33.48.png" alt="截屏2023-04-15 17.33.48" style="zoom:40%;"></li><li><p>认为两个控制点间范围$(0,1)$</p></li><li><p>分别找到对应$t$的点的位置$b_0^1$和$b_1^1$，连接</p></li><li><p>再找到$b_0^1$$b_1^1$线段上$t$对应的点$b_0^2$</p></li><li><p>按上述方法，对$t$枚举，即可画出曲线</p></li></ul></li><li><p>四个点：</p><ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 20.06.24.png" alt="截屏2023-04-15 20.06.24" style="zoom:33%;"></li></ul></li></ul></li><li><p><strong>代数公式</strong></p><ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 20.16.38.png" alt="截屏2023-04-15 20.16.38" style="zoom:50%;"></li><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 20.12.16.png" alt="截屏2023-04-15 20.12.16" style="zoom:33%;"></li><li>$n+1$个控制点$(0,1,2,…,n)$可以得到$n$阶的贝塞尔曲线<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 20.21.57.png" alt="截屏2023-04-15 20.21.57" style="zoom:50%;"></li><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 20.22.12.png" alt="截屏2023-04-15 20.22.12" style="zoom:50%;"></li><li>$B_j^n(t) = C_n^i t^i (1-t)^{n-i}$：伯恩斯坦多项式<ul><li>其实是$[t+(1-t)]^n = 1^n$的二项式展开的每一项，因此下图y方向，和为1</li><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 20.31.19.png" alt="截屏2023-04-15 20.31.19" style="zoom:33%;"></li></ul></li></ul></li></ul></li><li><p>性质</p><ul><li><p><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 20.42.32.png" alt="截屏2023-04-15 20.42.32" style="zoom:40%;"></p></li><li><ol><li><p>必过起点和终点。则$t=0$时$b(0) = b_0$，$t=1$时$b(1) = b_3$</p></li><li><p>对三次控制点：切线$b’(0)=3(b_1-b_0)$，$b’(1) = 3(b_3-b_2)$。针对系数3，通过求导可知</p></li><li><p>对于仿射变换：针对控制点的变换，和针对曲线本身的变换，得到的结果相同</p></li><li><p>凸包性质：贝塞尔曲线在控制点所形成的凸包内</p><p><img src="/2023/04/15/Games101-P10-12/截屏2023-04-15 20.52.32.png" alt="截屏2023-04-15 20.52.32" style="zoom:33%;"></p></li></ol></li></ul></li></ul><h5 id="Piecewise-Bézier-Curves-逐段贝塞尔曲线"><a href="#Piecewise-Bézier-Curves-逐段贝塞尔曲线" class="headerlink" title="Piecewise Bézier Curves 逐段贝塞尔曲线"></a>Piecewise Bézier Curves 逐段贝塞尔曲线</h5><ul><li>思路<ul><li>问题：控制点难以直观控制曲线：<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-17 15.44.08.png" alt="截屏2023-04-17 15.44.08" style="zoom:33%;"></li></ul></li><li>解决：试图用四个控制点控制一段贝塞尔曲线：<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-17 15.46.42.png" alt="截屏2023-04-17 15.46.42" style="zoom:33%;"></li></ul></li></ul></li><li>连续情况<ul><li>$C^0$连续：前一段截止点 = 下一段起始点</li><li>$C^1$连续<img src="/2023/04/15/Games101-P10-12/截屏2023-04-18 09.41.41.png" alt="截屏2023-04-18 09.41.41" style="zoom:33%;"></li><li>$C^n$连续：n阶导数连续</li></ul></li></ul><h3 id="其他曲线"><a href="#其他曲线" class="headerlink" title="其他曲线"></a>其他曲线</h3><ul><li>Spline 样条曲线</li></ul><p><img src="/2023/04/15/Games101-P10-12/截屏2023-04-18 09.52.00.png" alt="截屏2023-04-18 09.52.00" style="zoom:40%;"></p><ul><li>B-Spline<ul><li>Base spline</li><li>局部性</li></ul></li><li>Nurbs</li></ul><h2 id="Surfaces"><a href="#Surfaces" class="headerlink" title="Surfaces"></a>Surfaces</h2><ul><li>Bicubic Bézier Surface<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-18 18.05.13.png" alt="截屏2023-04-18 18.05.13" style="zoom:33%;"></li><li>思路：<ul><li>u方向控制点得出四条贝塞尔曲线，每一时刻t在四条曲线上的四个控制点为v方向对应贝塞尔曲线的控制点；v方向贝塞尔曲线扫过的面为对应曲面</li><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-18 18.05.43.png" alt="截屏2023-04-18 18.05.43" style="zoom:33%;"></li><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-18 18.09.04.png" alt="截屏2023-04-18 18.09.04" style="zoom:40%;"></li></ul></li></ul></li><li>Mesh Operations: Geometry Processing<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-18 18.16.05.png" alt="截屏2023-04-18 18.16.05" style="zoom:50%;"></li></ul></li></ul><h1 id="P12-Geometry"><a href="#P12-Geometry" class="headerlink" title="P12 Geometry"></a>P12 Geometry</h1><h2 id="Mesh-Subdivision-upsampling"><a href="#Mesh-Subdivision-upsampling" class="headerlink" title="Mesh Subdivision (upsampling)"></a>Mesh Subdivision (upsampling)</h2><p><img src="/2023/04/15/Games101-P10-12/截屏2023-04-18 23.23.18.png" alt="截屏2023-04-18 23.23.18" style="zoom:33%;"></p><h3 id="Loop-Subdivision"><a href="#Loop-Subdivision" class="headerlink" title="Loop Subdivision"></a>Loop Subdivision</h3><ul><li><p><strong>只适用于三角形网格</strong></p></li><li><p>步骤</p><ul><li>增加三角面，$\times 4$<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-18 23.32.35.png" alt="截屏2023-04-18 23.32.35" style="zoom:50%;"></li></ul></li><li>使模型表面变光滑（调整顶点位置）<ul><li>新/旧顶点已不同形式改变</li><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-18 23.35.13.png" alt="截屏2023-04-18 23.35.13" style="zoom: 50%;"></li></ul></li></ul></li><li><p>更新顶点位置的规则</p><ul><li>对于新的（不为边界的）点<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-18 23.39.23.png" alt="截屏2023-04-18 23.39.23" style="zoom:33%;"></li></ul></li><li>对于旧的点 (e.g. degree 6 vertices here)<ul><li>n：顶点的度，即为顶点所连接的边的个数</li><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-18 23.45.07.png" alt="截屏2023-04-18 23.45.07" style="zoom:33%;"></li></ul></li></ul></li></ul><h3 id="Catmull-Clark-Subdivision-General-Mesh"><a href="#Catmull-Clark-Subdivision-General-Mesh" class="headerlink" title="Catmull-Clark Subdivision (General Mesh)"></a>Catmull-Clark Subdivision (General Mesh)</h3><ul><li><strong>适用于三角面和四边面</strong><ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-20 21.50.02.png" alt="截屏2023-04-20 21.50.02" style="zoom:33%;"><ul><li>奇异点：度不为4的点</li></ul></li><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-20 21.53.45.png" alt="截屏2023-04-20 21.53.45" style="zoom:33%;"><ul><li>非四边形面消失并引入奇异点</li></ul></li><li><img src="/2023/04/15/Games101-P10-12/IMG_2892.JPG" alt="IMG_2892" style="zoom:70%;"></li></ul></li><li>新顶点位置的规则<ul><li><img src="/2023/04/15/Games101-P10-12/截屏2023-04-20 22.02.25.png" alt="截屏2023-04-20 22.02.25" style="zoom: 33%;"></li></ul></li></ul><h3 id="结果对比"><a href="#结果对比" class="headerlink" title="结果对比"></a>结果对比</h3><p><img src="/2023/04/15/Games101-P10-12/截屏2023-04-20 22.05.17.png" alt="截屏2023-04-20 22.05.17" style="zoom:40%;"></p><h2 id="Mesh-Simplification-downsampling"><a href="#Mesh-Simplification-downsampling" class="headerlink" title="Mesh Simplification (downsampling)"></a>Mesh Simplification (downsampling)</h2><p><img src="/2023/04/15/Games101-P10-12/截屏2023-04-18 23.23.41.png" alt="截屏2023-04-18 23.23.41" style="zoom:33%;"></p><ul><li>目标：减少面数的同时，保持物体原有的大致形状</li><li>联系Mipmap（也可以联系LOD），依据情况做simplification</li></ul><h3 id="简化方法"><a href="#简化方法" class="headerlink" title="简化方法"></a>简化方法</h3><h4 id="Collapsing-An-Edge-边坍缩"><a href="#Collapsing-An-Edge-边坍缩" class="headerlink" title="Collapsing An Edge 边坍缩"></a>Collapsing An Edge 边坍缩</h4><p><a href="http://graphics.stanford.edu/courses/cs468-10-fall/LectureSlides/08_Simplification.pdf">http://graphics.stanford.edu/courses/cs468-10-fall/LectureSlides/08_Simplification.pdf</a></p><p>（距离其中一种简化方法）</p><p><img src="/2023/04/15/Games101-P10-12/截屏2023-04-20 22.18.03.png" alt="截屏2023-04-20 22.18.03" style="zoom:33%;"></p><ul><li>如何判断坍缩的边：Quadric Error Metrics (QEM二次误差度量)<ul><li>对顶点进行局部平均不是一个好主意</li><li>二次误差度量：新的顶点需满足到其所联系的面的距离平方和最小</li></ul></li><li>如何坍缩对面影响最小——二次度量误差最小<ul><li>基本思想：算每一条边的二次度量误差，从最小的开始坍缩</li><li>问题：坍缩一条边，相连的边发生变化，二次度量误差随之变化<ul><li>解决：堆，优先排序，取QEM最小的坍缩，并动态更新所被影响的边的QEM</li></ul></li></ul></li></ul><h2 id="Mesh-Regularization-same-triangles"><a href="#Mesh-Regularization-same-triangles" class="headerlink" title="Mesh Regularization (same #triangles)"></a>Mesh Regularization (same #triangles)</h2><p><img src="/2023/04/15/Games101-P10-12/截屏2023-04-18 23.24.00.png" alt="截屏2023-04-18 23.24.00" style="zoom:33%;"></p>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
            <tag> 几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P7-9 Shading</title>
      <link href="/2023/04/02/Games101-P7-9/"/>
      <url>/2023/04/02/Games101-P7-9/</url>
      
        <content type="html"><![CDATA[<ul><li>P7 Overview<ul><li>Blinn - Phong Diffuse Reflection Model<ul><li>Diffuse</li></ul></li></ul></li><li>P8 Overview<ul><li>Blinn - Phong Diffuse Reflection Model<ul><li>Specular</li><li>Ambient</li></ul></li><li>Shading Frequencies</li><li>Graphics Pipeline</li></ul></li><li>P9 Overview<ul><li>Barycentric coordinate 重心插值</li><li>Texture antialiasing (MIPMAP)</li><li>Application of texture </li></ul></li></ul><span id="more"></span><h1 id="P7-Shading-Illumination-Shading-and-Graphics-Pipeline"><a href="#P7-Shading-Illumination-Shading-and-Graphics-Pipeline" class="headerlink" title="P7 Shading (Illumination, Shading and Graphics Pipeline)"></a>P7 Shading (Illumination, Shading and Graphics Pipeline)</h1><ul><li>回顾：Model - View - Projection - Viewport - Rasterization<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-02 14.31.29.png" alt="截屏2023-04-02 14.31.29" style="zoom:33%;"></li></ul></li></ul><h2 id="Shading-Definition"><a href="#Shading-Definition" class="headerlink" title="Shading Definition"></a>Shading Definition</h2><ul><li>字典中：The darkening or coloring of an illustration or diagram with parallel lines or a block of color.</li><li>本课中：The process of <strong>applying a material</strong> to an object. // 不同材质和光线相互作用的方法不同</li></ul><h2 id="简单的着色例子：Blinn-Phong-Reflection-Model"><a href="#简单的着色例子：Blinn-Phong-Reflection-Model" class="headerlink" title="简单的着色例子：Blinn - Phong Reflection Model"></a>简单的着色例子：Blinn - Phong Reflection Model</h2><ul><li>Blinn - Phong Reflection Model是经验型模型，并不完全符合物理</li></ul><h3 id="Shading-in-Local"><a href="#Shading-in-Local" class="headerlink" title="Shading in Local"></a>Shading in Local</h3><ul><li>光——得出反射模型<img src="/2023/04/02/Games101-P7-9/截屏2023-04-06 20.33.25.png" alt="截屏2023-04-06 20.33.25" style="zoom:25%;"><ul><li>Specular Highlight 高光</li><li>Diffuse Reflection 漫反射光</li><li>Ambient Light 环境光：不是直接接收到的光照，是通过物体反射接收到的光照</li></ul></li><li>Shading Point：相机所观察到的点<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-08 17.08.35.png" alt="截屏2023-04-08 17.08.35" style="zoom: 50%;"></li><li>input：（一下所有向量只表示方向，均为单位向量，由两点向量归一化得到）<ul><li>Viewer direction, v：观测方向，shading point向相机连线的方向</li><li>Surface normal, n：法线方向</li><li>Light direction, l：光照方向，shading point向光源连线的方向</li><li>Surface Parameter(color, shininess, …)：表面属性</li></ul></li></ul></li><li>注意⚠️：Shading in Local只关注该点自身着色，产生明暗变化，不产生阴影，与shadow无关<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-06 20.41.25.png" alt="截屏2023-04-06 20.41.25" style="zoom:33%;"></li></ul></li></ul><h3 id="Diffuse-Reflection-漫反射"><a href="#Diffuse-Reflection-漫反射" class="headerlink" title="Diffuse Reflection 漫反射"></a>Diffuse Reflection 漫反射</h3><ul><li>漫反射<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-06 20.43.27.png" alt="截屏2023-04-06 20.43.27" style="zoom:25%;"></li></ul></li><li>为什么光以不同的角度照射到物体表面，得到的明暗不同<ul><li><strong>Lambert’s cosine law（Lambert余弦定理）：物体表面单位面积接收到的光照和$cos\theta(=n \cdot l)$成正比</strong>，直射接收到所有能量</li><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-06 20.47.32.png" alt="截屏2023-04-06 20.47.32"></li></ul></li><li>Light Falloff<ul><li>能量守恒，远近球壳能量相等；平方反比</li><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-06 20.59.29.png" alt="截屏2023-04-06 20.59.29" style="zoom: 25%;"><ul><li>推广：<strong>已知光源能量 &amp; shading point与光源间距离，可知有多少光可传播到shading point；结合Lambert’s cosine law，可得出diffuse reflection的表示方法</strong></li></ul></li></ul></li><li>Lambertian (Diffuse) Shading —— 漫反射最终着色<ul><li>光源光强$I$，距离$r$，计算基于世界坐标</li><li>$max(0, n \cdot l)$：避免$cos\theta&lt;0$光照反向，无意义</li><li>$k_d$漫反射系数，表示吸收和反射的能量，1白0黑，表示明暗；若$k_d$是vector3，则RGB三通道可表示颜色<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-06 21.05.53.png" alt="截屏2023-04-06 21.05.53" style="zoom: 33%;"></li><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-06 21.20.04.png" alt="截屏2023-04-06 21.20.04" style="zoom:33%;"></li></ul></li></ul></li><li>漫反射理论上各个方向反射均匀，各个方向所观测到的着色应一致</li></ul><h1 id="P8-Shading-Pipeline-and-Texture-Mapping"><a href="#P8-Shading-Pipeline-and-Texture-Mapping" class="headerlink" title="P8 Shading (Pipeline and Texture Mapping)"></a>P8 Shading (Pipeline and Texture Mapping)</h1><h2 id="Blinn-Phong-Model"><a href="#Blinn-Phong-Model" class="headerlink" title="Blinn - Phong Model"></a>Blinn - Phong Model</h2><h3 id="Specular-Term-高光"><a href="#Specular-Term-高光" class="headerlink" title="Specular Term 高光"></a>Specular Term 高光</h3><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 09.36.00.png" alt="截屏2023-04-07 09.36.00" style="zoom:33%;"><ul><li>$v$$和r$足够接近时，可得到高光项</li></ul></li><li>Blinn - Phong 模型中的trick<ul><li>​    <img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 09.43.05.png" alt="截屏2023-04-07 09.43.05" style="zoom:33%;"></li><li>备注：<ul><li><strong>$v$$和r$很接近$\iff$法线方向和半程向量($l$和$v$角平分线方向)很接近</strong>；$n\cdot h$越接近1，则观察到的镜面反射越强烈</li><li>镜面反射系数$k_s$通常认为是白色的</li><li>利用半程向量的Blinn - Phong模型是对计算反射方向$r$的简化计算。若直接$r\cdot v$，则是Phong模型。</li><li>$max(0, n \cdot h)^p$指数$p$的作用：限制高光范围<ul><li>下图最左，不做指数运算，则会看到很大的高光；$p$通常为100~200</li><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 09.52.26.png" alt="截屏2023-04-07 09.52.26" style="zoom:33%;"></li></ul></li></ul></li></ul></li><li>最终效果<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 09.55.47.png" alt="截屏2023-04-07 09.55.47" style="zoom:33%;"></li></ul></li></ul><h3 id="Ambient-Term-环境光"><a href="#Ambient-Term-环境光" class="headerlink" title="Ambient Term 环境光"></a>Ambient Term 环境光</h3><ul><li>假设所有点接收到的环境光相同，强度$I_a$，来自四面八方；假设是错的！<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 09.59.36.png" alt="截屏2023-04-07 09.59.36" style="zoom:33%;"></li></ul></li></ul><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><ul><li>叠加所有光效<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 10.01.33.png" alt="截屏2023-04-07 10.01.33" style="zoom: 50%;"></li></ul></li></ul><h2 id="Shading-Frequencies-着色频率"><a href="#Shading-Frequencies-着色频率" class="headerlink" title="Shading Frequencies 着色频率"></a>Shading Frequencies 着色频率</h2><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 10.08.19.png" alt="截屏2023-04-07 10.08.19" style="zoom:33%;"><ul><li>利用法线插值</li></ul></li></ul><h3 id="Flat-Shading-shade-each-triangle"><a href="#Flat-Shading-shade-each-triangle" class="headerlink" title="Flat Shading: shade each triangle"></a>Flat Shading: shade each triangle</h3><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 10.13.38.png" alt="截屏2023-04-07 10.13.38" style="zoom: 50%;"><ul><li>每一个面都是平的，只有一个本身的法线</li><li>针对以一个三角面进行着色</li></ul></li></ul><h3 id="Gouraud-Shading-shade-each-vertex"><a href="#Gouraud-Shading-shade-each-vertex" class="headerlink" title="Gouraud Shading: shade each vertex"></a>Gouraud Shading: shade each vertex</h3><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 10.16.24.png" alt="截屏2023-04-07 10.16.24" style="zoom:50%;"><ul><li>求出顶点法线，针对每一个顶点进行着色</li><li>三个顶点所确定的三角形，根据三个顶点的颜色进行插值</li></ul></li></ul><h3 id="Phong-Shading-shade-each-pixel"><a href="#Phong-Shading-shade-each-pixel" class="headerlink" title="Phong Shading: shade each pixel"></a>Phong Shading: shade each pixel</h3><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 10.20.37.png" alt="截屏2023-04-07 10.20.37" style="zoom:50%;"><ul><li>得出三个顶点的法线后，插值三个顶点间每一个像素的法线方向，针对每个像素着色</li></ul></li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 10.30.47.png" alt="截屏2023-04-07 10.30.47" style="zoom:50%;"><ul><li>效果好坏是相对的</li><li>当面数极高，高于像素数，Flat shading消耗少于Phong shading，而效果差异不大</li></ul></li></ul><h3 id="定义顶点法线方向"><a href="#定义顶点法线方向" class="headerlink" title="定义顶点法线方向"></a>定义顶点法线方向</h3><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 10.37.34.png" alt="截屏2023-04-07 10.37.34" style="zoom: 50%;"><ul><li><mark>顶点法线</mark><strong>：相邻面的法线方向加权平均(根据面积)，再归一化</strong></li></ul></li></ul><h3 id="定义像素法线方向"><a href="#定义像素法线方向" class="headerlink" title="定义像素法线方向"></a>定义像素法线方向</h3><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 10.41.34.png" alt="截屏2023-04-07 10.41.34" style="zoom:50%;"><ul><li><mark>逐像素的法线</mark><strong>：根据顶点法线，利用重心坐标(Barycentric interpolation)插值，而后归一化</strong></li></ul></li></ul><h2 id="Graphics-Real-time-Rendering-Pipeline-实时渲染-渲染管线"><a href="#Graphics-Real-time-Rendering-Pipeline-实时渲染-渲染管线" class="headerlink" title="Graphics (Real-time Rendering) Pipeline 实时渲染 渲染管线"></a>Graphics (Real-time Rendering) Pipeline 实时渲染 渲染管线</h2><h3 id="渲染管线概述"><a href="#渲染管线概述" class="headerlink" title="渲染管线概述"></a>渲染管线概述</h3><ul><li>概览<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-08 17.53.04.png" alt="截屏2023-04-08 17.53.04" style="zoom:50%;"></li></ul></li><li>attention<ul><li>MVP变换发生在顶点阶段<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-08 18.05.29.png" alt="截屏2023-04-08 18.05.29" style="zoom:50%;"></li></ul></li><li>光栅化<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-08 18.06.17.png" alt="截屏2023-04-08 18.06.17" style="zoom:50%;"></li></ul></li><li>深度缓存<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-08 18.12.15.png" alt="截屏2023-04-08 18.12.15" style="zoom:50%;"></li></ul></li><li>Shading可发生在不同阶段，<strong>顶点的着色发生在顶点阶段，像素着色发生在Fragment阶段</strong><ul><li>eg：Gouraud shading发生在顶点阶段；Phong shading发生在Fragment阶段（需像素产生后进行</li><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-08 18.15.07.png" alt="截屏2023-04-08 18.15.07" style="zoom:50%;"></li></ul></li><li>Texture Mapping 纹理映射<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-08 18.19.29.png" alt="截屏2023-04-08 18.19.29" style="zoom:50%;"></li></ul></li></ul></li></ul><h3 id="Shader-Programs"><a href="#Shader-Programs" class="headerlink" title="Shader Programs"></a>Shader Programs</h3><ul><li><p>关于shader</p><ul><li>本质是可以通过API在硬件上执行的语言</li><li>分顶点shader和fragment shader，每个顶点/fragment执行一次。shader程序对任何顶点/像素通用，不用for循环</li></ul></li><li><p>一个像素着色器的例子</p><ul><li><p>关于像素着色器：通过程序写出，如何计算出像素最终的颜色，并输出</p></li><li><p><img src="/2023/04/02/Games101-P7-9/截屏2023-04-08 18.23.56.png" alt="截屏2023-04-08 18.23.56" style="zoom: 50%;"></p></li><li><pre><code class="lang-glsl">uniform sampler2D myTexture;    // program parameter；纹理全局变量uniform vec3 lightDir;    // program parameter；光照方向全局变量varying vec2 uv;    // per fragment value (interp. by rasterizer)；插值varying vec3 norm;    // per fragment value (interp. by rasterizer)；插值void diffuseShader()&#123;    vec3 kd;    // 漫反射系数    kd = texture2d(myTexture, uv);    // material color from texture     // Phong模型漫反射计算    kd *= clamp(dot(–lightDir, norm), 0.0, 1.0);    // Lambertian shading model；认为入射方向向内，因而lightDir为负    gl_FragColor = vec4(kd, 1.0);    // output fragment color&#125;</code></pre></li></ul></li><li><p>IQ大神的shader：Inigo Quilez, <a href="http://shadertoy.com/view/ld3Gz2">http://shadertoy.com/view/ld3Gz2</a></p><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-08 19.16.10.png" alt="截屏2023-04-08 19.16.10" style="zoom:50%;"></li><li>大神博客：<a href="https://iquilezles.org/">https://iquilezles.org/</a></li><li>大神油管：<a href="https://www.youtube.com/@InigoQuilez">https://www.youtube.com/@InigoQuilez</a></li></ul></li></ul><h2 id="Texture-Mapping-纹理映射"><a href="#Texture-Mapping-纹理映射" class="headerlink" title="Texture Mapping 纹理映射"></a>Texture Mapping 纹理映射</h2><ul><li><p><mark>注意</mark>⚠️：接下来的配图有点儿掉san🥵</p></li><li><p>思路：共用同一个模型，但漫反射系数发生了改变；需寻找一种方法，定义一个物体上任意一点的属性</p></li><li>Surfaces are 2D:  Every 3D surface point also has a place where it goes in the 2D image (texture).<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-10 11.21.37.png" alt="截屏2023-04-10 11.21.37" style="zoom:50%;"></li></ul></li><li>Texture Applied to Surface<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-10 11.24.22.png" alt="截屏2023-04-10 11.24.22" style="zoom:50%;"></li></ul></li><li>Visualization of Texture Coordinates<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-10 12.34.17.png" alt="截屏2023-04-10 12.34.17" style="zoom:50%;"></li><li>uv纹理范围在$(0,1)$</li></ul></li><li>Texture Applied to Surface<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-10 12.37.36.png" alt="截屏2023-04-10 12.37.36" style="zoom:50%;"></li></ul></li><li>纹理被重复利用<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-10 12.41.39.png" alt="截屏2023-04-10 12.41.39" style="zoom: 50%;"></li></ul></li><li>关于三角形内部点的uv值：通过顶点uv和重心坐标插值得出</li></ul><h1 id="P9-Shading-Texture-Mapping-cont"><a href="#P9-Shading-Texture-Mapping-cont" class="headerlink" title="P9 Shading (Texture Mapping cont.)"></a>P9 Shading (Texture Mapping cont.)</h1><h2 id="Interpolation-Across-Triangles-Barycentric-Coordinates-重心坐标"><a href="#Interpolation-Across-Triangles-Barycentric-Coordinates-重心坐标" class="headerlink" title="Interpolation Across Triangles: Barycentric Coordinates 重心坐标"></a>Interpolation Across Triangles: Barycentric Coordinates 重心坐标</h2><ul><li>三角形内部插值的作用：通过顶点的值，完成顶点间片元（像素）的平滑过度</li><li>插值的内容：texture coordinates, color, normal vectors…</li><li><strong>重心插值数学基础</strong><ul><li>重心坐标概念基础<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 09.42.53.png" alt="截屏2023-04-13 09.42.53" style="zoom: 33%;"></li><li>三角形<strong>内</strong>任意一点$(x,y)$都可以写成三个顶点的线性组合：$(x,y) = \alpha A+\beta B + \gamma C$；其中，$\alpha + \beta + \gamma = 1$，且$\alpha,\beta,\gamma &gt; 0$。重心坐标即为$(\alpha,\beta,\gamma)$</li><li>$\alpha + \beta + \gamma = 1$表明点在三角形所在平面内，$\alpha,\beta,\gamma &gt; 0$表明点在三角形内部</li></ul></li><li>重心坐标求法：利用面积<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 09.48.47.png" alt="截屏2023-04-13 09.48.47" style="zoom:33%;"></li></ul></li><li>三角形自身重心的性质：重心与三角形顶点连线所得的三角形面积相等。可得：<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 09.55.12.png" alt="截屏2023-04-13 09.55.12" style="zoom:33%;"></li></ul></li><li>导出公式<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 10.00.08.png" alt="截屏2023-04-13 10.00.08" style="zoom:33%;"></li></ul></li></ul></li><li>三角形内重心坐标的应用<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 10.02.36.png" alt="截屏2023-04-13 10.02.36" style="zoom:33%;"><ul><li><mark>注意</mark>⚠️：三角形投影后形状发生拉伸，重心坐标会改变。三维空间中三角形应在三维空间中插值，不能在二维投影屏面插值。</li></ul></li></ul></li></ul><h2 id="Applying-Textures-纹理应用"><a href="#Applying-Textures-纹理应用" class="headerlink" title="Applying Textures 纹理应用"></a>Applying Textures 纹理应用</h2><ul><li>纹理映射举例——Diffuse Color<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 10.13.15.png" alt="截屏2023-04-13 10.13.15" style="zoom:33%;"></li><li>通过对顶点插值，得出每一个片元(x, y)的uv坐标；</li><li>随后在纹理上查询该片元uv值，得出该片元的颜色texcolor；</li><li>将漫反射系数$k_d$设置为texcolor。</li></ul></li></ul><h3 id="Texture-Magnification-纹理分辨率小，需放大"><a href="#Texture-Magnification-纹理分辨率小，需放大" class="headerlink" title="Texture Magnification(纹理分辨率小，需放大)"></a>Texture Magnification(纹理分辨率小，需放大)</h3><ul><li>插值方法：Nearest, Bilinear, Bicubic<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 10.25.17.png" alt="截屏2023-04-13 10.25.17" style="zoom:33%;"></li></ul></li></ul><h4 id="Nearest"><a href="#Nearest" class="headerlink" title="Nearest"></a>Nearest</h4><ul><li>屏幕pixel颜色应用最近的纹理texel的颜色，导致多个相邻pixel被映射成一个texel</li></ul><h4 id="Bilinear-Interpolation-双线性插值"><a href="#Bilinear-Interpolation-双线性插值" class="headerlink" title="Bilinear Interpolation 双线性插值"></a>Bilinear Interpolation 双线性插值</h4><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 10.39.27.png" alt="截屏2023-04-13 10.39.27" style="zoom: 50%;"></li><li>寻找一个pixel(红色)附近的四个texel(黑色)，定义$t$和$s$范围都为$(0,1)$</li><li>由此插值后，$u_{00},u_{01},u_{10},u_{11}$四个texel所围成的区域内，pixel可实现平滑过度</li></ul><h4 id="Bicubic-Interpolation"><a href="#Bicubic-Interpolation" class="headerlink" title="Bicubic Interpolation"></a>Bicubic Interpolation</h4><ul><li>利用pixel附近的十六个texel，进行三次的插值</li></ul><h3 id="Texture-Magnification-纹理分辨率大，需缩小"><a href="#Texture-Magnification-纹理分辨率大，需缩小" class="headerlink" title="Texture Magnification(纹理分辨率大，需缩小)"></a>Texture Magnification(纹理分辨率大，需缩小)</h3><ul><li>问题：产生摩尔纹和锯齿<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 16.57.04.png" alt="截屏2023-04-13 16.57.04" style="zoom:50%;"></li><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 16.59.38.png" alt="截屏2023-04-13 16.59.38" style="zoom:50%;"></li></ul></li><li>Antialiasing — Supersampling 超采样？<ul><li>可以，但消耗太大</li><li>当纹理严重缩小时，多个texel会集中在一个pixel中。一个pixel中，信号频率太快，而采样频率跟不上</li></ul></li><li>采样会引起走样，因此引入不采样的思路。<ul><li>理想：可直接得知像素覆盖的texel的平均值$\Rightarrow$给定任何一个texel区域即可得知平均值</li><li>引入Range Query范围查询</li></ul></li></ul><h2 id="Mipmap-Allowing-fast-approx-square-range-queries"><a href="#Mipmap-Allowing-fast-approx-square-range-queries" class="headerlink" title="Mipmap: Allowing (fast, approx., square) range queries"></a>Mipmap: Allowing (fast, approx., square) range queries</h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><ul><li>mipmap做近似的、正方形的查询</li><li>如下图，Level提升以及，分辨率减半</li></ul><p><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 20.07.23.png" alt="截屏2023-04-13 20.07.23" style="zoom: 50%;"></p><p><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 20.53.07.png" alt="截屏2023-04-13 20.53.07" style="zoom: 33%;"></p><ul><li>What is the storage overhead of a mipmap?<ul><li>原图存储量为1，而后每提高一个Level，存储量都变为前者的四分之一</li><li>$1+\frac 1 4++\frac 1 {16}+\frac 1 {64} + … = \frac 4 3$ 即变为原来的三分之四</li></ul></li></ul><h3 id="如何计算Mipmap的Level-D-得出范围查询的面积"><a href="#如何计算Mipmap的Level-D-得出范围查询的面积" class="headerlink" title="如何计算Mipmap的Level D(得出范围查询的面积)"></a>如何计算Mipmap的Level D(得出范围查询的面积)</h3><ul><li><p>思路</p><ul><li>计算一个像素在纹理上的覆盖面积，$D=log_2L$</li><li>求出这个像素对应的纹理在第几Level会变到一个像素内</li><li>查找对应Level的Mipmap，得出平均值</li></ul></li><li><p>将像素分别映射到纹理</p><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 21.05.43.png" alt="截屏2023-04-13 21.05.43" style="zoom: 33%;"></li></ul></li><li>计算映射到纹理后，各个像素间的距离，$L$取距离的最大值。用正方形近似不规则四边形<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 21.09.22.png" alt="截屏2023-04-13 21.09.22" style="zoom:50%;"></li></ul></li><li>得出$D=log_2L$，在根据预先计算好的Mipmap进行对应D的范围查询<ul><li>举例：假如$L$为4（正方形$4 \times 4$），则该区域在$D=2$时，会变为一个像素（正方形$1 \times 1$）</li></ul></li><li>结果<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 21.29.28.png" alt="截屏2023-04-13 21.29.28" style="zoom:40%;"></li><li>问题：渐变不连续，D不为整数时接缝明显</li><li>解决：Trilinear Interpolation进行过渡</li></ul></li></ul><h3 id="Mipmap间过渡-Trilinear-Interpolation-三线形插值"><a href="#Mipmap间过渡-Trilinear-Interpolation-三线形插值" class="headerlink" title="Mipmap间过渡: Trilinear Interpolation 三线形插值"></a>Mipmap间过渡: <mark>Trilinear Interpolation 三线形插值</mark></h3><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 21.34.22.png" alt="截屏2023-04-13 21.34.22" style="zoom:50%;"><ul><li>两层Level分别先做Bilinear Interpolation，所得的插值结果再进行一次插值</li></ul></li><li>结果<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 21.42.39.png" alt="截屏2023-04-13 21.42.39" style="zoom:40%;"></li></ul></li><li><p>三线形插值优点</p><ul><li>得到完全连续的过渡</li><li>开销小：做两次查询，一次插值</li></ul></li><li><p>三线形插值的局限性：远处overblur</p><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-14 15.05.38.png" alt="截屏2023-04-14 15.05.38" style="zoom:33%;"></li></ul></li></ul><h3 id="Anisotropic-Filtering各向异性过滤；EWA-Fliter"><a href="#Anisotropic-Filtering各向异性过滤；EWA-Fliter" class="headerlink" title="Anisotropic Filtering各向异性过滤；EWA Fliter"></a>Anisotropic Filtering各向异性过滤；EWA Fliter</h3><ul><li>解决<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-14 15.08.08.png" alt="截屏2023-04-14 15.08.08" style="zoom:33%;"></li></ul></li><li>各向异性过滤可解决mipmap只能查询正方形的问题。（可对单一方向压缩剧烈的长条形区域进行范围查询，不必限制在正方形内）<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-14 15.11.13.png" alt="截屏2023-04-14 15.11.13" style="zoom:50%;"></li></ul></li><li>但是各向异性查询对如下对角线方向倾斜的矩形仍无法完美近似，因此也存在局限性<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-14 15.11.39.png" alt="截屏2023-04-14 15.11.39" style="zoom:50%;"></li></ul></li><li>解决：EWA filtering<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-14 15.17.18.png" alt="截屏2023-04-14 15.17.18" style="zoom:40%;"></li></ul></li></ul><h2 id="Application-of-texture"><a href="#Application-of-texture" class="headerlink" title="Application of texture"></a>Application of texture</h2><ul><li>纹理应用范围很广<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-14 16.53.31.png" alt="截屏2023-04-14 16.53.31" style="zoom:33%;"></li></ul></li></ul><h3 id="Environment-Map-环境光贴图"><a href="#Environment-Map-环境光贴图" class="headerlink" title="Environment Map 环境光贴图"></a>Environment Map 环境光贴图</h3><ul><li><p>运用环境光贴图的假设前提：光来自无限远处，贴图只记录方向信息，无实际深度意义</p><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-14 16.54.12.png" alt="截屏2023-04-14 16.54.12" style="zoom:50%;"></li></ul></li><li><p>Spherical Environment Map</p><ul><li>环境光贴图被记录在球面上<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-14 21.59.21.png" alt="截屏2023-04-14 21.59.21" style="zoom:50%;"></li></ul></li><li>展开会产生扭曲，无法均匀描述<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-14 22.00.51.png" alt="截屏2023-04-14 22.00.51" style="zoom:50%;"></li></ul></li></ul></li><li>利用 Cube Map 解决扭曲问题<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-14 22.01.59.png" alt="截屏2023-04-14 22.01.59" style="zoom:50%;"></li><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-14 22.02.46.png" alt="截屏2023-04-14 22.02.46" style="zoom:50%;"></li></ul></li></ul><h3 id="Bump-Map-凹凸贴图"><a href="#Bump-Map-凹凸贴图" class="headerlink" title="Bump Map 凹凸贴图"></a>Bump Map 凹凸贴图</h3><ul><li><p>区分：高度贴图和法线贴图</p><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-14 22.25.57.png" alt="截屏2023-04-14 22.25.57"><ul><li><ol><li>base color</li><li>base color + normal：法线贴图修改表面光照</li><li>base color + normal + height：高度贴图实现遮挡</li></ol></li></ul></li></ul></li><li><p><strong>Height map: 定义在法线基础上，上下位移的相对高度</strong></p><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-14 22.25.06.png" alt="截屏2023-04-14 22.25.06" style="zoom:50%;"></li></ul></li><li><p>作用</p><ul><li>在不增加三角面的基础上，增加表面细节<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-14 22.47.51.png" alt="截屏2023-04-14 22.47.51" style="zoom:33%;"></li></ul></li></ul></li><li><p><strong>法线的计算</strong></p><ul><li><p><strong>Case1: flatland</strong> 图中原本面为平面，蓝色面由凹凸贴图定义得到：<img src="/2023/04/02/Games101-P7-9/截屏2023-04-14 22.59.32.png" alt="截屏2023-04-14 22.59.32" style="zoom:33%;"></p><ul><li><p>思路：</p><ol><li><p>平面上$p$点原本法线：$n(p) = (0,1)$</p></li><li><p>应用凹凸贴图后，$p$点切线方向：$dp = c*[h(p+1) - h(p)]$ (其中$c$为常数，用于表示凹凸贴图的影像大小)</p></li><li><p>由于法线垂直于切线，即可知：$n(p) = (-dp, 1).normalized()$</p></li></ol></li></ul></li><li><p><strong>Case2: 3D</strong></p><ul><li>思路：<ul><li>原平面表面法线：$n(p) = (0,0,1)$</li><li>对贴图在三维空间的$u$方向和$v$方向求偏导：<ul><li>$dp/du = c1 * [h(u+1) - h(u)]$</li><li>$dp/dv = c2 * [h(v+1) - h(v)]$</li></ul></li><li>得出切线方向：$n(p) = (-dp/du, -dp/dv, 1).normalized()$</li></ul></li><li>注意⚠️：以上计算均在切线空间、局部空间进行<mark>（记得取补这块内容！！）</mark></li></ul></li></ul></li><li><p><strong>Displacement Map 置换贴图</strong></p><ul><li><p>对顶点进行真实的位移</p><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-15 00.24.27.png" alt="截屏2023-04-15 00.24.27" style="zoom:50%;"></li></ul></li><li><p>区分：bump vs. normal vs. displacement </p><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-14 22.56.49.png" alt="截屏2023-04-14 22.56.49"></li></ul></li><li><p>代价：三角面数需足够多，需高于置换贴图的采样频率</p><ul><li>理想：根据置换贴图采样频率，按需规定模型细分精度</li><li>DX中解决方法：动态曲面细分Dynamic Tessellation</li></ul></li></ul></li></ul><h3 id="三维纹理"><a href="#三维纹理" class="headerlink" title="三维纹理"></a>三维纹理</h3><ul><li>3D Procedural Noise + Solid Modeling<ul><li>纹理是实心的球，可以定义三维空间中任意一点的纹理。</li><li>并没有生成对应的内部纹理图，但是定义了一个三维空间中的噪声函数(Perlin Noise)，可以通过解析式算出任意一点的噪声</li><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-15 00.38.39.png" alt="截屏2023-04-15 00.38.39" style="zoom:33%;"></li></ul></li></ul><h3 id="Provide-Precomputed-预先计算的-Shading"><a href="#Provide-Precomputed-预先计算的-Shading" class="headerlink" title="Provide Precomputed(预先计算的) Shading"></a>Provide Precomputed(预先计算的) Shading</h3><ul><li>eg：提前计算AO Map，与原有shader做multiple</li></ul><p><img src="/2023/04/02/Games101-P7-9/截屏2023-04-15 00.44.30.png" alt="截屏2023-04-15 00.44.30" style="zoom:50%;"></p><h3 id="3D-Textures-and-Volume-Rendering"><a href="#3D-Textures-and-Volume-Rendering" class="headerlink" title="3D Textures and Volume Rendering"></a>3D Textures and Volume Rendering</h3><ul><li>eg：医学CT影像，扫描出的数据处理成三维纹理以呈现</li></ul><p><img src="/2023/04/02/Games101-P7-9/截屏2023-04-15 00.49.03.png" alt="截屏2023-04-15 00.49.03" style="zoom:50%;"></p>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
            <tag> 着色 </tag>
            
            <tag> 渲染管线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P5-6 Rasterization</title>
      <link href="/2023/03/27/Games101-P5-6/"/>
      <url>/2023/03/27/Games101-P5-6/</url>
      
        <content type="html"><![CDATA[<ul><li>P5 Overview<ul><li>Finishing up viewing<ul><li>Viewport transformation </li></ul></li><li>Rasterization<ul><li>Different raster displays</li><li>Rasterizing a triangle</li></ul></li></ul></li><li><p>P6 Overview</p><ul><li><p>Antialiasing</p><ul><li>采样简单理论</li><li>实际图形学中的反走样</li></ul></li><li><p>Visible /  Occlusion（讲解部分在P7开始处）</p><ul><li>Z - Buffer</li></ul></li></ul></li><li><p>补充！</p><ul><li>shadows</li></ul></li></ul><span id="more"></span><h1 id="P5-Rasterization-Triangles"><a href="#P5-Rasterization-Triangles" class="headerlink" title="P5 Rasterization(Triangles)"></a>P5 Rasterization(Triangles)</h1><h2 id="Finishing-up-viewing"><a href="#Finishing-up-viewing" class="headerlink" title="Finishing up viewing"></a>Finishing up viewing</h2><h3 id="Viewport-transformation-视口变换"><a href="#Viewport-transformation-视口变换" class="headerlink" title="Viewport transformation 视口变换"></a>Viewport transformation 视口变换</h3><h4 id="Intro-摄影机"><a href="#Intro-摄影机" class="headerlink" title="Intro - 摄影机"></a>Intro - 摄影机</h4><ul><li>定义视锥的两个概念<ul><li>长宽比</li><li>FOV</li></ul></li><li>用近平面lrbt表示fov<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-03-27 21.09.36.png" alt="截屏2023-03-27 21.09.36" style="zoom:33%;"></li></ul></li><li>What’s after MVP?<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-03-27 21.22.19.png" alt="截屏2023-03-27 21.22.19" style="zoom: 33%;"></li></ul></li></ul><h4 id="Intro-屏幕"><a href="#Intro-屏幕" class="headerlink" title="Intro - 屏幕"></a>Intro - 屏幕</h4><ul><li>什么是屏幕<ul><li>抽象地认为是二维数组，其中每个元素都是一个像素</li><li>数组的大小就是屏幕分辨率</li><li>一种典型的光栅化显示</li></ul></li><li>Raster光栅<ul><li>Rasterize == drawing onto the screen</li></ul></li><li><p>Pixel像素</p><ul><li>课程中简单地认为是一个个小方块</li><li>实际是RGB的空间混合</li></ul></li><li><p>定义屏幕空间</p><ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-03-27 21.28.54.png" alt="截屏2023-03-27 21.28.54" style="zoom: 33%;"><ul><li>（x，y）形式，每个像素坐标均为整数。蓝色坐标为（2，1），因为从0开始</li><li>屏幕上，像素坐标范围是（0，0）到（width - 1，height - 1）</li><li>像素中心坐标是（x+0.5，y+0.5）</li><li>屏幕范围（0，0）到（width，height）</li></ul></li></ul></li></ul><h4 id="视口变换：将-1-1-3-立方体转化到整个屏幕"><a href="#视口变换：将-1-1-3-立方体转化到整个屏幕" class="headerlink" title="视口变换：将$[-1, 1]^3$立方体转化到整个屏幕"></a>视口变换：将$[-1, 1]^3$立方体转化到整个屏幕</h4><ul><li>Transform xy plane: $[-1, 1]^2$ to  $[0 ,width] * [0, height]$，先不管$z$<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-03-27 21.42.23.png" alt="截屏2023-03-27 21.42.23" style="zoom:33%;"></li><li>视口转化矩阵<ul><li>$M_{viewport} = \begin{pmatrix} \frac{width}2 &amp; 0 &amp; 0 &amp; \frac{width}2\\  0&amp; \frac{height}2 &amp; 0 &amp; \frac{height}2 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0&amp; 1 \\ \end{pmatrix}$<ul><li>左上角矩阵缩放</li><li>缩放后原点是中心，需将左下角平移到原点</li></ul></li></ul></li></ul></li></ul><h2 id="光栅化-Rasterizing-Triangles-into-Pixels"><a href="#光栅化-Rasterizing-Triangles-into-Pixels" class="headerlink" title="光栅化 - Rasterizing Triangles into Pixels"></a>光栅化 - Rasterizing Triangles into Pixels</h2><h3 id="Frame-Buffer-Memory-of-a-Raster-Display"><a href="#Frame-Buffer-Memory-of-a-Raster-Display" class="headerlink" title="Frame Buffer: Memory of a Raster Display"></a>Frame Buffer: Memory of a Raster Display</h3><ul><li>内存空间的一块区域映射到屏幕上，成为显示的图像</li></ul><h3 id="Polygon-Mesh"><a href="#Polygon-Mesh" class="headerlink" title="Polygon Mesh"></a>Polygon Mesh</h3><ul><li>intro<ul><li>已完成：将三维空间顶点变换到屏幕空间中</li><li>下一步：将多边形拆成不同的像素（光栅化的过程</li></ul></li><li>Triangle Mesh<ul><li>基础性质<ul><li>最基础的多边形</li><li>任何其他多边形都可拆成三角形</li></ul></li><li>独特性质<ul><li>三角形三点必在同一平面</li><li>三角形内外定义清晰（可以通过叉积直接定义三角形内外</li><li>三角形内部的点，可根据已知三个点的信息进行渐变（lerp插值）</li></ul></li></ul></li><li><img src="/2023/03/27/Games101-P5-6/截屏2023-03-31 14.57.13.png" alt="截屏2023-03-31 14.57.13" style="zoom:33%;"></li></ul><h3 id="Sampling-采样"><a href="#Sampling-采样" class="headerlink" title="Sampling 采样"></a>Sampling 采样</h3><ul><li><p>采样函数（一维</p><ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-03-31 15.00.30.png" alt="截屏2023-03-31 15.00.30" style="zoom:33%;"></li></ul></li><li><p>判断像素中心是否在三角形内</p><ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 09.38.41.png" alt="截屏2023-04-01 09.38.41" style="zoom:25%;"></li></ul></li><li><p>二维采样</p><ul><li><pre><code class="lang-c++">for (int x = 0; x&lt; xmax; x++)  for (int y = 0; y &lt; ymax; y++)    image[x][y] = inside(tri, x + 0.5, y+ 0.5); //三角形中心要+0.5</code></pre></li></ul></li><li><p>inside(tri, x, y)具体如何实现：向量叉积</p><ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 09.46.23.png" alt="截屏2023-04-01 09.46.23" style="zoom:25%;"></li><li>$\overrightarrow{P_1P_2} \times \overrightarrow{P_1Q}$ 得到$Q$在$P_1P_2$左边，$P_0P_1$同理</li><li>$\overrightarrow{P_2P_0} \times \overrightarrow{P_2Q}$ 得到$Q$在$P_2P_0$右边</li><li>综上，$Q$在三角形外</li></ul></li><li><p>边界处理：OpenGL认为上左在内，下右在外</p></li></ul><h3 id="光栅化加速优化"><a href="#光栅化加速优化" class="headerlink" title="光栅化加速优化"></a>光栅化加速优化</h3><ul><li>包围盒Bounding Box（AABB）<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 10.03.48.png" alt="截屏2023-04-01 10.03.48" style="zoom:25%;"></li></ul></li><li>每一行只考虑最左和最右，相当于一行一个Bounding Box<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 10.04.55.png" alt="截屏2023-04-01 10.04.55" style="zoom:25%;"></li><li>适用于瘦长三角形</li></ul></li></ul><h3 id="实际屏幕的光栅化-Rasterization-on-Real-Displays"><a href="#实际屏幕的光栅化-Rasterization-on-Real-Displays" class="headerlink" title="实际屏幕的光栅化 Rasterization on Real Displays"></a>实际屏幕的光栅化 Rasterization on Real Displays</h3><ul><li>加色<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 10.23.06.png" alt="截屏2023-04-01 10.23.06" style="zoom:25%;"></li></ul></li><li>减色<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 10.23.30.png" alt="截屏2023-04-01 10.23.30" style="zoom:25%;"></li></ul></li></ul><h3 id="光栅化问题"><a href="#光栅化问题" class="headerlink" title="光栅化问题"></a>光栅化问题</h3><ul><li>锯齿<ul><li>像素有一定大小，采样率不够高，导致图像走样</li></ul></li></ul><h1 id="P6-Rasterization-Antialiasing-and-Z-Buffer-反走样和深度缓冲"><a href="#P6-Rasterization-Antialiasing-and-Z-Buffer-反走样和深度缓冲" class="headerlink" title="P6 Rasterization(Antialiasing and Z-Buffer 反走样和深度缓冲)"></a>P6 Rasterization(Antialiasing and Z-Buffer 反走样和深度缓冲)</h1><h2 id="采样理论"><a href="#采样理论" class="headerlink" title="采样理论"></a>采样理论</h2><ul><li>Artifact：黑话。泛指图形学中的error/mistake/inaccuracies<ul><li>锯齿</li><li>摩尔纹</li><li>车轮倒转效应</li></ul></li><li><strong>产生Artifact的本质原因：信号速度太快，而采样速度跟不上</strong></li></ul><h2 id="如何反走样"><a href="#如何反走样" class="headerlink" title="如何反走样"></a>如何反走样</h2><ul><li><strong>基本思想</strong>：前进行Blur，本质是滤(高频)波；再进行采样<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 10.48.46.png" alt="截屏2023-04-01 10.48.46" style="zoom:33%;"></li><li>不可以先采样，再滤波（先采样的话，混叠的信号已然存在，再进行滤波也无法消除）<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 10.52.16.png" alt="截屏2023-04-01 10.52.16" style="zoom:25%;"></li></ul></li></ul></li></ul><h2 id="Frequency-Domain-频域"><a href="#Frequency-Domain-频域" class="headerlink" title="Frequency Domain 频域"></a>Frequency Domain 频域</h2><h3 id="前置知识-信号处理"><a href="#前置知识-信号处理" class="headerlink" title="前置知识 - 信号处理"></a>前置知识 - 信号处理</h3><ul><li>傅里叶级数展开：任何一个周期函数都可以写成一系列sin和cos的线性组合，和常数项<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 11.07.27.png" alt="截屏2023-04-01 11.07.27" style="zoom:33%;"></li></ul></li><li>傅里叶变换和傅里叶级数展开<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 11.13.01.png" alt="截屏2023-04-01 11.13.01" style="zoom:33%;"><ul><li>通过傅里叶展开可知，上述函数可展开成不同频率的函数</li></ul></li></ul></li></ul><h3 id="走样"><a href="#走样" class="headerlink" title="走样"></a>走样</h3><ul><li>对于傅里叶展开后的函数采样，高频部分出现走样<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 11.17.29.png" alt="截屏2023-04-01 11.17.29" style="zoom:33%;"></li><li><strong>奈奎斯特采样定理</strong>：采样频率要大于信号最高频率的2倍，才能无失真的保留信号的完整信息</li></ul></li><li><strong>走样</strong>：同样的一种采样方法，采样两种不同频率的信号，得出的结果无法进行区分<ul><li>对高频信号通过低频采样出现的走样<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 11.27.15.png" alt="截屏2023-04-01 11.27.15" style="zoom:33%;"></li></ul></li></ul></li></ul><h3 id="Filtering-滤波"><a href="#Filtering-滤波" class="headerlink" title="Filtering 滤波"></a>Filtering 滤波</h3><ul><li>滤波：把某个特定频率抹去</li><li>对图像进行傅里叶变换（变成频域空间<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 16.19.46.png" alt="截屏2023-04-01 16.19.46"><ul><li>右图，中心为最低频。图像细节为高频信息</li><li>右图十字出现原因：图片在平面上平铺，左右边界和上下边界交界处信号变化剧烈，使得四个方向出现高频信号。</li></ul></li></ul></li><li>对图像进行高通滤波<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 16.25.55.png" alt="截屏2023-04-01 16.25.55"></li></ul></li><li>对图像进行低糖滤波<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 16.26.46.png" alt="截屏2023-04-01 16.26.46"></li></ul></li><li><p>中通滤波</p><ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 16.40.29.png" alt="截屏2023-04-01 16.40.29"></li><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 16.41.21.png" alt="截屏2023-04-01 16.41.21"><h4 id="Fliter-Convolution-卷积-Averaging"><a href="#Fliter-Convolution-卷积-Averaging" class="headerlink" title="Fliter = Convolution 卷积 ( = Averaging)"></a>Fliter = Convolution 卷积 ( = Averaging)</h4></li></ul></li><li><p>滤波器和卷积效果相近，但原理不同</p></li><li><p>卷积补充：<a href="https://www.zhihu.com/question/22298352/answer/228543288">如何通俗易懂地理解卷积</a></p><ul><li>卷积可帮助实现平滑算法<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 17.47.54.png" alt="截屏2023-04-01 17.47.54" style="zoom:50%;"></li><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 17.48.40.png" alt="截屏2023-04-01 17.48.40" style="zoom:50%;"></li><li>计算过程说明<img src="/2023/03/27/Games101-P5-6/卷积.gif" alt="卷积"></li><li>计算过程模拟<img src="/2023/03/27/Games101-P5-6/卷积2.gif" alt="卷积2"></li></ul></li></ul></li><li>图形学中Convolution：理解为加权平均<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 17.56.08.png" alt="截屏2023-04-01 17.56.08" style="zoom: 25%;"></li><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 17.56.42.png" alt="截屏2023-04-01 17.56.42" style="zoom:25%;"></li></ul></li></ul><ul><li><strong>卷积定理</strong>：两个信号时域上的卷积，是这两个信号频域上的乘积；反之，时域上的乘积，也等于频域上的卷积<ul><li>理解：时域和频域差一个傅里叶的叠加</li></ul></li><li><p>对图像进行滤波（有两种方法</p><ul><li>Option1: 在空域使用卷积进行滤波</li><li><p>Option2</p><ul><li>利用傅里叶变换将空域图片转到频域空间</li><li>图像在频域下，与<a href="https://blog.csdn.net/i_silence/article/details/116483732">卷积核</a>相乘</li><li>通过逆傅里叶变换重新变回空域</li></ul></li><li><p><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 18.10.54.png" alt="截屏2023-04-01 18.10.54" style="zoom:33%;"></p><ul><li>这个例子：一个像素* <script type="math/tex">\begin{bmatrix} \frac 1 9 & \frac 1 9 & \frac 1 9 \\ \frac 1 9 & \frac 1 9 & \frac 1 9 \\ \frac 1 9 & \frac 1 9 & \frac 1 9 \end{bmatrix} \tag{1}</script> = 一个像素和周围一圈像素求平均</li></ul></li></ul></li><li><p>卷积核Box Filter</p><ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 20.38.22.png" alt="截屏2023-04-01 20.38.22" style="zoom:25%;"></li></ul></li><li><p>Box Function = 低通滤波</p><ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 20.46.24.png" alt="截屏2023-04-01 20.46.24"></li></ul></li><li><p>Wider Filter Kernel = 更低的频率</p><ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 20.46.38.png" alt="截屏2023-04-01 20.46.38"><ul><li>理解：利用更大的卷积核进行卷积操作，得到的卷积频率会更低</li></ul></li></ul></li></ul><h3 id="Sampling采样-Repeating-Frequency-Contents"><a href="#Sampling采样-Repeating-Frequency-Contents" class="headerlink" title="Sampling采样 = Repeating Frequency Contents"></a>Sampling采样 = Repeating Frequency Contents</h3><p><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 20.56.53.png" alt="截屏2023-04-01 20.56.53" style="zoom:50%;"></p><ul><li>上图<ul><li>(e)是(a)和(c)在时域上的乘积</li><li>(f)是(b)和(d)在频域上的卷积</li><li>通过观察(b)和(f)，发现采样的过程是重复原始函数的频谱</li></ul></li><li>走样 = 频谱上的混叠<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 21.17.32.png" alt="截屏2023-04-01 21.17.32" style="zoom:33%;"><ul><li>冲激函数周期变大等于冲击函数频域周期变小，则相乘后函数频域也变小，因此“粘贴的函数图像”变密</li></ul></li></ul></li></ul><h2 id="反走样-Antialiasing"><a href="#反走样-Antialiasing" class="headerlink" title="反走样 Antialiasing"></a>反走样 Antialiasing</h2><h3 id="反走样原理"><a href="#反走样原理" class="headerlink" title="反走样原理"></a>反走样原理</h3><ul><li>Reduce Aliasing Error<ul><li><strong>Option1: 增加采样率</strong><ul><li>增大冲激信号在频域的间隔</li><li>更高分辨率的显示器<ul><li>缺点：成本高&amp;需要很高的很高的分辨率</li></ul></li></ul></li><li><strong>Option2: 进行反走样操作</strong><ul><li>采样前，让信号在频域变窄 = 滤高频 = 图像模糊处理</li></ul></li></ul></li><li>Antialiasing = Limiting, then repeating<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 21.33.11.png" alt="截屏2023-04-01 21.33.11"><ul><li>滤波后，避免上上图中的频域混叠</li></ul></li></ul></li><li>应用于图像处理中<ul><li>一般采样<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 21.36.02.png" alt="截屏2023-04-01 21.36.02" style="zoom:33%;"></li></ul></li><li>反走样——先对三角形模糊<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 21.36.30.png" alt="截屏2023-04-01 21.36.30" style="zoom:33%;"></li></ul></li></ul></li><li>上述的滤波操作？（如何将三角形变模糊）<ul><li>用一定大小的低通滤波器进行卷积</li><li>实际解决方法：对每个像素，把三角形求平均值，再采样<img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 21.40.10.png" alt="截屏2023-04-01 21.40.10" style="zoom: 33%;"><ul><li>卷积：$f(x, y)$ by a 1-pixel box-blur<ul><li>Recall: convolving = filtering = averaging</li></ul></li><li>Then 采样，at every pixel’s center</li></ul></li></ul></li><li>Antialiasing by Computing Average Pixel Value 通过计算像素平均值进行反走样<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-02 09.59.19.png" alt="截屏2023-04-02 09.59.19" style="zoom:33%;"></li></ul></li></ul><h3 id="MSAA-Antialiasing-By-Supersampling"><a href="#MSAA-Antialiasing-By-Supersampling" class="headerlink" title="MSAA: Antialiasing By Supersampling"></a>MSAA: Antialiasing By Supersampling</h3><ul><li><p>原理：超采样Supersampling</p><ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-02 10.04.46.png" alt="截屏2023-04-02 10.04.46" style="zoom:33%;"><ul><li><strong>注意</strong>：MSAA实际上是对Blur的一种近似，是对信号的模糊，并没有提高分辨率（屏幕分辨率没改变）</li></ul></li></ul></li><li>过程举例<ul><li>增加采样点，挨个判断是否在三角形内；四个采样点，覆盖率有$0\%, 25\%, 50\%,75\%,100\%$<ul><li><img src="/2023/03/27/Games101-P5-6/Supersampling.JPG" alt="Supersampling"></li></ul></li></ul></li><li><p>MSAA的<strong>性能代价</strong>：计算量增大</p></li><li><p><strong>实际应用</strong>中以降低性能代价，像素不会被规则的划分为NxN，而是会用更加有效的划分方法，一些点还会被临近像素复用。</p></li></ul><h3 id="FXAA-Fast-Approximate-AA"><a href="#FXAA-Fast-Approximate-AA" class="headerlink" title="FXAA: Fast Approximate AA"></a>FXAA: Fast Approximate AA</h3><ul><li>与增加样本数无关，属于图像的后期处理。速度快</li><li>过程：得到有锯齿的图后，通过图像匹配的方法找到边界部分，将边界换成没有锯齿的边界</li></ul><h3 id="TAA-Temporal-AA"><a href="#TAA-Temporal-AA" class="headerlink" title="TAA: Temporal AA"></a>TAA: Temporal AA</h3><ul><li>理解：将MSAA对应样本，从空间分布改变为时间分布</li></ul><h3 id="补：Super-Resolution超分辨率-Super-Sampling"><a href="#补：Super-Resolution超分辨率-Super-Sampling" class="headerlink" title="补：Super Resolution超分辨率 / Super Sampling"></a>补：Super Resolution超分辨率 / Super Sampling</h3><ul><li><p>将小图放大，并避免锯齿的产生（举例：<a href="https://github.com/nagadomi/waifu2x">waifu2x</a>）</p></li><li><p>DLSS: Deep Learning Super Sampling</p><ul><li>通过深度学习，对放大后缺失的细节进行猜测</li></ul></li></ul><h2 id="Visible可见性-Occlusion遮挡"><a href="#Visible可见性-Occlusion遮挡" class="headerlink" title="Visible可见性 /  Occlusion遮挡"></a>Visible可见性 /  Occlusion遮挡</h2><h3 id="画家算法"><a href="#画家算法" class="headerlink" title="画家算法"></a>画家算法</h3><ul><li>对三角面排序，从远到近画，overwrite in the framebuffer</li><li>会出现错误遮挡<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-02 13.39.23.png" alt="截屏2023-04-02 13.39.23" style="zoom:25%;"></li></ul></li></ul><h3 id="Z-Buffer-深度缓存"><a href="#Z-Buffer-深度缓存" class="headerlink" title="Z-Buffer 深度缓存"></a>Z-Buffer 深度缓存</h3><ul><li>对<strong>像素内</strong>深度进行排序</li><li>Ideas：<ul><li>存储当先像素最小的深度</li><li>在生成最终图像的同时，<strong>同步生成</strong>另一张深度图（深度缓存）<img src="/2023/03/27/Games101-P5-6/截屏2023-04-02 13.54.51.png" alt="截屏2023-04-02 13.54.51"><ul><li>frame buffer stores color values</li><li>depth buffer (z-buffer) stores depth</li></ul></li></ul></li><li>注意：<ul><li>视口变换中，相机放在原点，看向$-Z$方向</li><li>这里为了方便计算，Z-Buffer中规定$Z$均为正值。则$Z$越小表示越近，$Z$越大表示越远</li></ul></li><li>深度缓存实现步骤<ul><li>初始化每个像素的深度缓存值都为$\infty$</li><li>对每个像素进行Rasterization：遍历每一个三角形中的每一个像素，若该三角形中该像素[x,y]的深度值z于zbuffer[x,y]中的值，则更新zbuffer[x,y]的值为z，并且更新该像素[x,y]的颜色<img src="/2023/03/27/Games101-P5-6/截屏2023-04-02 14.05.47.png" alt="截屏2023-04-02 14.05.47"></li></ul></li><li>举例<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-02 14.07.41.png" alt="截屏2023-04-02 14.07.41" style="zoom:33%;"></li></ul></li><li>Z-Buffer复杂度<ul><li><strong>看完数据结构回来<a href="https://www.bilibili.com/video/BV1X7411F744?t=1423.9&amp;p=7">填坑</a></strong></li><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-02 14.14.54.png" alt="截屏2023-04-02 14.14.54" style="zoom:25%;"></li></ul></li><li>假设没有像素在同一深度（实际情况中，浮点数几乎不可能相等），深度缓存画三角形的顺序将不影响结果</li><li>若结合MSAA，则需针对每一个采样点进行相应的Z-Buffer深度操作</li><li>Z-Buffer处理不了透明物体！</li></ul><h1 id="Shadows"><a href="#Shadows" class="headerlink" title="Shadows"></a>Shadows</h1><h2 id="Shadow-mapping"><a href="#Shadow-mapping" class="headerlink" title="Shadow mapping"></a>Shadow mapping</h2><p> （shadow mapping只能处理<strong>点光源</strong>的<strong>硬阴影</strong>）</p><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><ul><li>一种图片空间的算法<ul><li>计算阴影时，无需知道场景几何信息</li><li>需解决走样问题</li></ul></li><li><strong>Key idea：若点不在阴影里，则摄影机和光源都可看到该点</strong>（若在阴影中，摄影机可看到但光源看不到）</li></ul><h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h3><p><img src="/2023/03/27/Games101-P5-6/截屏2023-04-20 23.29.38.png" alt="截屏2023-04-20 23.29.38" style="zoom:40%;"></p><ul><li><p>Render from light：从光源看向场景，记录深度图</p></li><li><p>Render from eye：从眼睛（摄像机）处看向光源，记录深度和颜色信息图</p></li><li>Project to light：将眼睛所看见的点映射回光源所看到的深度图中对应的像素，计算该点在光源处看的深度，比较所得深度和第一步该点处深度。一致，则光源可以看到，该点不在阴影中；不一致，则光源看不到，该点在阴影中。</li><li>举例<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-20 23.39.20.png" alt="截屏2023-04-20 23.39.20" style="zoom:50%;"></li><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-20 23.39.44.png" alt="截屏2023-04-20 23.39.44" style="zoom:50%;"></li><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-20 23.40.10.png" alt="截屏2023-04-20 23.40.10" style="zoom:50%;"></li><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-20 23.40.33.png" alt="截屏2023-04-20 23.40.33" style="zoom:50%;"><ul><li>问题：边缘不清晰——浮点数很难判断相等，边界处深度判断易出错；shadow map分辨率会引起相应采样问题</li></ul></li></ul></li></ul><h3 id="Problems-with-shadow-maps"><a href="#Problems-with-shadow-maps" class="headerlink" title="Problems with shadow maps"></a>Problems with shadow maps</h3><ul><li>Hard shadows (point lights only)<ul><li>补：软阴影<ul><li>光源有大小才可能出现软阴影</li><li>出现在Penumbra半影区。本质是本影、半影、影子外的过渡</li><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-20 23.52.49.png" alt="截屏2023-04-20 23.52.49" style="zoom:33%;"></li></ul></li></ul></li><li>阴影质量取决于shadow map分辨率（采样率低有锯齿，采样率高耗性能）(general problem with image-based techniques……)</li><li>涉及浮点深度值的相等比较，是指尺度、偏差、公差等问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
            <tag> 光栅化 </tag>
            
            <tag> 反走样 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P3-4 Transformation</title>
      <link href="/2023/03/21/Games101-P3-4/"/>
      <url>/2023/03/21/Games101-P3-4/</url>
      
        <content type="html"><![CDATA[<ul><li>P3 Overview<ul><li>Why study transformation </li><li>2D变换：rotation, scale, shear</li><li>其次坐标：增加一维表示平移变换</li><li>复合变换</li></ul></li><li>P4 Overview<ul><li>3D变换</li><li>Viewing(观测) Transformation<ul><li>View(视图)/Camera Transformation</li><li>Projection(投影) Transformation<ul><li>Orthographic(正交)</li><li>Perspective(透视)</li></ul></li></ul></li></ul></li></ul><span id="more"></span><h1 id="P3-4-Transformation"><a href="#P3-4-Transformation" class="headerlink" title="P3-4 Transformation"></a>P3-4 Transformation</h1><h2 id="P3"><a href="#P3" class="headerlink" title="P3"></a>P3</h2><h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><ul><li>Modeling模型变换</li><li>Viewing视图变换：（3D to 2D）projection</li></ul><h3 id="2D-Transformation"><a href="#2D-Transformation" class="headerlink" title="2D Transformation"></a>2D Transformation</h3><ul><li>Scale<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-21 20.16.25.png" alt="截屏2023-03-21 20.16.25" style="zoom:25%;"></li></ul></li><li>Reflection<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-21 20.18.45.png" alt="截屏2023-03-21 20.18.45" style="zoom:25%;"></li></ul></li><li>Shear(切变)<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-21 20.24.18.png" alt="截屏2023-03-21 20.24.18" style="zoom:25%;"></li></ul></li><li>Rotation（特殊化点，推导（旋转绕原点<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-21 20.27.31.png" alt="截屏2023-03-21 20.27.31" style="zoom:25%;"></li><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 10.12.13.png" alt="截屏2023-03-27 10.12.13" style="zoom:25%;"><ul><li>正交矩阵，转置 = 逆</li></ul></li></ul></li><li>线性变换（写成矩阵形式<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-21 21.15.53.png" alt="截屏2023-03-21 21.15.53" style="zoom:25%;"></li></ul></li></ul><h4 id="其次坐标"><a href="#其次坐标" class="headerlink" title="其次坐标"></a>其次坐标</h4><ul><li><p>平移变换——非线性变换，上述矩阵无法满足</p><ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-26 21.13.00.png" alt="截屏2023-03-26 21.13.00" style="zoom:25%;"></li></ul></li><li><p>引入其次坐标</p><ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-26 21.18.19.png" alt="截屏2023-03-26 21.18.19" style="zoom:25%;"></li><li>1和0用于区分是点还是向量<ul><li>向量是0: 因为向量具有平移不变性</li></ul></li><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-26 21.27.22.png" alt="截屏2023-03-26 21.27.22" style="zoom:25%;"><ul><li>point + point得到两点间中点</li></ul></li></ul></li><li>Affine Transform 仿射变换<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-26 21.29.32.png" alt="截屏2023-03-26 21.29.32" style="zoom:25%;"></li><li>$\begin{pmatrix}线 &amp; 性 &amp; 平\\ 变 &amp; 换 &amp; 移\\ 0&amp;0&amp;1 \\ \end{pmatrix}$</li></ul></li><li>逆变换</li><li>复合变换：分步左乘变换矩阵，不满足交换律<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-26 21.42.15.png" alt="截屏2023-03-26 21.42.15" style="zoom:25%;"></li><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-26 21.43.20.png" alt="截屏2023-03-26 21.43.20" style="zoom: 33%;"><ul><li>先应用线性变换，再平移</li></ul></li></ul></li></ul><h3 id="3D-Transformation"><a href="#3D-Transformation" class="headerlink" title="3D Transformation"></a>3D Transformation</h3><ul><li>引入其次坐标<ul><li>$3D\quad point = (x, y, z, 1)^T$</li><li>$3D \quad vector = (x, y, z, 0)^T$</li></ul></li><li>仿射变换<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 10.03.04.png" alt="截屏2023-03-27 10.03.04" style="zoom: 25%;"></li></ul></li></ul><h2 id="P4"><a href="#P4" class="headerlink" title="P4"></a>P4</h2><h3 id="3D-Transformation-1"><a href="#3D-Transformation-1" class="headerlink" title="3D Transformation"></a>3D Transformation</h3><ul><li>三维空间旋转<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 10.27.29.png" alt="截屏2023-03-27 10.27.29" style="zoom:25%;"><ul><li>Y轴旋转相反：X ✖️ Z = -Y</li></ul></li><li>$R_{xyz}(\alpha, \beta ,\gamma) = R_x(\alpha)R_y(\beta)R_z(\gamma)$ 三维空间变换分解<ul><li>$\alpha$, $\beta$ ,$\gamma$ 为欧拉角</li><li>Yaw, Pitch, Roll描述三维空间变换<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 10.37.26.png" alt="截屏2023-03-27 10.37.26" style="zoom:25%;"></li></ul></li></ul></li><li>罗德里格斯旋转公式：绕n轴旋转$\alpha$<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 10.40.09.png" alt="截屏2023-03-27 10.40.09" style="zoom:25%;"></li></ul></li></ul></li></ul><h3 id="Viewing-Transformation-视图变换"><a href="#Viewing-Transformation-视图变换" class="headerlink" title="Viewing Transformation 视图变换"></a>Viewing Transformation 视图变换</h3><p><mark>得到$[-1, 1]^3$的立方体</mark></p><h4 id="View-Camera-Transformation"><a href="#View-Camera-Transformation" class="headerlink" title="View/Camera Transformation"></a>View/Camera Transformation</h4><ul><li><strong>MVP变换</strong><ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 10.52.32.png" alt="截屏2023-03-27 10.52.32" style="zoom: 33%;"></li></ul></li><li>How to perform view transformation? 得到<strong>$M_{view}$视图变换矩阵</strong><ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 10.56.48.png" alt="截屏2023-03-27 10.56.48" style="zoom: 33%;"><ul><li>Up Direction：用一个向量定义相机向上的方向</li></ul></li><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 10.57.15.png" alt="截屏2023-03-27 10.57.15" style="zoom:33%;"><ul><li>相机放在标准位置(0, 0, 0)，向-Z看，上方向为Y</li></ul></li><li>实现上一步的步骤<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 11.03.25.png" alt="截屏2023-03-27 11.03.25" style="zoom:33%;"></li><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 11.05.16.png" alt="截屏2023-03-27 11.05.16" style="zoom:33%;"><ul><li>R~view~^-1^：将xy -z旋转到etg（代入<strong>X</strong>(1,0,0,0)^T^, <strong>Y</strong>(0,1,0,0)^T^, <strong>Z</strong>(0,0,1,0)^T^可以验证XYZ向量的旋转得到etg）<img src="/2023/03/21/Games101-P3-4/IMG_0776.jpg" alt="IMG_0776" style="zoom:25%;"></li><li>正交矩阵，逆 = 转置</li></ul></li></ul></li><li>总结<ul><li>$M_{view}$视图变换操作相机，其他物体跟着相机发生变换</li><li>得到的结果：相机在原点，朝向-Z，上方向为Y</li></ul></li><li>ModelView Transformation模型视图变换：移动相机模型跟着变换，Model和View可相提并论</li></ul></li></ul><h4 id="Projection-Transformation"><a href="#Projection-Transformation" class="headerlink" title="Projection Transformation"></a>Projection Transformation</h4><ul><li>Ortho vs. Persp<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.02.28.png" alt="截屏2023-03-27 14.02.28" style="zoom: 50%;"></li></ul></li></ul><h5 id="Orthographic-Projection正交投影"><a href="#Orthographic-Projection正交投影" class="headerlink" title="Orthographic Projection正交投影"></a>Orthographic Projection正交投影</h5><ul><li>简单做法<ul><li>仍掉Z <img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.05.51.png" alt="截屏2023-03-27 14.05.51" style="zoom:33%;"></li></ul></li><li>正式做法<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.14.53.png" alt="截屏2023-03-27 14.14.53" style="zoom:33%;"><ul><li>定义立方体（三个轴的范围）</li><li>将立方体中心移到原点</li><li>映射到$cube[-1, 1]^3$</li></ul></li></ul></li><li>$M_{ortho}$正交变换矩阵<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.18.21.png" alt="截屏2023-03-27 14.18.21" style="zoom:33%;"><ul><li>先平移，再缩放</li></ul></li></ul></li><li>注意⚠️<ul><li>这里使用右手系。看向-Z方向，所以n平面(近处)的Z数值比f平面(远处)大</li></ul></li></ul><h5 id="Perspective-Projection-透视投影"><a href="#Perspective-Projection-透视投影" class="headerlink" title="Perspective Projection 透视投影"></a>Perspective Projection 透视投影</h5><ul><li>知识回顾<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.32.51.png" alt="截屏2023-03-27 14.32.51" style="zoom:33%;"></li></ul></li><li>步骤<ul><li>概述：<img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.33.45.png" alt="截屏2023-03-27 14.33.45" style="zoom:33%;"><ul><li>将视锥远平面压缩到长方体中（$M_{persp-&gt;ortho}$）<ul><li>近平面永远不变</li><li>远平面中心点不变，Z不变</li></ul></li><li>长方体做正交投影（$M_{ortho}$）</li></ul></li><li>STEP1：将persp视锥远平面压缩到ortho长方体中，xy可通过相似三角形计算，z未知<ul><li>关于Y如何被挤压<img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.41.45.png" alt="截屏2023-03-27 14.41.45" style="zoom:33%;"></li><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.44.02.png" alt="截屏2023-03-27 14.44.02" style="zoom:33%;"></li><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.50.43.png" alt="截屏2023-03-27 14.50.43" style="zoom:33%;"><ul><li>利用近平面的点(x, y, n, 1)，特殊化求解第三行<ul><li>下图右上角：$(x,y,n,1)^T$经$M_{persp-&gt;ortho}$变换后，还是会得到自己本身。因此乘n，得到与左上角格式类似的矩阵（此时的z=n），可看到unknown的值在近平面为$n^2$</li><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.56.24.png" alt="截屏2023-03-27 14.56.24" style="zoom:33%;"><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.57.10.png" alt="截屏2023-03-27 14.57.10" style="zoom:33%;"></li></ul></li><li>利用远平面中点(0, 0, f, 1)不变<img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.58.40.png" alt="截屏2023-03-27 14.58.40" style="zoom:33%;"></li><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 15.14.45.png" alt="截屏2023-03-27 15.14.45" style="zoom: 33%;"></li><li>$M_{persp-&gt;ortho} = \begin{pmatrix}n &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; n &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; n+f &amp;-nf \\ 0 &amp; 0 &amp; 1&amp; 0 \\ \end{pmatrix}$</li></ul></li></ul></li><li>STEP2：对压缩后长方体进行$M_{ortho}$<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 15.15.03.png" alt="截屏2023-03-27 15.15.03" style="zoom:33%;"></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
            <tag> MVP变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P2 Review Of Linear Algebra</title>
      <link href="/2023/03/20/Games101-P2/"/>
      <url>/2023/03/20/Games101-P2/</url>
      
        <content type="html"><![CDATA[<ul><li>Overview<ul><li>向量点乘、叉乘</li><li>矩阵</li></ul></li></ul><span id="more"></span><h1 id="P2-Review-Of-Linear-Algebra-向量与线性代数"><a href="#P2-Review-Of-Linear-Algebra-向量与线性代数" class="headerlink" title="P2 - Review Of Linear Algebra 向量与线性代数"></a>P2 - Review Of Linear Algebra 向量与线性代数</h1><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><h3 id="向量点乘"><a href="#向量点乘" class="headerlink" title="向量点乘"></a>向量点乘</h3><ul><li>快速得到两个向量的夹角：如，光照运算中，法线、光线夹角 / 投影<ul><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 18.45.34.png" alt="截屏2023-03-21 18.45.34" style="zoom:25%;"></li></ul></li><li>测量两个向量距离远近<ul><li>单位向量点乘范围[-1, 1]，1近，-1远</li><li>可用于镜面反射，金属高光：反射处附近看，高光明显</li></ul></li><li>判断向量方向，向前/向后<ul><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 19.07.09.png" alt="截屏2023-03-21 19.07.09" style="zoom:25%;"></li></ul></li><li>计算<ul><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 19.01.02.png" alt="截屏2023-03-21 19.01.02" style="zoom:25%;"></li></ul></li></ul><h3 id="向量叉乘"><a href="#向量叉乘" class="headerlink" title="向量叉乘"></a>向量叉乘</h3><ul><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 19.12.25.png" alt="截屏2023-03-21 19.12.25" style="zoom:33%;"></li><li>$\vec{x} \times \vec{y} = + \vec{z}$</li><li>==判断左右==（叉乘向内/外）==/内外==（三角形三边叉乘同向则在内部，光栅化基础）⭐️<ul><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 19.24.34.png" alt="截屏2023-03-21 19.24.34" style="zoom:25%;"></li></ul></li></ul><h3 id="直角坐标系便于向量分解"><a href="#直角坐标系便于向量分解" class="headerlink" title="直角坐标系便于向量分解"></a>直角坐标系便于向量分解</h3><ul><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 19.33.42.png" alt="截屏2023-03-21 19.33.42" style="zoom:25%;"></li></ul><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><ul><li>运算法则<ul><li>(AB)C = A(BC)</li><li>A(B+C) = AB + AC</li><li>(A+B)C = AC + AB</li></ul></li><li>矩阵转置<ul><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 19.43.16.png" alt="截屏2023-03-21 19.43.16" style="zoom:25%;"></li><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 19.45.50.png" alt="截屏2023-03-21 19.45.50" style="zoom:25%;"></li></ul></li><li>单位矩阵<ul><li>是对角阵</li><li>定义矩阵的逆<ul><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 19.47.38.png" alt="截屏2023-03-21 19.47.38" style="zoom:25%;"></li></ul></li></ul></li><li>向量点乘/叉乘写成矩阵形式<ul><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 19.49.52.png" alt="截屏2023-03-21 19.49.52" style="zoom:25%;"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P1 Overview Of Computer Graphic</title>
      <link href="/2023/03/20/Games101-P1/"/>
      <url>/2023/03/20/Games101-P1/</url>
      
        <content type="html"><![CDATA[<ul><li>Overview<ul><li>应用</li><li>course topics</li></ul></li></ul><span id="more"></span><h1 id="P1-Overview-Of-Computer-Graphic"><a href="#P1-Overview-Of-Computer-Graphic" class="headerlink" title="P1 - Overview Of Computer Graphic"></a>P1 - Overview Of Computer Graphic</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>游戏<ul><li>判断画面质量：亮度（全局光照）</li></ul></li><li>电影<ul><li>特效：常见=难做</li></ul></li><li>动画：如毛发，以及和光线作用<ul><li>几何形体的表述</li><li>渲染</li><li>光线计算</li></ul></li><li>设计：如CAD<ul><li>几何</li><li>光照</li><li>物理模拟，如车辆碰撞测试</li></ul></li><li>可视化：将三维空间信息编程视觉信息<ul><li><img src="/2023/03/20/Games101-P1/截屏2023-03-20 14.22.25.png" alt="截屏2023-03-20 14.22.25" style="zoom:50%;"></li></ul></li><li>虚拟现实</li><li>数字图像绘制/处理</li><li>物理模拟</li><li>GUI：图形用户接口（UI设计</li><li>字体设计<ul><li><img src="/2023/03/20/Games101-P1/截屏2023-03-20 20.30.50.png" alt="截屏2023-03-20 20.30.50" style="zoom:25%;"></li></ul></li></ul><h2 id="Course-Topics"><a href="#Course-Topics" class="headerlink" title="Course Topics"></a>Course Topics</h2><ul><li>光栅化（rasterization）<ul><li>三维空间几何形体显示在屏幕上</li><li>广泛用于实时渲染（实时：&gt;30fps）</li></ul></li><li>曲线和曲面</li><li>光线追踪（ray tracing）<ul><li>动画/电影使用</li><li>实时光线追踪</li></ul></li><li>动画与模拟</li></ul>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
