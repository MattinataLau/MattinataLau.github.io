<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Games101-P7-9</title>
      <link href="/2023/04/02/Games101-P7-9/"/>
      <url>/2023/04/02/Games101-P7-9/</url>
      
        <content type="html"><![CDATA[<ul><li>P7 Overview<ul><li>Blinn - Phong Diffuse Reflection Model<ul><li>Diffuse</li></ul></li></ul></li><li>P8 Overview<ul><li>Blinn - Phong Diffuse Reflection Model<ul><li>Specular</li><li>Ambient</li></ul></li><li>Shading Frequencies</li><li>Graphics Pipeline</li></ul></li><li>P9 Overview<ul><li>Barycentric coordinate 重心插值</li><li>Texture queries </li><li>Application of texture </li></ul></li></ul><span id="more"></span><h1 id="P7-9-Shading"><a href="#P7-9-Shading" class="headerlink" title="P7-9 Shading"></a>P7-9 Shading</h1><h2 id="P7-Shading-Illumination-Shading-and-Graphics-Pipeline"><a href="#P7-Shading-Illumination-Shading-and-Graphics-Pipeline" class="headerlink" title="P7 Shading (Illumination, Shading and Graphics Pipeline)"></a>P7 Shading (Illumination, Shading and Graphics Pipeline)</h2><ul><li>回顾：Model - View - Projection - Viewport - Rasterization<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-02 14.31.29.png" alt="截屏2023-04-02 14.31.29" style="zoom:33%;"></li></ul></li></ul><h3 id="Shading-Definition"><a href="#Shading-Definition" class="headerlink" title="Shading Definition"></a>Shading Definition</h3><ul><li>字典中：The darkening or coloring of an illustration or diagram with parallel lines or a block of color.</li><li>本课中：The process of <strong>applying a material</strong> to an object. // 不同材质和光线相互作用的方法不同</li></ul><h3 id="简单的着色例子：Blinn-Phong-Reflection-Model"><a href="#简单的着色例子：Blinn-Phong-Reflection-Model" class="headerlink" title="简单的着色例子：Blinn - Phong Reflection Model"></a>简单的着色例子：Blinn - Phong Reflection Model</h3><ul><li>Blinn - Phong Reflection Model是经验型模型，并不完全符合物理</li></ul><h4 id="Shading-in-Local"><a href="#Shading-in-Local" class="headerlink" title="Shading in Local"></a>Shading in Local</h4><ul><li>光——得出反射模型<img src="/2023/04/02/Games101-P7-9/截屏2023-04-06 20.33.25.png" alt="截屏2023-04-06 20.33.25" style="zoom:25%;"><ul><li>Specular Highlight 高光</li><li>Diffuse Reflection 漫反射光</li><li>Ambient Light 环境光：不是直接接收到的光照，是通过物体反射接收到的光照</li></ul></li><li>Shading Point：相机所观察到的点<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-08 17.08.35.png" alt="截屏2023-04-08 17.08.35" style="zoom: 50%;"></li><li>input：（一下所有向量只表示方向，均为单位向量，由两点向量归一化得到）<ul><li>Viewer direction, v：观测方向，shading point向相机连线的方向</li><li>Surface normal, n：法线方向</li><li>Light direction, l：光照方向，shading point向光源连线的方向</li><li>Surface Parameter(color, shininess, …)：表面属性</li></ul></li></ul></li><li>注意⚠️：Shading in Local只关注该点自身着色，产生明暗变化，不产生阴影，与shadow无关<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-06 20.41.25.png" alt="截屏2023-04-06 20.41.25" style="zoom:33%;"></li></ul></li></ul><h4 id="Diffuse-Reflection-漫反射"><a href="#Diffuse-Reflection-漫反射" class="headerlink" title="Diffuse Reflection 漫反射"></a>Diffuse Reflection 漫反射</h4><ul><li>漫反射<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-06 20.43.27.png" alt="截屏2023-04-06 20.43.27" style="zoom:25%;"></li></ul></li><li>为什么光以不同的角度照射到物体表面，得到的明暗不同<ul><li><strong>Lambert’s cosine law（Lambert余弦定理）：物体表面单位面积接收到的光照和$cos\theta(=n \cdot l)$成正比</strong>，直射接收到所有能量</li><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-06 20.47.32.png" alt="截屏2023-04-06 20.47.32"></li></ul></li><li>Light Falloff<ul><li>能量守恒，远近球壳能量相等；平方反比</li><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-06 20.59.29.png" alt="截屏2023-04-06 20.59.29" style="zoom: 25%;"><ul><li>推广：<strong>已知光源能量 &amp; shading point与光源间距离，可知有多少光可传播到shading point；结合Lambert’s cosine law，可得出diffuse reflection的表示方法</strong></li></ul></li></ul></li><li>Lambertian (Diffuse) Shading —— 漫反射最终着色<ul><li>光源光强$I$，距离$r$，计算基于世界坐标</li><li>$max(0, n \cdot l)$：避免$cos\theta&lt;0$光照反向，无意义</li><li>$k_d$漫反射系数，表示吸收和反射的能量，1白0黑，表示明暗；若$k_d$是vector3，则RGB三通道可表示颜色<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-06 21.05.53.png" alt="截屏2023-04-06 21.05.53" style="zoom: 33%;"></li><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-06 21.20.04.png" alt="截屏2023-04-06 21.20.04" style="zoom:33%;"></li></ul></li></ul></li><li>漫反射理论上各个方向反射均匀，各个方向所观测到的着色应一致</li></ul><h2 id="P8-Shading-Pipeline-and-Texture-Mapping"><a href="#P8-Shading-Pipeline-and-Texture-Mapping" class="headerlink" title="P8 Shading (Pipeline and Texture Mapping)"></a>P8 Shading (Pipeline and Texture Mapping)</h2><h3 id="Blinn-Phong-Model"><a href="#Blinn-Phong-Model" class="headerlink" title="Blinn - Phong Model"></a>Blinn - Phong Model</h3><h4 id="Specular-Term-高光"><a href="#Specular-Term-高光" class="headerlink" title="Specular Term 高光"></a>Specular Term 高光</h4><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 09.36.00.png" alt="截屏2023-04-07 09.36.00" style="zoom:33%;"><ul><li>$v$$和r$足够接近时，可得到高光项</li></ul></li><li>Blinn - Phong 模型中的trick<ul><li>​    <img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 09.43.05.png" alt="截屏2023-04-07 09.43.05" style="zoom:33%;"></li><li>备注：<ul><li><strong>$v$$和r$很接近$\iff$法线方向和半程向量($l$和$v$角平分线方向)很接近</strong>；$n\cdot h$越接近1，则观察到的镜面反射越强烈</li><li>镜面反射系数$k_s$通常认为是白色的</li><li>利用半程向量的Blinn - Phong模型是对计算反射方向$r$的简化计算。若直接$r\cdot v$，则是Phong模型。</li><li>$max(0, n \cdot h)^p$指数$p$的作用：限制高光范围<ul><li>下图最左，不做指数运算，则会看到很大的高光；$p$通常为100~200</li><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 09.52.26.png" alt="截屏2023-04-07 09.52.26" style="zoom:33%;"></li></ul></li></ul></li></ul></li><li>最终效果<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 09.55.47.png" alt="截屏2023-04-07 09.55.47" style="zoom:33%;"></li></ul></li></ul><h4 id="Ambient-Term-环境光"><a href="#Ambient-Term-环境光" class="headerlink" title="Ambient Term 环境光"></a>Ambient Term 环境光</h4><ul><li>假设所有点接收到的环境光相同，强度$I_a$，来自四面八方；假设是错的！<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 09.59.36.png" alt="截屏2023-04-07 09.59.36" style="zoom:33%;"></li></ul></li></ul><h4 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h4><ul><li>叠加所有光效<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 10.01.33.png" alt="截屏2023-04-07 10.01.33" style="zoom: 50%;"></li></ul></li></ul><h3 id="Shading-Frequencies-着色频率"><a href="#Shading-Frequencies-着色频率" class="headerlink" title="Shading Frequencies 着色频率"></a>Shading Frequencies 着色频率</h3><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 10.08.19.png" alt="截屏2023-04-07 10.08.19" style="zoom:33%;"><ul><li>利用法线插值</li></ul></li></ul><h4 id="Flat-Shading-shade-each-triangle"><a href="#Flat-Shading-shade-each-triangle" class="headerlink" title="Flat Shading: shade each triangle"></a>Flat Shading: shade each triangle</h4><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 10.13.38.png" alt="截屏2023-04-07 10.13.38" style="zoom: 50%;"><ul><li>每一个面都是平的，只有一个本身的法线</li><li>针对以一个三角面进行着色</li></ul></li></ul><h4 id="Gouraud-Shading-shade-each-vertex"><a href="#Gouraud-Shading-shade-each-vertex" class="headerlink" title="Gouraud Shading: shade each vertex"></a>Gouraud Shading: shade each vertex</h4><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 10.16.24.png" alt="截屏2023-04-07 10.16.24" style="zoom:50%;"><ul><li>求出顶点法线，针对每一个顶点进行着色</li><li>三个顶点所确定的三角形，根据三个顶点的颜色进行插值</li></ul></li></ul><h4 id="Phong-Shading-shade-each-pixel"><a href="#Phong-Shading-shade-each-pixel" class="headerlink" title="Phong Shading: shade each pixel"></a>Phong Shading: shade each pixel</h4><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 10.20.37.png" alt="截屏2023-04-07 10.20.37" style="zoom:50%;"><ul><li>得出三个顶点的法线后，插值三个顶点间每一个像素的法线方向，针对每个像素着色</li></ul></li></ul><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 10.30.47.png" alt="截屏2023-04-07 10.30.47" style="zoom:50%;"><ul><li>效果好坏是相对的</li><li>当面数极高，高于像素数，Flat shading消耗少于Phong shading，而效果差异不大</li></ul></li></ul><h4 id="定义顶点法线方向"><a href="#定义顶点法线方向" class="headerlink" title="定义顶点法线方向"></a>定义顶点法线方向</h4><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 10.37.34.png" alt="截屏2023-04-07 10.37.34" style="zoom: 50%;"><ul><li><mark>顶点法线</mark><strong>：相邻面的法线方向加权平均(根据面积)，再归一化</strong></li></ul></li></ul><h4 id="定义像素法线方向"><a href="#定义像素法线方向" class="headerlink" title="定义像素法线方向"></a>定义像素法线方向</h4><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-07 10.41.34.png" alt="截屏2023-04-07 10.41.34" style="zoom:50%;"><ul><li><mark>逐像素的法线</mark><strong>：根据顶点法线，利用重心坐标(Barycentric interpolation)插值，而后归一化</strong></li></ul></li></ul><h3 id="Graphics-Real-time-Rendering-Pipeline-实时渲染-渲染管线"><a href="#Graphics-Real-time-Rendering-Pipeline-实时渲染-渲染管线" class="headerlink" title="Graphics (Real-time Rendering) Pipeline 实时渲染 渲染管线"></a>Graphics (Real-time Rendering) Pipeline 实时渲染 渲染管线</h3><h4 id="渲染管线概述"><a href="#渲染管线概述" class="headerlink" title="渲染管线概述"></a>渲染管线概述</h4><ul><li>概览<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-08 17.53.04.png" alt="截屏2023-04-08 17.53.04" style="zoom:50%;"></li></ul></li><li>attention<ul><li>MVP变换发生在顶点阶段<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-08 18.05.29.png" alt="截屏2023-04-08 18.05.29" style="zoom:50%;"></li></ul></li><li>光栅化<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-08 18.06.17.png" alt="截屏2023-04-08 18.06.17" style="zoom:50%;"></li></ul></li><li>深度缓存<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-08 18.12.15.png" alt="截屏2023-04-08 18.12.15" style="zoom:50%;"></li></ul></li><li>Shading可发生在不同阶段，<strong>顶点的着色发生在顶点阶段，像素着色发生在Fragment阶段</strong><ul><li>eg：Gouraud shading发生在顶点阶段；Phong shading发生在Fragment阶段（需像素产生后进行</li><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-08 18.15.07.png" alt="截屏2023-04-08 18.15.07" style="zoom:50%;"></li></ul></li><li>Texture Mapping 纹理映射<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-08 18.19.29.png" alt="截屏2023-04-08 18.19.29" style="zoom:50%;"></li></ul></li></ul></li></ul><h4 id="Shader-Programs"><a href="#Shader-Programs" class="headerlink" title="Shader Programs"></a>Shader Programs</h4><ul><li><p>关于shader</p><ul><li>本质是可以通过API在硬件上执行的语言</li><li>分顶点shader和fragment shader，每个顶点/fragment执行一次。shader程序对任何顶点/像素通用，不用for循环</li></ul></li><li><p>一个像素着色器的例子</p><ul><li><p>关于像素着色器：通过程序写出，如何计算出像素最终的颜色，并输出</p></li><li><p><img src="/2023/04/02/Games101-P7-9/截屏2023-04-08 18.23.56.png" alt="截屏2023-04-08 18.23.56" style="zoom: 50%;"></p></li><li><pre><code class="lang-glsl">uniform sampler2D myTexture;    // program parameter；纹理全局变量uniform vec3 lightDir;    // program parameter；光照方向全局变量varying vec2 uv;    // per fragment value (interp. by rasterizer)；插值varying vec3 norm;    // per fragment value (interp. by rasterizer)；插值void diffuseShader()&#123;    vec3 kd;    // 漫反射系数    kd = texture2d(myTexture, uv);    // material color from texture     // Phong模型漫反射计算    kd *= clamp(dot(–lightDir, norm), 0.0, 1.0);    // Lambertian shading model；认为入射方向向内，因而lightDir为负    gl_FragColor = vec4(kd, 1.0);    // output fragment color&#125;</code></pre></li></ul></li><li><p>IQ大神的shader：Inigo Quilez, <a href="http://shadertoy.com/view/ld3Gz2">http://shadertoy.com/view/ld3Gz2</a></p><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-08 19.16.10.png" alt="截屏2023-04-08 19.16.10" style="zoom:50%;"></li><li>大神博客：<a href="https://iquilezles.org/">https://iquilezles.org/</a></li><li>大神油管：<a href="https://www.youtube.com/@InigoQuilez">https://www.youtube.com/@InigoQuilez</a></li></ul></li></ul><h3 id="Texture-Mapping-纹理映射"><a href="#Texture-Mapping-纹理映射" class="headerlink" title="Texture Mapping 纹理映射"></a>Texture Mapping 纹理映射</h3><ul><li><p><mark>注意</mark>⚠️：接下来的配图有点儿掉san🥵</p></li><li><p>思路：共用同一个模型，但漫反射系数发生了改变；需寻找一种方法，定义一个物体上任意一点的属性</p></li><li>Surfaces are 2D:  Every 3D surface point also has a place where it goes in the 2D image (texture).<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-10 11.21.37.png" alt="截屏2023-04-10 11.21.37" style="zoom:50%;"></li></ul></li><li>Texture Applied to Surface<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-10 11.24.22.png" alt="截屏2023-04-10 11.24.22" style="zoom:50%;"></li></ul></li><li>Visualization of Texture Coordinates<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-10 12.34.17.png" alt="截屏2023-04-10 12.34.17" style="zoom:50%;"></li><li>uv纹理范围在$(0,1)$</li></ul></li><li>Texture Applied to Surface<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-10 12.37.36.png" alt="截屏2023-04-10 12.37.36" style="zoom:50%;"></li></ul></li><li>纹理被重复利用<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-10 12.41.39.png" alt="截屏2023-04-10 12.41.39" style="zoom: 50%;"></li></ul></li><li>关于三角形内部点的uv值：通过顶点uv和重心坐标插值得出</li></ul><h2 id="P9-Shading-Texture-Mapping-cont"><a href="#P9-Shading-Texture-Mapping-cont" class="headerlink" title="P9 Shading (Texture Mapping cont.)"></a>P9 Shading (Texture Mapping cont.)</h2><h3 id="Interpolation-Across-Triangles-Barycentric-Coordinates-重心坐标"><a href="#Interpolation-Across-Triangles-Barycentric-Coordinates-重心坐标" class="headerlink" title="Interpolation Across Triangles: Barycentric Coordinates 重心坐标"></a>Interpolation Across Triangles: Barycentric Coordinates 重心坐标</h3><ul><li>三角形内部插值的作用：通过顶点的值，完成顶点间片元（像素）的平滑过度</li><li>插值的内容：texture coordinates, color, normal vectors…</li><li><strong>重心插值数学基础</strong><ul><li>重心坐标概念基础<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 09.42.53.png" alt="截屏2023-04-13 09.42.53" style="zoom: 33%;"></li><li>三角形<strong>内</strong>任意一点$(x,y)$都可以写成三个顶点的线性组合：$(x,y) = \alpha A+\beta B + \gamma C$；其中，$\alpha + \beta + \gamma = 1$，且$\alpha,\beta,\gamma &gt; 0$。重心坐标即为$(\alpha,\beta,\gamma)$</li><li>$\alpha + \beta + \gamma = 1$表明点在三角形所在平面内，$\alpha,\beta,\gamma &gt; 0$表明点在三角形内部</li></ul></li><li>重心坐标求法：利用面积<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 09.48.47.png" alt="截屏2023-04-13 09.48.47" style="zoom:33%;"></li></ul></li><li>三角形自身重心的性质：重心与三角形顶点连线所得的三角形面积相等。可得：<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 09.55.12.png" alt="截屏2023-04-13 09.55.12" style="zoom:33%;"></li></ul></li><li>导出公式<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 10.00.08.png" alt="截屏2023-04-13 10.00.08" style="zoom:33%;"></li></ul></li></ul></li><li>三角形内重心坐标的应用<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 10.02.36.png" alt="截屏2023-04-13 10.02.36" style="zoom:33%;"><ul><li><mark>注意</mark>⚠️：三角形投影后形状发生拉伸，重心坐标会改变。三维空间中三角形应在三维空间中插值，不能在二维投影屏面插值。</li></ul></li></ul></li></ul><h3 id="Applying-Textures-纹理应用"><a href="#Applying-Textures-纹理应用" class="headerlink" title="Applying Textures 纹理应用"></a>Applying Textures 纹理应用</h3><ul><li>纹理映射举例——Diffuse Color<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 10.13.15.png" alt="截屏2023-04-13 10.13.15" style="zoom:33%;"></li><li>通过对顶点插值，得出每一个片元(x, y)的uv坐标；</li><li>随后在纹理上查询该片元uv值，得出该片元的颜色texcolor；</li><li>将漫反射系数$k_d$设置为texcolor。</li></ul></li></ul><h3 id="Texture-Magnification-纹理分辨率小，需放大"><a href="#Texture-Magnification-纹理分辨率小，需放大" class="headerlink" title="Texture Magnification(纹理分辨率小，需放大)"></a>Texture Magnification(纹理分辨率小，需放大)</h3><ul><li>插值方法：Nearest, Bilinear, Bicubic<ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 10.25.17.png" alt="截屏2023-04-13 10.25.17" style="zoom:33%;"></li></ul></li></ul><h4 id="Nearest"><a href="#Nearest" class="headerlink" title="Nearest"></a>Nearest</h4><ul><li>屏幕pixel颜色应用最近的纹理texel的颜色，导致多个相邻pixel被映射成一个texel</li></ul><h4 id="Bilinear-Interpolation-双线性插值"><a href="#Bilinear-Interpolation-双线性插值" class="headerlink" title="Bilinear Interpolation 双线性插值"></a>Bilinear Interpolation 双线性插值</h4><ul><li><img src="/2023/04/02/Games101-P7-9/截屏2023-04-13 10.39.27.png" alt="截屏2023-04-13 10.39.27" style="zoom: 50%;"></li><li>寻找一个pixel(红色)附近的四个texel(黑色)，定义$t$和$s$范围都为$(0,1)$</li><li>由此插值后，$u_{00},u_{01},u_{10},u_{11}$四个texel所围成的区域内，pixel可实现平滑过度</li></ul><h4 id="Bicubic-Interpolation"><a href="#Bicubic-Interpolation" class="headerlink" title="Bicubic Interpolation"></a>Bicubic Interpolation</h4><ul><li>利用pixel附近的十六个texel，进行三次的插值</li></ul><h3 id="Texture-Magnification-纹理分辨率大，需缩小"><a href="#Texture-Magnification-纹理分辨率大，需缩小" class="headerlink" title="Texture Magnification(纹理分辨率大，需缩小)"></a>Texture Magnification(纹理分辨率大，需缩小)</h3>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
            <tag> 着色 </tag>
            
            <tag> 渲染管线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P5-6</title>
      <link href="/2023/03/27/Games101-P5-6/"/>
      <url>/2023/03/27/Games101-P5-6/</url>
      
        <content type="html"><![CDATA[<ul><li>P5 Overview<ul><li>Finishing up viewing<ul><li>Viewport transformation </li></ul></li><li>Rasterization<ul><li>Different raster displays</li><li>Rasterizing a triangle</li></ul></li></ul></li><li><p>P6 Overview</p><ul><li><p>Antialiasing</p><ul><li>采样简单理论</li><li>实际图形学中的反走样</li></ul></li><li><p>Visible /  Occlusion（讲解部分在P7开始处）</p><ul><li>Z - Buffer</li></ul></li></ul></li></ul><span id="more"></span><h1 id="P5-6-Rasterization"><a href="#P5-6-Rasterization" class="headerlink" title="P5-6 Rasterization"></a>P5-6 Rasterization</h1><h2 id="P5-Rasterization-Triangles"><a href="#P5-Rasterization-Triangles" class="headerlink" title="P5 Rasterization(Triangles)"></a>P5 Rasterization(Triangles)</h2><h3 id="Finishing-up-viewing"><a href="#Finishing-up-viewing" class="headerlink" title="Finishing up viewing"></a>Finishing up viewing</h3><h4 id="Viewport-transformation-视口变换"><a href="#Viewport-transformation-视口变换" class="headerlink" title="Viewport transformation 视口变换"></a>Viewport transformation 视口变换</h4><h5 id="Intro-摄影机"><a href="#Intro-摄影机" class="headerlink" title="Intro - 摄影机"></a>Intro - 摄影机</h5><ul><li>定义视锥的两个概念<ul><li>长宽比</li><li>FOV</li></ul></li><li>用近平面lrbt表示fov<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-03-27 21.09.36.png" alt="截屏2023-03-27 21.09.36" style="zoom:33%;"></li></ul></li><li>What’s after MVP?<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-03-27 21.22.19.png" alt="截屏2023-03-27 21.22.19" style="zoom: 33%;"></li></ul></li></ul><h5 id="Intro-屏幕"><a href="#Intro-屏幕" class="headerlink" title="Intro - 屏幕"></a>Intro - 屏幕</h5><ul><li>什么是屏幕<ul><li>抽象地认为是二维数组，其中每个元素都是一个像素</li><li>数组的大小就是屏幕分辨率</li><li>一种典型的光栅化显示</li></ul></li><li>Raster光栅<ul><li>Rasterize == drawing onto the screen</li></ul></li><li><p>Pixel像素</p><ul><li>课程中简单地认为是一个个小方块</li><li>实际是RGB的空间混合</li></ul></li><li><p>定义屏幕空间</p><ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-03-27 21.28.54.png" alt="截屏2023-03-27 21.28.54" style="zoom: 33%;"><ul><li>（x，y）形式，每个像素坐标均为整数。蓝色坐标为（2，1），因为从0开始</li><li>屏幕上，像素坐标范围是（0，0）到（width - 1，height - 1）</li><li>像素中心坐标是（x+0.5，y+0.5）</li><li>屏幕范围（0，0）到（width，height）</li></ul></li></ul></li></ul><h5 id="视口变换：将-1-1-3-立方体转化到整个屏幕"><a href="#视口变换：将-1-1-3-立方体转化到整个屏幕" class="headerlink" title="视口变换：将$[-1, 1]^3$立方体转化到整个屏幕"></a>视口变换：将$[-1, 1]^3$立方体转化到整个屏幕</h5><ul><li>Transform xy plane: $[-1, 1]^2$ to  $[0 ,width] * [0, height]$，先不管$z$<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-03-27 21.42.23.png" alt="截屏2023-03-27 21.42.23" style="zoom:33%;"></li><li>视口转化矩阵<ul><li>$M_{viewport} = \begin{pmatrix} \frac{width}2 &amp; 0 &amp; 0 &amp; \frac{width}2\\  0&amp; \frac{height}2 &amp; 0 &amp; \frac{height}2 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0&amp; 1 \\ \end{pmatrix}$<ul><li>左上角矩阵缩放</li><li>缩放后原点是中心，需将左下角平移到原点</li></ul></li></ul></li></ul></li></ul><h3 id="光栅化-Rasterizing-Triangles-into-Pixels"><a href="#光栅化-Rasterizing-Triangles-into-Pixels" class="headerlink" title="光栅化 - Rasterizing Triangles into Pixels"></a>光栅化 - Rasterizing Triangles into Pixels</h3><h4 id="Frame-Buffer-Memory-of-a-Raster-Display"><a href="#Frame-Buffer-Memory-of-a-Raster-Display" class="headerlink" title="Frame Buffer: Memory of a Raster Display"></a>Frame Buffer: Memory of a Raster Display</h4><ul><li>内存空间的一块区域映射到屏幕上，成为显示的图像</li></ul><h4 id="Polygon-Mesh"><a href="#Polygon-Mesh" class="headerlink" title="Polygon Mesh"></a>Polygon Mesh</h4><ul><li>intro<ul><li>已完成：将三维空间顶点变换到屏幕空间中</li><li>下一步：将多边形拆成不同的像素（光栅化的过程</li></ul></li><li>Triangle Mesh<ul><li>基础性质<ul><li>最基础的多边形</li><li>任何其他多边形都可拆成三角形</li></ul></li><li>独特性质<ul><li>三角形三点必在同一平面</li><li>三角形内外定义清晰（可以通过叉积直接定义三角形内外</li><li>三角形内部的点，可根据已知三个点的信息进行渐变（lerp插值）</li></ul></li></ul></li><li><img src="/2023/03/27/Games101-P5-6/截屏2023-03-31 14.57.13.png" alt="截屏2023-03-31 14.57.13" style="zoom:33%;"></li></ul><h4 id="Sampling-采样"><a href="#Sampling-采样" class="headerlink" title="Sampling 采样"></a>Sampling 采样</h4><ul><li><p>采样函数（一维</p><ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-03-31 15.00.30.png" alt="截屏2023-03-31 15.00.30" style="zoom:33%;"></li></ul></li><li><p>判断像素中心是否在三角形内</p><ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 09.38.41.png" alt="截屏2023-04-01 09.38.41" style="zoom:25%;"></li></ul></li><li><p>二维采样</p><ul><li><pre><code class="lang-c++">for (int x = 0; x&lt; xmax; x++)  for (int y = 0; y &lt; ymax; y++)    image[x][y] = inside(tri, x + 0.5, y+ 0.5); //三角形中心要+0.5</code></pre></li></ul></li><li><p>inside(tri, x, y)具体如何实现：向量叉积</p><ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 09.46.23.png" alt="截屏2023-04-01 09.46.23" style="zoom:25%;"></li><li>$\overrightarrow{P_1P_2} \times \overrightarrow{P_1Q}$ 得到$Q$在$P_1P_2$左边，$P_0P_1$同理</li><li>$\overrightarrow{P_2P_0} \times \overrightarrow{P_2Q}$ 得到$Q$在$P_2P_0$右边</li><li>综上，$Q$在三角形外</li></ul></li><li><p>边界处理：OpenGL认为上左在内，下右在外</p></li></ul><h4 id="光栅化加速优化"><a href="#光栅化加速优化" class="headerlink" title="光栅化加速优化"></a>光栅化加速优化</h4><ul><li>包围盒Bounding Box（AABB）<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 10.03.48.png" alt="截屏2023-04-01 10.03.48" style="zoom:25%;"></li></ul></li><li>每一行只考虑最左和最右，相当于一行一个Bounding Box<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 10.04.55.png" alt="截屏2023-04-01 10.04.55" style="zoom:25%;"></li><li>适用于瘦长三角形</li></ul></li></ul><h4 id="实际屏幕的光栅化-Rasterization-on-Real-Displays"><a href="#实际屏幕的光栅化-Rasterization-on-Real-Displays" class="headerlink" title="实际屏幕的光栅化 Rasterization on Real Displays"></a>实际屏幕的光栅化 Rasterization on Real Displays</h4><ul><li>加色<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 10.23.06.png" alt="截屏2023-04-01 10.23.06" style="zoom:25%;"></li></ul></li><li>减色<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 10.23.30.png" alt="截屏2023-04-01 10.23.30" style="zoom:25%;"></li></ul></li></ul><h4 id="光栅化问题"><a href="#光栅化问题" class="headerlink" title="光栅化问题"></a>光栅化问题</h4><ul><li>锯齿<ul><li>像素有一定大小，采样率不够高，导致图像走样</li></ul></li></ul><h2 id="P6-Rasterization-Antialiasing-and-Z-Buffer-反走样和深度缓冲"><a href="#P6-Rasterization-Antialiasing-and-Z-Buffer-反走样和深度缓冲" class="headerlink" title="P6 Rasterization(Antialiasing and Z-Buffer 反走样和深度缓冲)"></a>P6 Rasterization(Antialiasing and Z-Buffer 反走样和深度缓冲)</h2><h3 id="采样理论"><a href="#采样理论" class="headerlink" title="采样理论"></a>采样理论</h3><ul><li>Artifact：黑话。泛指图形学中的error/mistake/inaccuracies<ul><li>锯齿</li><li>摩尔纹</li><li>车轮倒转效应</li></ul></li><li><strong>产生Artifact的本质原因：信号速度太快，而采样速度跟不上</strong></li></ul><h3 id="如何反走样"><a href="#如何反走样" class="headerlink" title="如何反走样"></a>如何反走样</h3><ul><li><strong>基本思想</strong>：前进行Blur，本质是滤(高频)波；再进行采样<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 10.48.46.png" alt="截屏2023-04-01 10.48.46" style="zoom:33%;"></li><li>不可以先采样，再滤波（先采样的话，混叠的信号已然存在，再进行滤波也无法消除）<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 10.52.16.png" alt="截屏2023-04-01 10.52.16" style="zoom:25%;"></li></ul></li></ul></li></ul><h3 id="Frequency-Domain-频域"><a href="#Frequency-Domain-频域" class="headerlink" title="Frequency Domain 频域"></a>Frequency Domain 频域</h3><h4 id="前置知识-信号处理"><a href="#前置知识-信号处理" class="headerlink" title="前置知识 - 信号处理"></a>前置知识 - 信号处理</h4><ul><li>傅里叶级数展开：任何一个周期函数都可以写成一系列sin和cos的线性组合，和常数项<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 11.07.27.png" alt="截屏2023-04-01 11.07.27" style="zoom:33%;"></li></ul></li><li>傅里叶变换和傅里叶级数展开<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 11.13.01.png" alt="截屏2023-04-01 11.13.01" style="zoom:33%;"><ul><li>通过傅里叶展开可知，上述函数可展开成不同频率的函数</li></ul></li></ul></li></ul><h4 id="走样"><a href="#走样" class="headerlink" title="走样"></a>走样</h4><ul><li>对于傅里叶展开后的函数采样，高频部分出现走样<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 11.17.29.png" alt="截屏2023-04-01 11.17.29" style="zoom:33%;"></li><li><strong>奈奎斯特采样定理</strong>：采样频率要大于信号最高频率的2倍，才能无失真的保留信号的完整信息</li></ul></li><li><strong>走样</strong>：同样的一种采样方法，采样两种不同频率的信号，得出的结果无法进行区分<ul><li>对高频信号通过低频采样出现的走样<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 11.27.15.png" alt="截屏2023-04-01 11.27.15" style="zoom:33%;"></li></ul></li></ul></li></ul><h4 id="Filtering-滤波"><a href="#Filtering-滤波" class="headerlink" title="Filtering 滤波"></a>Filtering 滤波</h4><ul><li>滤波：把某个特定频率抹去</li><li>对图像进行傅里叶变换（变成频域空间<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 16.19.46.png" alt="截屏2023-04-01 16.19.46"><ul><li>右图，中心为最低频。图像细节为高频信息</li><li>右图十字出现原因：图片在平面上平铺，左右边界和上下边界交界处信号变化剧烈，使得四个方向出现高频信号。</li></ul></li></ul></li><li>对图像进行高通滤波<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 16.25.55.png" alt="截屏2023-04-01 16.25.55"></li></ul></li><li>对图像进行低糖滤波<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 16.26.46.png" alt="截屏2023-04-01 16.26.46"></li></ul></li><li><p>中通滤波</p><ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 16.40.29.png" alt="截屏2023-04-01 16.40.29"></li><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 16.41.21.png" alt="截屏2023-04-01 16.41.21"><h5 id="Fliter-Convolution-卷积-Averaging"><a href="#Fliter-Convolution-卷积-Averaging" class="headerlink" title="Fliter = Convolution 卷积 ( = Averaging)"></a>Fliter = Convolution 卷积 ( = Averaging)</h5></li></ul></li><li><p>滤波器和卷积效果相近，但原理不同</p></li><li><p>卷积补充：<a href="https://www.zhihu.com/question/22298352/answer/228543288">如何通俗易懂地理解卷积</a></p><ul><li>卷积可帮助实现平滑算法<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 17.47.54.png" alt="截屏2023-04-01 17.47.54" style="zoom:50%;"></li><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 17.48.40.png" alt="截屏2023-04-01 17.48.40" style="zoom:50%;"></li><li>计算过程说明<img src="/2023/03/27/Games101-P5-6/卷积.gif" alt="卷积"></li><li>计算过程模拟<img src="/2023/03/27/Games101-P5-6/卷积2.gif" alt="卷积2"></li></ul></li></ul></li><li>图形学中Convolution：理解为加权平均<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 17.56.08.png" alt="截屏2023-04-01 17.56.08" style="zoom: 25%;"></li><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 17.56.42.png" alt="截屏2023-04-01 17.56.42" style="zoom:25%;"></li></ul></li></ul><ul><li><strong>卷积定理</strong>：两个信号时域上的卷积，是这两个信号频域上的乘积；反之，时域上的乘积，也等于频域上的卷积<ul><li>理解：时域和频域差一个傅里叶的叠加</li></ul></li><li><p>对图像进行滤波（有两种方法</p><ul><li>Option1: 在空域使用卷积进行滤波</li><li><p>Option2</p><ul><li>利用傅里叶变换将空域图片转到频域空间</li><li>图像在频域下，与<a href="https://blog.csdn.net/i_silence/article/details/116483732">卷积核</a>相乘</li><li>通过逆傅里叶变换重新变回空域</li></ul></li><li><p><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 18.10.54.png" alt="截屏2023-04-01 18.10.54" style="zoom:33%;"></p><ul><li>这个例子：一个像素* <script type="math/tex">\begin{bmatrix} \frac 1 9 & \frac 1 9 & \frac 1 9 \\ \frac 1 9 & \frac 1 9 & \frac 1 9 \\ \frac 1 9 & \frac 1 9 & \frac 1 9 \end{bmatrix} \tag{1}</script> = 一个像素和周围一圈像素求平均</li></ul></li></ul></li><li><p>卷积核Box Filter</p><ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 20.38.22.png" alt="截屏2023-04-01 20.38.22" style="zoom:25%;"></li></ul></li><li><p>Box Function = 低通滤波</p><ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 20.46.24.png" alt="截屏2023-04-01 20.46.24"></li></ul></li><li><p>Wider Filter Kernel = 更低的频率</p><ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 20.46.38.png" alt="截屏2023-04-01 20.46.38"><ul><li>理解：利用更大的卷积核进行卷积操作，得到的卷积频率会更低</li></ul></li></ul></li></ul><h4 id="Sampling采样-Repeating-Frequency-Contents"><a href="#Sampling采样-Repeating-Frequency-Contents" class="headerlink" title="Sampling采样 = Repeating Frequency Contents"></a>Sampling采样 = Repeating Frequency Contents</h4><p><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 20.56.53.png" alt="截屏2023-04-01 20.56.53" style="zoom:50%;"></p><ul><li>上图<ul><li>(e)是(a)和(c)在时域上的乘积</li><li>(f)是(b)和(d)在频域上的卷积</li><li>通过观察(b)和(f)，发现采样的过程是重复原始函数的频谱</li></ul></li><li>走样 = 频谱上的混叠<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 21.17.32.png" alt="截屏2023-04-01 21.17.32" style="zoom:33%;"><ul><li>冲激函数周期变大等于冲击函数频域周期变小，则相乘后函数频域也变小，因此“粘贴的函数图像”变密</li></ul></li></ul></li></ul><h3 id="反走样-Antialiasing"><a href="#反走样-Antialiasing" class="headerlink" title="反走样 Antialiasing"></a>反走样 Antialiasing</h3><h4 id="反走样原理"><a href="#反走样原理" class="headerlink" title="反走样原理"></a>反走样原理</h4><ul><li>Reduce Aliasing Error<ul><li><strong>Option1: 增加采样率</strong><ul><li>增大冲激信号在频域的间隔</li><li>更高分辨率的显示器<ul><li>缺点：成本高&amp;需要很高的很高的分辨率</li></ul></li></ul></li><li><strong>Option2: 进行反走样操作</strong><ul><li>采样前，让信号在频域变窄 = 滤高频 = 图像模糊处理</li></ul></li></ul></li><li>Antialiasing = Limiting, then repeating<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 21.33.11.png" alt="截屏2023-04-01 21.33.11"><ul><li>滤波后，避免上上图中的频域混叠</li></ul></li></ul></li><li>应用于图像处理中<ul><li>一般采样<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 21.36.02.png" alt="截屏2023-04-01 21.36.02" style="zoom:33%;"></li></ul></li><li>反走样——先对三角形模糊<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 21.36.30.png" alt="截屏2023-04-01 21.36.30" style="zoom:33%;"></li></ul></li></ul></li><li>上述的滤波操作？（如何将三角形变模糊）<ul><li>用一定大小的低通滤波器进行卷积</li><li>实际解决方法：对每个像素，把三角形求平均值，再采样<img src="/2023/03/27/Games101-P5-6/截屏2023-04-01 21.40.10.png" alt="截屏2023-04-01 21.40.10" style="zoom: 33%;"><ul><li>卷积：$f(x, y)$ by a 1-pixel box-blur<ul><li>Recall: convolving = filtering = averaging</li></ul></li><li>Then 采样，at every pixel’s center</li></ul></li></ul></li><li>Antialiasing by Computing Average Pixel Value 通过计算像素平均值进行反走样<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-02 09.59.19.png" alt="截屏2023-04-02 09.59.19" style="zoom:33%;"></li></ul></li></ul><h4 id="MSAA-Antialiasing-By-Supersampling"><a href="#MSAA-Antialiasing-By-Supersampling" class="headerlink" title="MSAA: Antialiasing By Supersampling"></a>MSAA: Antialiasing By Supersampling</h4><ul><li><p>原理：超采样Supersampling</p><ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-02 10.04.46.png" alt="截屏2023-04-02 10.04.46" style="zoom:33%;"><ul><li><strong>注意</strong>：MSAA实际上是对Blur的一种近似，是对信号的模糊，并没有提高分辨率（屏幕分辨率没改变）</li></ul></li></ul></li><li>过程举例<ul><li>增加采样点，挨个判断是否在三角形内；四个采样点，覆盖率有$0\%, 25\%, 50\%,75\%,100\%$<ul><li><img src="/2023/03/27/Games101-P5-6/Supersampling.JPG" alt="Supersampling"></li></ul></li></ul></li><li><p>MSAA的<strong>性能代价</strong>：计算量增大</p></li><li><p><strong>实际应用</strong>中以降低性能代价，像素不会被规则的划分为NxN，而是会用更加有效的划分方法，一些点还会被临近像素复用。</p></li></ul><h4 id="FXAA-Fast-Approximate-AA"><a href="#FXAA-Fast-Approximate-AA" class="headerlink" title="FXAA: Fast Approximate AA"></a>FXAA: Fast Approximate AA</h4><ul><li>与增加样本数无关，属于图像的后期处理。速度快</li><li>过程：得到有锯齿的图后，通过图像匹配的方法找到边界部分，将边界换成没有锯齿的边界</li></ul><h4 id="TAA-Temporal-AA"><a href="#TAA-Temporal-AA" class="headerlink" title="TAA: Temporal AA"></a>TAA: Temporal AA</h4><ul><li>理解：将MSAA对应样本，从空间分布改变为时间分布</li></ul><h4 id="补：Super-Resolution超分辨率-Super-Sampling"><a href="#补：Super-Resolution超分辨率-Super-Sampling" class="headerlink" title="补：Super Resolution超分辨率 / Super Sampling"></a>补：Super Resolution超分辨率 / Super Sampling</h4><ul><li><p>将小图放大，并避免锯齿的产生（举例：<a href="https://github.com/nagadomi/waifu2x">waifu2x</a>）</p></li><li><p>DLSS: Deep Learning Super Sampling</p><ul><li>通过深度学习，对放大后缺失的细节进行猜测</li></ul></li></ul><h3 id="Visible可见性-Occlusion遮挡"><a href="#Visible可见性-Occlusion遮挡" class="headerlink" title="Visible可见性 /  Occlusion遮挡"></a>Visible可见性 /  Occlusion遮挡</h3><h4 id="画家算法"><a href="#画家算法" class="headerlink" title="画家算法"></a>画家算法</h4><ul><li>对三角面排序，从远到近画，overwrite in the framebuffer</li><li>会出现错误遮挡<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-02 13.39.23.png" alt="截屏2023-04-02 13.39.23" style="zoom:25%;"></li></ul></li></ul><h4 id="Z-Buffer-深度缓存"><a href="#Z-Buffer-深度缓存" class="headerlink" title="Z-Buffer 深度缓存"></a>Z-Buffer 深度缓存</h4><ul><li>对<strong>像素内</strong>深度进行排序</li><li>Ideas：<ul><li>存储当先像素最小的深度</li><li>在生成最终图像的同时，<strong>同步生成</strong>另一张深度图（深度缓存）<img src="/2023/03/27/Games101-P5-6/截屏2023-04-02 13.54.51.png" alt="截屏2023-04-02 13.54.51"><ul><li>frame buffer stores color values</li><li>depth buffer (z-buffer) stores depth</li></ul></li></ul></li><li>注意：<ul><li>视口变换中，相机放在原点，看向$-Z$方向</li><li>这里为了方便计算，Z-Buffer中规定$Z$均为正值。则$Z$越小表示越近，$Z$越大表示越远</li></ul></li><li>深度缓存实现步骤<ul><li>初始化每个像素的深度缓存值都为$\infty$</li><li>对每个像素进行Rasterization：遍历每一个三角形中的每一个像素，若该三角形中该像素[x,y]的深度值z于zbuffer[x,y]中的值，则更新zbuffer[x,y]的值为z，并且更新该像素[x,y]的颜色<img src="/2023/03/27/Games101-P5-6/截屏2023-04-02 14.05.47.png" alt="截屏2023-04-02 14.05.47"></li></ul></li><li>举例<ul><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-02 14.07.41.png" alt="截屏2023-04-02 14.07.41" style="zoom:33%;"></li></ul></li><li>Z-Buffer复杂度<ul><li><strong>看完数据结构回来<a href="https://www.bilibili.com/video/BV1X7411F744?t=1423.9&amp;p=7">填坑</a></strong></li><li><img src="/2023/03/27/Games101-P5-6/截屏2023-04-02 14.14.54.png" alt="截屏2023-04-02 14.14.54" style="zoom:25%;"></li></ul></li><li>假设没有像素在同一深度（实际情况中，浮点数几乎不可能相等），深度缓存画三角形的顺序将不影响结果</li><li>若结合MSAA，则需针对每一个采样点进行相应的Z-Buffer深度操作</li><li>Z-Buffer处理不了透明物体！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
            <tag> 光栅化 </tag>
            
            <tag> 反走样 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P3-4</title>
      <link href="/2023/03/21/Games101-P3-4/"/>
      <url>/2023/03/21/Games101-P3-4/</url>
      
        <content type="html"><![CDATA[<ul><li>P3 Overview<ul><li>Why study transformation </li><li>2D变换：rotation, scale, shear</li><li>其次坐标：增加一维表示平移变换</li><li>复合变换</li></ul></li><li>P4 Overview<ul><li>3D变换</li><li>Viewing(观测) Transformation<ul><li>View(视图)/Camera Transformation</li><li>Projection(投影) Transformation<ul><li>Orthographic(正交)</li><li>Perspective(透视)</li></ul></li></ul></li></ul></li></ul><span id="more"></span><h1 id="P3-4-Transformation"><a href="#P3-4-Transformation" class="headerlink" title="P3-4 - Transformation"></a>P3-4 - Transformation</h1><h2 id="P3"><a href="#P3" class="headerlink" title="P3"></a>P3</h2><h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><ul><li>Modeling模型变换</li><li>Viewing视图变换：（3D to 2D）projection</li></ul><h3 id="2D-Transformation"><a href="#2D-Transformation" class="headerlink" title="2D Transformation"></a>2D Transformation</h3><ul><li>Scale<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-21 20.16.25.png" alt="截屏2023-03-21 20.16.25" style="zoom:25%;"></li></ul></li><li>Reflection<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-21 20.18.45.png" alt="截屏2023-03-21 20.18.45" style="zoom:25%;"></li></ul></li><li>Shear(切变)<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-21 20.24.18.png" alt="截屏2023-03-21 20.24.18" style="zoom:25%;"></li></ul></li><li>Rotation（特殊化点，推导（旋转绕原点<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-21 20.27.31.png" alt="截屏2023-03-21 20.27.31" style="zoom:25%;"></li><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 10.12.13.png" alt="截屏2023-03-27 10.12.13" style="zoom:25%;"><ul><li>正交矩阵，转置 = 逆</li></ul></li></ul></li><li>线性变换（写成矩阵形式<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-21 21.15.53.png" alt="截屏2023-03-21 21.15.53" style="zoom:25%;"></li></ul></li></ul><h4 id="其次坐标"><a href="#其次坐标" class="headerlink" title="其次坐标"></a>其次坐标</h4><ul><li><p>平移变换——非线性变换，上述矩阵无法满足</p><ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-26 21.13.00.png" alt="截屏2023-03-26 21.13.00" style="zoom:25%;"></li></ul></li><li><p>引入其次坐标</p><ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-26 21.18.19.png" alt="截屏2023-03-26 21.18.19" style="zoom:25%;"></li><li>1和0用于区分是点还是向量<ul><li>向量是0: 因为向量具有平移不变性</li></ul></li><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-26 21.27.22.png" alt="截屏2023-03-26 21.27.22" style="zoom:25%;"><ul><li>point + point得到两点间中点</li></ul></li></ul></li><li>Affine Transform 仿射变换<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-26 21.29.32.png" alt="截屏2023-03-26 21.29.32" style="zoom:25%;"></li><li>$\begin{pmatrix}线 &amp; 性 &amp; 平\\ 变 &amp; 换 &amp; 移\\ 0&amp;0&amp;1 \\ \end{pmatrix}$</li></ul></li><li>逆变换</li><li>复合变换：分步左乘变换矩阵，不满足交换律<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-26 21.42.15.png" alt="截屏2023-03-26 21.42.15" style="zoom:25%;"></li><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-26 21.43.20.png" alt="截屏2023-03-26 21.43.20" style="zoom: 33%;"><ul><li>先应用线性变换，再平移</li></ul></li></ul></li></ul><h3 id="3D-Transformation"><a href="#3D-Transformation" class="headerlink" title="3D Transformation"></a>3D Transformation</h3><ul><li>引入其次坐标<ul><li>$3D\quad point = (x, y, z, 1)^T$</li><li>$3D \quad vector = (x, y, z, 0)^T$</li></ul></li><li>仿射变换<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 10.03.04.png" alt="截屏2023-03-27 10.03.04" style="zoom: 25%;"></li></ul></li></ul><h2 id="P4"><a href="#P4" class="headerlink" title="P4"></a>P4</h2><h3 id="3D-Transformation-1"><a href="#3D-Transformation-1" class="headerlink" title="3D Transformation"></a>3D Transformation</h3><ul><li>三维空间旋转<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 10.27.29.png" alt="截屏2023-03-27 10.27.29" style="zoom:25%;"><ul><li>Y轴旋转相反：X ✖️ Z = -Y</li></ul></li><li>$R_{xyz}(\alpha, \beta ,\gamma) = R_x(\alpha)R_y(\beta)R_z(\gamma)$ 三维空间变换分解<ul><li>$\alpha$, $\beta$ ,$\gamma$ 为欧拉角</li><li>Yaw, Pitch, Roll描述三维空间变换<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 10.37.26.png" alt="截屏2023-03-27 10.37.26" style="zoom:25%;"></li></ul></li></ul></li><li>罗德里格斯旋转公式：绕n轴旋转$\alpha$<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 10.40.09.png" alt="截屏2023-03-27 10.40.09" style="zoom:25%;"></li></ul></li></ul></li></ul><h3 id="Viewing-Transformation-视图变换"><a href="#Viewing-Transformation-视图变换" class="headerlink" title="Viewing Transformation 视图变换"></a>Viewing Transformation 视图变换</h3><p><mark>得到$[-1, 1]^3$的立方体</mark></p><h4 id="View-Camera-Transformation"><a href="#View-Camera-Transformation" class="headerlink" title="View/Camera Transformation"></a>View/Camera Transformation</h4><ul><li><strong>MVP变换</strong><ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 10.52.32.png" alt="截屏2023-03-27 10.52.32" style="zoom: 33%;"></li></ul></li><li>How to perform view transformation? 得到<strong>$M_{view}$视图变换矩阵</strong><ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 10.56.48.png" alt="截屏2023-03-27 10.56.48" style="zoom: 33%;"><ul><li>Up Direction：用一个向量定义相机向上的方向</li></ul></li><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 10.57.15.png" alt="截屏2023-03-27 10.57.15" style="zoom:33%;"><ul><li>相机放在标准位置(0, 0, 0)，向-Z看，上方向为Y</li></ul></li><li>实现上一步的步骤<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 11.03.25.png" alt="截屏2023-03-27 11.03.25" style="zoom:33%;"></li><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 11.05.16.png" alt="截屏2023-03-27 11.05.16" style="zoom:33%;"><ul><li>R~view~^-1^：将xy -z旋转到etg（代入<strong>X</strong>(1,0,0,0)^T^, <strong>Y</strong>(0,1,0,0)^T^, <strong>Z</strong>(0,0,1,0)^T^可以验证XYZ向量的旋转得到etg）<img src="/2023/03/21/Games101-P3-4/IMG_0776.jpg" alt="IMG_0776" style="zoom:25%;"></li><li>正交矩阵，逆 = 转置</li></ul></li></ul></li><li>总结<ul><li>$M_{view}$视图变换操作相机，其他物体跟着相机发生变换</li><li>得到的结果：相机在原点，朝向-Z，上方向为Y</li></ul></li><li>ModelView Transformation模型视图变换：移动相机模型跟着变换，Model和View可相提并论</li></ul></li></ul><h4 id="Projection-Transformation"><a href="#Projection-Transformation" class="headerlink" title="Projection Transformation"></a>Projection Transformation</h4><ul><li>Ortho vs. Persp<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.02.28.png" alt="截屏2023-03-27 14.02.28" style="zoom: 50%;"></li></ul></li></ul><h5 id="Orthographic-Projection正交投影"><a href="#Orthographic-Projection正交投影" class="headerlink" title="Orthographic Projection正交投影"></a>Orthographic Projection正交投影</h5><ul><li>简单做法<ul><li>仍掉Z <img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.05.51.png" alt="截屏2023-03-27 14.05.51" style="zoom:33%;"></li></ul></li><li>正式做法<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.14.53.png" alt="截屏2023-03-27 14.14.53" style="zoom:33%;"><ul><li>定义立方体（三个轴的范围）</li><li>将立方体中心移到原点</li><li>映射到$cube[-1, 1]^3$</li></ul></li></ul></li><li>$M_{ortho}$正交变换矩阵<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.18.21.png" alt="截屏2023-03-27 14.18.21" style="zoom:33%;"><ul><li>先平移，再缩放</li></ul></li></ul></li><li>注意⚠️<ul><li>这里使用右手系。看向-Z方向，所以n平面(近处)的Z数值比f平面(远处)大</li></ul></li></ul><h5 id="Perspective-Projection-透视投影"><a href="#Perspective-Projection-透视投影" class="headerlink" title="Perspective Projection 透视投影"></a>Perspective Projection 透视投影</h5><ul><li>知识回顾<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.32.51.png" alt="截屏2023-03-27 14.32.51" style="zoom:33%;"></li></ul></li><li>步骤<ul><li>概述：<img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.33.45.png" alt="截屏2023-03-27 14.33.45" style="zoom:33%;"><ul><li>将视锥远平面压缩到长方体中（$M_{persp-&gt;ortho}$）<ul><li>近平面永远不变</li><li>远平面中心点不变，Z不变</li></ul></li><li>长方体做正交投影（$M_{ortho}$）</li></ul></li><li>STEP1：将persp视锥远平面压缩到ortho长方体中，xy可通过相似三角形计算，z未知<ul><li>关于Y如何被挤压<img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.41.45.png" alt="截屏2023-03-27 14.41.45" style="zoom:33%;"></li><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.44.02.png" alt="截屏2023-03-27 14.44.02" style="zoom:33%;"></li><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.50.43.png" alt="截屏2023-03-27 14.50.43" style="zoom:33%;"><ul><li>利用近平面的点(x, y, n, 1)，特殊化求解第三行<ul><li>下图右上角：$(x,y,n,1)^T$经$M_{persp-&gt;ortho}$变换后，还是会得到自己本身。因此乘n，得到与左上角格式类似的矩阵（此时的z=n），可看到unknown的值在近平面为$n^2$</li><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.56.24.png" alt="截屏2023-03-27 14.56.24" style="zoom:33%;"><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.57.10.png" alt="截屏2023-03-27 14.57.10" style="zoom:33%;"></li></ul></li><li>利用远平面中点(0, 0, f, 1)不变<img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 14.58.40.png" alt="截屏2023-03-27 14.58.40" style="zoom:33%;"></li><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 15.14.45.png" alt="截屏2023-03-27 15.14.45" style="zoom: 33%;"></li><li>$M_{persp-&gt;ortho} = \begin{pmatrix}n &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; n &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; n+f &amp;-nf \\ 0 &amp; 0 &amp; 1&amp; 0 \\ \end{pmatrix}$</li></ul></li></ul></li><li>STEP2：对压缩后长方体进行$M_{ortho}$<ul><li><img src="/2023/03/21/Games101-P3-4/截屏2023-03-27 15.15.03.png" alt="截屏2023-03-27 15.15.03" style="zoom:33%;"></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
            <tag> MVP变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P2</title>
      <link href="/2023/03/20/Games101-P2/"/>
      <url>/2023/03/20/Games101-P2/</url>
      
        <content type="html"><![CDATA[<ul><li>Overview<ul><li>向量点乘、叉乘</li><li>矩阵</li></ul></li></ul><span id="more"></span><h1 id="P2-Review-Of-Linear-Algebra-向量与线性代数"><a href="#P2-Review-Of-Linear-Algebra-向量与线性代数" class="headerlink" title="P2 - Review Of Linear Algebra 向量与线性代数"></a>P2 - Review Of Linear Algebra 向量与线性代数</h1><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><h3 id="向量点乘"><a href="#向量点乘" class="headerlink" title="向量点乘"></a>向量点乘</h3><ul><li>快速得到两个向量的夹角：如，光照运算中，法线、光线夹角 / 投影<ul><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 18.45.34.png" alt="截屏2023-03-21 18.45.34" style="zoom:25%;"></li></ul></li><li>测量两个向量距离远近<ul><li>单位向量点乘范围[-1, 1]，1近，-1远</li><li>可用于镜面反射，金属高光：反射处附近看，高光明显</li></ul></li><li>判断向量方向，向前/向后<ul><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 19.07.09.png" alt="截屏2023-03-21 19.07.09" style="zoom:25%;"></li></ul></li><li>计算<ul><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 19.01.02.png" alt="截屏2023-03-21 19.01.02" style="zoom:25%;"></li></ul></li></ul><h3 id="向量叉乘"><a href="#向量叉乘" class="headerlink" title="向量叉乘"></a>向量叉乘</h3><ul><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 19.12.25.png" alt="截屏2023-03-21 19.12.25" style="zoom:33%;"></li><li>$\vec{x} \times \vec{y} = + \vec{z}$</li><li>==判断左右==（叉乘向内/外）==/内外==（三角形三边叉乘同向则在内部，光栅化基础）⭐️<ul><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 19.24.34.png" alt="截屏2023-03-21 19.24.34" style="zoom:25%;"></li></ul></li></ul><h3 id="直角坐标系便于向量分解"><a href="#直角坐标系便于向量分解" class="headerlink" title="直角坐标系便于向量分解"></a>直角坐标系便于向量分解</h3><ul><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 19.33.42.png" alt="截屏2023-03-21 19.33.42" style="zoom:25%;"></li></ul><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><ul><li>运算法则<ul><li>(AB)C = A(BC)</li><li>A(B+C) = AB + AC</li><li>(A+B)C = AC + AB</li></ul></li><li>矩阵转置<ul><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 19.43.16.png" alt="截屏2023-03-21 19.43.16" style="zoom:25%;"></li><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 19.45.50.png" alt="截屏2023-03-21 19.45.50" style="zoom:25%;"></li></ul></li><li>单位矩阵<ul><li>是对角阵</li><li>定义矩阵的逆<ul><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 19.47.38.png" alt="截屏2023-03-21 19.47.38" style="zoom:25%;"></li></ul></li></ul></li><li>向量点乘/叉乘写成矩阵形式<ul><li><img src="/2023/03/20/Games101-P2/截屏2023-03-21 19.49.52.png" alt="截屏2023-03-21 19.49.52" style="zoom:25%;"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P1</title>
      <link href="/2023/03/20/Games101-P1/"/>
      <url>/2023/03/20/Games101-P1/</url>
      
        <content type="html"><![CDATA[<ul><li>Overview<ul><li>应用</li><li>course topics</li></ul></li></ul><span id="more"></span><h1 id="P1-Overview-Of-Computer-Graphic"><a href="#P1-Overview-Of-Computer-Graphic" class="headerlink" title="P1 - Overview Of Computer Graphic"></a>P1 - Overview Of Computer Graphic</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>游戏<ul><li>判断画面质量：亮度（全局光照）</li></ul></li><li>电影<ul><li>特效：常见=难做</li></ul></li><li>动画：如毛发，以及和光线作用<ul><li>几何形体的表述</li><li>渲染</li><li>光线计算</li></ul></li><li>设计：如CAD<ul><li>几何</li><li>光照</li><li>物理模拟，如车辆碰撞测试</li></ul></li><li>可视化：将三维空间信息编程视觉信息<ul><li><img src="/2023/03/20/Games101-P1/截屏2023-03-20 14.22.25.png" alt="截屏2023-03-20 14.22.25" style="zoom:50%;"></li></ul></li><li>虚拟现实</li><li>数字图像绘制/处理</li><li>物理模拟</li><li>GUI：图形用户接口（UI设计</li><li>字体设计<ul><li><img src="/2023/03/20/Games101-P1/截屏2023-03-20 20.30.50.png" alt="截屏2023-03-20 20.30.50" style="zoom:25%;"></li></ul></li></ul><h2 id="Course-Topics"><a href="#Course-Topics" class="headerlink" title="Course Topics"></a>Course Topics</h2><ul><li>光栅化（rasterization）<ul><li>三维空间几何形体显示在屏幕上</li><li>广泛用于实时渲染（实时：&gt;30fps）</li></ul></li><li>曲线和曲面</li><li>光线追踪（ray tracing）<ul><li>动画/电影使用</li><li>实时光线追踪</li></ul></li><li>动画与模拟</li></ul>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
