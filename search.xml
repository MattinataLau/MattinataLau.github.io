<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>对自己说</title>
      <link href="/2023/09/26/Others/%E5%AF%B9%E8%87%AA%E5%B7%B1%E8%AF%B4/"/>
      <url>/2023/09/26/Others/%E5%AF%B9%E8%87%AA%E5%B7%B1%E8%AF%B4/</url>
      
        <content type="html"><![CDATA[<h4 id="对自己说"><a href="#对自己说" class="headerlink" title="对自己说"></a><strong>对自己说</strong></h4><ul><li>目标要永远坚定</li><li>不要畏惧环境</li><li>做事一定要认真，像组里大家那样；学习他们思考问题、解决问题的方式</li><li>不要太受情绪控制了</li><li>目标坚定</li><li>早睡早起勤锻炼，保持精力（请务必努力做到: P）</li><li>计划 - 目标 - 完成情况</li><li>别闷头学。看看应用，总结方法！方法！方法！</li><li>及时记录复盘，多反思，多提问</li><li>Stay hungry, stay foolish.</li><li>礼貌 &amp; 谦虚（真的真的很佩服leader）</li><li>看书看电影练琴</li><li>你还有朋友</li></ul>]]></content>
      
      
      <categories>
          
          <category> 羧基的碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对自己说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games202-P1-2 Basic</title>
      <link href="/2023/09/02/Games202/Games202-P1-2/"/>
      <url>/2023/09/02/Games202/Games202-P1-2/</url>
      
        <content type="html"><![CDATA[<ul><li>L2 Preview<ul><li>Recap of CG Basics<ul><li>Basic GPU hardware pipeline</li><li>OpenGL</li><li>OpenGL Shading Language (GLSL)</li><li>The Rendering Equation</li><li>Calculus</li></ul></li></ul></li></ul><span id="more"></span><h1 id="L1-Basic"><a href="#L1-Basic" class="headerlink" title="L1 Basic"></a>L1 Basic</h1><h2 id="Real-time-High-Quality-Rendering"><a href="#Real-time-High-Quality-Rendering" class="headerlink" title="Real-time High Quality Rendering"></a>Real-time High Quality Rendering</h2><ul><li><p>Real-time</p><ul><li>Speed: > 30fps; AR/VR field: > 90fps</li><li>Interactive</li></ul></li><li><p>High quality</p><ul><li>Realism: By trade-off, but advanced approach</li><li>Dependability: Artifacts。模拟物理正确。多数时间正确(精确或近似)，或可容忍的、不可控的少量错误</li></ul></li></ul><h2 id="Course-Topic"><a href="#Course-Topic" class="headerlink" title="Course Topic"></a>Course Topic</h2><ul><li>阴影 &amp; 环境光贴图</li><li>Interactive Global Illumination Techinques</li><li>Precomputerd Radiance Transfer - 空间换时间</li><li>Real-time ray tracing</li><li>Participating Media Rendering, Image Space Effect, etc<ul><li><img src="/2023/09/02/Games202/Games202-P1-2/截屏2023-09-02 16.47.59.png" alt="截屏2023-09-02 16.47.59"></li></ul></li><li><p>Non-Photorealistic Rendering 非真实感渲染NPR</p></li><li><p>Anti-Aliasing and Super-Sampling</p></li></ul><h2 id="How-to-Study"><a href="#How-to-Study" class="headerlink" title="How to Study"></a>How to Study</h2><p><img src="/2023/09/02/Games202/Games202-P1-2/截屏2023-09-02 17.09.46.png" alt="截屏2023-09-02 17.09.46"></p><h2 id="Evolution-of-Real-Time-Rendering"><a href="#Evolution-of-Real-Time-Rendering" class="headerlink" title="Evolution of Real-Time Rendering"></a>Evolution of Real-Time Rendering</h2><ul><li>判断画面渲染好坏<ul><li>画面是否明亮——全局光照 阴影</li><li>油（不自然的高光）——材质细节 粗糙度</li></ul></li><li>Today<ul><li>VR&amp;AR</li><li>电影</li></ul></li></ul><h2 id="Technological-and-Algorithmic-Milestones"><a href="#Technological-and-Algorithmic-Milestones" class="headerlink" title="Technological and Algorithmic Milestones"></a>Technological and Algorithmic Milestones</h2><ul><li>可编程shader</li><li>预计算：在进行复杂渲染前完成计算，空间换时间<ul><li>Complex visual effects are (partially) pre-computed</li><li>Minimum rendering cost at run time</li></ul></li><li><p>预计算方法：Relighting</p><ul><li><img src="/2023/09/02/Games202/Games202-P1-2/image-20230905205333960.png" alt="image-20230905205333960"></li></ul></li><li><p>Interactive Ray Tracing: 在GPU上先以很低的采样率得到噪声较高的图，而后快速降噪</p><ul><li><img src="/2023/09/02/Games202/Games202-P1-2/image-20230905205615709.png" alt="image-20230905205615709"></li></ul></li></ul><h1 id="L2-Recap-of-CG-Basic"><a href="#L2-Recap-of-CG-Basic" class="headerlink" title="L2 Recap of CG Basic"></a>L2 Recap of CG Basic</h1><h2 id="图形渲染管线"><a href="#图形渲染管线" class="headerlink" title="图形渲染管线"></a>图形渲染管线</h2><p><img src="/2023/09/02/Games202/Games202-P1-2/image-20230905212107286.png" alt="image-20230905212107286"></p><ul><li><p>顶点阶段</p><ul><li>针对每一个顶点，MVP变换</li><li>vertex shader</li></ul></li><li><p>光栅化阶段</p><ul><li>将三角形里三成像素</li></ul></li><li><p>Fragment Processing</p><ul><li>Z-Buffer</li></ul></li><li>片元着色<ul><li>Fragment shader</li><li>纹理映射</li></ul></li></ul><h2 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h2><ul><li>一系列API</li><li>在CPU执行，调动GPU</li></ul><h3 id="工作流——类比oil-paint"><a href="#工作流——类比oil-paint" class="headerlink" title="工作流——类比oil paint"></a>工作流——类比oil paint</h3><h4 id="Step1-Place-objects-and-models"><a href="#Step1-Place-objects-and-models" class="headerlink" title="Step1: Place objects and models"></a>Step1: Place objects and models</h4><ul><li><p>输入</p><ul><li><p>什么模型：用户定义的模型被传递给VBO</p><ul><li>Vertex buffer object(VBO)：GPU中负责存储模型的区域（存储vertices、normals、texture、coords，类似.obj文件）</li></ul></li><li><p>模型transformation：调用OpenGL中方法</p></li></ul></li></ul><h4 id="Step2-Set-an-easel"><a href="#Step2-Set-an-easel" class="headerlink" title="Step2: Set an easel"></a>Step2: Set an easel</h4><ul><li>目的<ul><li>视图变换：画架位置是观察位置<ul><li><img src="/2023/09/02/Games202/Games202-P1-2/image-20230907203113714.png" alt="image-20230907203113714" style="zoom:40%;"></li></ul></li><li>创建/指定framebuffer：理解为需要使用哪一个画架</li></ul></li></ul><h4 id="Step3-Attach-a-canvas-to-the-easel"><a href="#Step3-Attach-a-canvas-to-the-easel" class="headerlink" title="Step3: Attach a canvas to the easel"></a>Step3: Attach a canvas to the easel</h4><ul><li><p>指定一个framebuffer可以渲染出多个纹理（multiple render target）,光栅化一次，渲染出多种纹理（如深度、basecolor、etc），由fragment shader告知GPU渲染到对应纹理</p></li><li><p>对于将一个framebuffer渲染目标设置成屏幕</p><ul><li>上一帧没渲染完的画面会被下一帧覆盖，从而造成画面撕裂</li><li>垂直同步：开启，则可避免上述状况</li><li>双重缓冲：先将渲染结果存入一个纹理or缓冲区，确认没问题后再显示</li></ul></li></ul><h4 id="Step4-Paint-to-the-canvas"><a href="#Step4-Paint-to-the-canvas" class="headerlink" title="Step4: Paint to the canvas"></a>Step4: Paint to the canvas</h4><ul><li><p>理解</p><ul><li><p>i.e., how to perform shading</p></li><li><p>This is when vertex / fragment shaders will be used</p></li></ul></li><li><p>对于每一个Vertex</p><ul><li>Vertex shader：顶点的变换 (Model Vie Projection)，顶点插值到对应fragment</li></ul></li><li><p>对于每一个fragment</p><ul><li>fragment shader：shading &amp; lighting</li><li>深度测试</li></ul></li></ul><h4 id="Step5-Attach-other-canvases-to-the-easel-and-continue-painting"><a href="#Step5-Attach-other-canvases-to-the-easel-and-continue-painting" class="headerlink" title="Step5:  (Attach other canvases to the easel and continue painting)"></a>Step5:  (Attach other canvases to the easel and continue painting)</h4><ul><li>结合Step3</li></ul><h4 id="Step6-Use-previous-paintings-for-reference"><a href="#Step6-Use-previous-paintings-for-reference" class="headerlink" title="Step6: (Use previous paintings for reference)"></a>Step6: (Use previous paintings for reference)</h4><ul><li>帧缓冲，结合Steps3</li><li>上一次渲染结果可作为下一次渲染参考（e.g. shadow map，光追中，光线可以看到哪些fragment，摄影机看到的fragment能否也被光线看到，确定阴影区域）</li></ul><h3 id="Summary-in-each-pass"><a href="#Summary-in-each-pass" class="headerlink" title="Summary: in each pass"></a>Summary: in each pass</h3><ul><li>定义objects, camera, MVP, etc,</li><li><p>定义Framebuffer and input/output textures</p></li><li><p>定义vertex shaders &amp; fragment shaders</p></li><li><p>(When you have everything specified on the GPU) Render!</p></li></ul><h2 id="OpenGL-Shading-Language-GLSL"><a href="#OpenGL-Shading-Language-GLSL" class="headerlink" title="OpenGL Shading Language (GLSL)"></a>OpenGL Shading Language (GLSL)</h2><p><img src="/2023/09/02/Games202/Games202-P1-2/image-20230907212151264.png" alt="image-20230907212151264"></p>]]></content>
      
      
      <categories>
          
          <category> Games202 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games202 </tag>
            
            <tag> 高质量实时渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>曲面细分与几何着色器</title>
      <link href="/2023/07/31/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E4%B8%8E%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/"/>
      <url>/2023/07/31/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E4%B8%8E%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>Preview<ul><li>着色器（执行顺序）</li><li>TESS</li><li>GS</li></ul></li></ul><span id="more"></span><h1 id="3-3-曲面细分-Tessellation-Shader-TESS-与几何着色器-Geometry-Shader-GS"><a href="#3-3-曲面细分-Tessellation-Shader-TESS-与几何着色器-Geometry-Shader-GS" class="headerlink" title="3.3 曲面细分 Tessellation Shader (TESS) 与几何着色器 Geometry Shader(GS)"></a>3.3 曲面细分 Tessellation Shader (TESS) 与几何着色器 Geometry Shader(GS)</h1><ul><li>曲面细分着色器的应用<ul><li>海浪、雪地（创造交互）</li><li>与置换贴图结合<img src="/2023/07/31/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E4%B8%8E%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/截屏2023-07-31 00.10.55.png" alt="截屏2023-07-31 00.10.55"></li></ul></li><li>几何着色器的应用<ul><li>几何动画，爆破效果</li><li>草地，可调节密度</li></ul></li></ul><h2 id="着色器执行顺序"><a href="#着色器执行顺序" class="headerlink" title="着色器执行顺序"></a>着色器<strong>执行顺序</strong></h2><ul><li><img src="/2023/07/31/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E4%B8%8E%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/截屏2023-07-31 00.12.17.png" alt="截屏2023-07-31 00.12.17"></li><li>Hull：细分</li><li>Domain：位移（需要空间转换）</li></ul><h2 id="TESS"><a href="#TESS" class="headerlink" title="TESS"></a>TESS</h2><p><img src="/2023/07/31/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E4%B8%8E%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/截屏2023-07-30 15.07.16.png" alt="截屏2023-07-30 15.07.16"></p><ul><li><p>功能：将图元细分(可以是三角形，矩形等)</p></li><li><p>输入输出</p><ul><li>输入：Patch, 可以看成是多个顶点的集合，包含每个顶点的属性，可以指定一个Patch包含的顶点数以及自己的属性</li><li>输出：细分后的顶点</li></ul></li></ul><h3 id="Hull-shader"><a href="#Hull-shader" class="headerlink" title="Hull shader"></a>Hull shader</h3><ul><li><p>决定细分的数量(设定Tessellation factor以及Inside Tessellation factor)</p></li><li><p>对输入的Patch参数进行改变(如果需要)</p></li><li><strong>HULL Shader</strong>各参数解析<ul><li>Tessellation Factor决定将一条边分成几部分；后两个更平滑：<ul><li>equal_Spacing<img src="/2023/07/31/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E4%B8%8E%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/07ab6195-8ca2-4082-a16f-b7078b76b800.gif" alt="07ab6195-8ca2-4082-a16f-b7078b76b800"></li><li>fractional_even_spacing<img src="/2023/07/31/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E4%B8%8E%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/f1bac071-5ad8-4a21-a70e-74253f7b9fba.gif" alt="f1bac071-5ad8-4a21-a70e-74253f7b9fba"></li><li>fractional_odd_spacing<img src="/2023/07/31/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E4%B8%8E%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/9062d404-6325-451c-a717-a67eae3afda1.gif" alt="9062d404-6325-451c-a717-a67eae3afda1"></li></ul></li><li>Inner Tessellation Factor<ul><li><img src="/2023/07/31/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E4%B8%8E%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/截屏2023-07-31 00.28.02.png" alt="截屏2023-07-31 00.28.02"></li></ul></li></ul></li></ul><h3 id="Tessellation-Primitive-Generation"><a href="#Tessellation-Primitive-Generation" class="headerlink" title="Tessellation Primitive Generation"></a>Tessellation Primitive Generation</h3><ul><li>进行细分操作，无法控制</li></ul><h3 id="Domain-Shader"><a href="#Domain-Shader" class="headerlink" title="Domain Shader"></a>Domain Shader</h3><ul><li>对细分后的点进行处理，从重心空间(Barycentric coordinate system)转换到屏幕空间</li></ul><h2 id="GS"><a href="#GS" class="headerlink" title="GS"></a>GS</h2><ul><li><p>输入：图元(三角形，矩形，线等) 。根据图元的不同，shader中会出现对应不同数量的顶点</p></li><li><p>输出：同样为图元，一个或多个，需要自己从顶点构建，顺序很重要同时需要定义最大输出的顶点数</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 百人计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> 着色器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.3 纹理</title>
      <link href="/2023/07/29/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E7%BA%B9%E7%90%86/"/>
      <url>/2023/07/29/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E7%BA%B9%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-3-纹理"><a href="#1-3-纹理" class="headerlink" title="1.3 纹理"></a>1.3 纹理</h1><ul><li>可供着色器读写的，结构化存储形式<ul><li>Image[Height][Width][4]，4为RGBA</li></ul></li><li>Pros：建模工作量、储存空间、读取速度⬇️</li><li>Cons：几何细节损失</li></ul><span id="more"></span><h2 id="纹理管线"><a href="#纹理管线" class="headerlink" title="纹理管线"></a>纹理管线</h2><p><img src="/2023/07/29/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E7%BA%B9%E7%90%86/截屏2023-07-29 16.48.42.png" alt="截屏2023-07-29 16.48.42"></p><p><img src="/2023/07/29/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E7%BA%B9%E7%90%86/截屏2023-07-29 16.55.29.png" alt="截屏2023-07-29 16.55.29" style="zoom:33%;"></p><h2 id="纹理采样中问题解决"><a href="#纹理采样中问题解决" class="headerlink" title="纹理采样中问题解决"></a>纹理采样中问题解决</h2><h3 id="超出UV部分"><a href="#超出UV部分" class="headerlink" title="超出UV部分"></a>超出UV部分</h3><ul><li>Warp mode：纹理采样，超出UV范围时的处理方式<ul><li><img src="/2023/07/29/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E7%BA%B9%E7%90%86/截屏2023-07-29 16.58.11.png" alt="截屏2023-07-29 16.58.11"></li></ul></li></ul><h3 id="纹理被放大"><a href="#纹理被放大" class="headerlink" title="纹理被放大"></a>纹理被放大</h3><ul><li>Filter mode</li></ul><p><img src="/2023/07/29/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E7%BA%B9%E7%90%86/截屏2023-07-29 17.16.27.png" alt="截屏2023-07-29 17.16.27"></p><ul><li><p>纹理被放大</p><ul><li><img src="/2023/07/29/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E7%BA%B9%E7%90%86/截屏2023-07-29 16.59.43.png" alt="截屏2023-07-29 16.59.43"></li></ul></li><li><p>立方卷积插值（Bicubic Interpolation 双三次插值）</p><ul><li><img src="/2023/07/29/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E7%BA%B9%E7%90%86/截屏2023-07-29 17.11.35.png" alt="截屏2023-07-29 17.11.35"></li></ul></li><li>Quilez光滑曲线插值<ul><li>在双线性插值前，改变线性的插值模式</li><li><img src="/2023/07/29/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E7%BA%B9%E7%90%86/截屏2023-07-29 17.14.23.png" alt="截屏2023-07-29 17.14.23"><img src="/2023/07/29/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E7%BA%B9%E7%90%86/截屏2023-07-29 17.15.33.png" alt="截屏2023-07-29 17.15.33"></li></ul></li></ul><h3 id="纹理被缩小"><a href="#纹理被缩小" class="headerlink" title="纹理被缩小"></a>纹理被缩小</h3><ul><li><p>问题：颜色丢失；移动时出现闪烁</p><h4 id="Mipmap"><a href="#Mipmap" class="headerlink" title="Mipmap"></a>Mipmap</h4><ul><li><img src="/2023/07/29/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E7%BA%B9%E7%90%86/截屏2023-07-29 17.20.36.png" alt="截屏2023-07-29 17.20.36"></li><li>确定Mipmap的Level D<ul><li><img src="/2023/07/29/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E7%BA%B9%E7%90%86/截屏2023-07-30 12.10.57.png" alt="截屏2023-07-30 12.10.57"></li></ul></li><li>Mipmap间过渡：<a href="https://mattinatalau.github.io/2023/04/02/Games101/Games101-P7-9/?highlight=双线性#Mipmap间过渡-Trilinear-Interpolation-三线形插值">三线形插值</a></li><li>Mapmap问题：过渡模糊（overblur）。上述金字塔结构的mipmap只考虑了各向同性的纹理<h4 id="各向异性过滤Anisotropic-Filtering"><a href="#各向异性过滤Anisotropic-Filtering" class="headerlink" title="各向异性过滤Anisotropic Filtering"></a>各向异性过滤Anisotropic Filtering</h4></li></ul></li><li><p>Ripmap：做出各种比例的矩形预处理，内存开销变为三倍</p><ul><li><p><img src="/2023/07/29/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E7%BA%B9%E7%90%86/截屏2023-07-30 12.13.21.png" alt="截屏2023-07-30 12.13.21"></p></li><li><p>无法彻底解决多角度观察的问题，如上图红圈部位</p></li></ul></li><li><p>SAT</p><ul><li>积分图Summed-Area Table：所需区域，求平均<ul><li><img src="/2023/07/29/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E7%BA%B9%E7%90%86/截屏2023-07-30 12.56.56.png" alt="截屏2023-07-30 12.56.56"></li></ul></li></ul></li><li><p>重用Mipmap：现代游戏引擎内使用</p><ul><li><img src="/2023/07/29/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E7%BA%B9%E7%90%86/截屏2023-07-30 13.19.16.png" alt="截屏2023-07-30 13.19.16" style="zoom:30%;"></li><li>由屏幕空间像素反向投影到纹理空间，形成不规则四边形；通过四边形覆盖的最短边查找Mipmap的Level；创建一条穿过四边形中心的各向异性线，沿着线段进行采样、合成</li><li>Pros and Cons<ul><li>Prons：因为是沿着各向异性线，所以这个方案不受方向约束，解决了Ripmap的不足；因为是重用Mipmap所以纹理内存消耗只多了1/3</li><li>Cons：沿着各向异性线进行采样、合成，且基于三线形插值，计算消耗要高</li></ul></li></ul></li></ul><h2 id="纹理相关优化"><a href="#纹理相关优化" class="headerlink" title="纹理相关优化"></a>纹理相关优化</h2><h3 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h3><ul><li>纹理图集 / 纹理数组：目的是减少DC数量<ul><li><img src="/2023/07/29/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E7%BA%B9%E7%90%86/截屏2023-07-30 13.31.46.png" alt="截屏2023-07-30 13.31.46"></li></ul></li></ul><h3 id="GPU优化"><a href="#GPU优化" class="headerlink" title="GPU优化"></a>GPU优化</h3><ul><li>压缩纹理：目的是减少带宽 </li></ul><h2 id="其他纹理"><a href="#其他纹理" class="headerlink" title="其他纹理"></a>其他纹理</h2><h3 id="立方体贴图CubeMap"><a href="#立方体贴图CubeMap" class="headerlink" title="立方体贴图CubeMap"></a>立方体贴图CubeMap</h3><ul><li>用三维向量对cubemap进行采样，一个map一个纹理的点</li></ul><h3 id="Bump-Normal-Mapping"><a href="#Bump-Normal-Mapping" class="headerlink" title="Bump/Normal Mapping"></a>Bump/Normal Mapping</h3><ul><li>不增加顶点，没有真正改变顶点的高度。过改变几何体表面各点的法线，使本来是平的东西看起来有凹凸的效果</li></ul><h3 id="Displacement-Mapping"><a href="#Displacement-Mapping" class="headerlink" title="Displacement Mapping"></a>Displacement Mapping</h3><ul><li>真的把顶点作了位置的移动</li></ul>]]></content>
      
      
      <categories>
          
          <category> 百人计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> 纹理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PBR</title>
      <link href="/2023/07/17/Others/PBR/"/>
      <url>/2023/07/17/Others/PBR/</url>
      
        <content type="html"><![CDATA[<p><strong>PBR</strong>补充笔记</p><p>引擎PBR公式基于微表面模型，BRDF：$f_r = f_{spec} + f_{diff}$</p><ul><li><p>其中微表面BRDF高光部分：$f_{spec} = k_s \frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)}$，用于计算specular</p><ul><li><p>$k_s$ 镜面反射比例</p></li><li><p>$\omega_o$ 为光线出射方向，即viewDir；$\omega_i$ 为光线入射方向，即lightDir</p></li><li><p>D为法线分布（描述漫反射/镜面反射）；$D = \frac{Roughness^2}{\pi (cos^2\theta_h(Roughness^2 -1 )+1)^2}$</p></li><li><p>F为菲涅尔项（描述反射、折射的能量分布）；$F = F_0 + (1-F_0)(1-cos\theta _h)^5$，$F_0$根据金属度发生变化</p></li><li><p>G为几何项（描述微表面间的相互遮挡）；$G = G_{GGX}(n\cdot l ,k) \cdot G_{GGX}(n\cdot v ,k)$，其中$G_{GGX}(float \quad dot ,float \quad k) = \frac{dot}{dot(1-k)+k}$，而$k = \frac{(Roughness + 1)^2}{8}$</p></li></ul></li><li><p>其中微表面BRDF高光部分：$f_{diff} = k_d \frac{Diffuse}{\pi}$</p><ul><li><p>$k_d$ 为漫反射比例</p></li><li><p>$Diffusion$ 为纹理颜色</p></li></ul></li><li><p>将微表面BRDF带入反射方程：$L_0 = \int_\pi f_r \cdot L_i \cdot (\omega_i \cdot n)d\omega_i$</p></li></ul><p>基于上述公式，可以实现引擎中PBR</p><p><img src="/2023/07/17/Others/PBR/截屏2023-07-29 13.41.05.png" alt="截屏2023-07-29 13.41.05"></p><span id="more"></span><h1 id="PBR"><a href="#PBR" class="headerlink" title="PBR"></a>PBR</h1><ul><li><p>基于物理</p><ul><li>基于材质</li><li>基于光照</li><li>基于相机</li></ul></li><li><p>基于物理需满足</p><ul><li>微表面模型理论</li><li>能量守恒</li><li></li></ul></li><li><p>如何实现能量守恒</p><ul><li><img src="/2023/07/17/Others/PBR/截屏2023-07-29 12.39.53.png" alt="截屏2023-07-29 12.39.53"></li><li>BRDF<img src="/2023/07/17/Others/PBR/截屏2023-07-29 12.41.54.png" alt="截屏2023-07-29 12.41.54"></li></ul></li><li><p>Cook - Torrance反射率方程</p><ul><li><img src="/2023/07/17/Others/PBR/截屏2023-07-29 12.52.11.png" alt="截屏2023-07-29 12.52.11"></li></ul></li><li><p>高光部分</p><ul><li>D：法线分布函数<ul><li>GGX：更符合真实<ul><li><img src="/2023/07/17/Others/PBR/截屏2023-07-29 12.59.26.png" alt="截屏2023-07-29 12.59.26"></li></ul></li></ul></li><li>G：几何遮蔽函数<ul><li>分为“几何遮蔽”和“几何阴影”</li><li><img src="/2023/07/17/Others/PBR/截屏2023-07-29 13.34.40.png" alt="截屏2023-07-29 13.34.40"></li></ul></li><li>F：菲涅尔<ul><li><img src="/2023/07/17/Others/PBR/截屏2023-07-29 13.39.04.png" alt="截屏2023-07-29 13.39.04"></li></ul></li></ul></li></ul><h1 id="Disney-BRDF"><a href="#Disney-BRDF" class="headerlink" title="Disney BRDF"></a>Disney BRDF</h1><p><img src="/2023/07/17/Others/PBR/截屏2023-07-29 13.49.10.png" alt="截屏2023-07-29 13.49.10" style="zoom:30%;"></p><ul><li><p>使用直观的参数</p></li><li><p>参数尽可能少</p></li><li><p>参数在其合理范围内应为0～1</p></li><li><p>允许参数在有意义时超过这个范围</p></li><li><p>所有参数组合都应尽可能合理</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 补充 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> PBR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games104-P6-7 Rendering</title>
      <link href="/2023/07/04/Games104/Games104-P6-7/"/>
      <url>/2023/07/04/Games104/Games104-P6-7/</url>
      
        <content type="html"><![CDATA[<ul><li>Preview</li></ul><span id="more"></span><h1 id="Lecture6-Rendering-Terrian"><a href="#Lecture6-Rendering-Terrian" class="headerlink" title="Lecture6 Rendering(Terrian)"></a>Lecture6 Rendering(Terrian)</h1><h2 id="地形概述"><a href="#地形概述" class="headerlink" title="地形概述"></a>地形概述</h2><ul><li>Heightfield<ul><li><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-05 16.06.54.png" alt="截屏2023-07-05 16.06.54"></li><li>LOD受限，需要设计<h3 id="复杂面优化"><a href="#复杂面优化" class="headerlink" title="复杂面优化"></a>复杂面优化</h3></li></ul></li><li><p>根据FOV（受焦距影像）设置细致程度（ps：FOV越小，每个三角面对应的像素量就越多</p><ul><li><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-05 16.11.49.png" alt="截屏2023-07-05 16.11.49"></li></ul></li><li><p>两种简化原则 - View dependent error bound</p><ul><li>DIstance to camera and FOV</li><li>Error compare to ground truth (pre-computation) 理解为根据地势差做预先计算，决定网格采样点</li><li><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-19 00.52.22.png" alt="截屏2023-07-19 00.52.22"></li></ul></li></ul><h3 id="Triangle-Based-Subdivision"><a href="#Triangle-Based-Subdivision" class="headerlink" title="Triangle-Based Subdivision"></a><strong>Triangle-Based Subdivision</strong></h3><ul><li>二叉树思想<ul><li><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-19 20.41.07.png" alt="截屏2023-07-19 20.41.07"></li></ul></li></ul><h4 id="T-Junctions"><a href="#T-Junctions" class="headerlink" title="T - Junctions"></a>T - Junctions</h4><ul><li>算法解决思路：若邻边中间被切分，则该边自身也进行切分，递归</li></ul><p><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-19 20.49.18.png" alt="截屏2023-07-19 20.49.18"></p><h3 id="QuadTree-Based-Subdivision"><a href="#QuadTree-Based-Subdivision" class="headerlink" title="QuadTree-Based Subdivision"></a><strong>QuadTree-Based Subdivision</strong></h3><ul><li>四叉树思想<ul><li><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-19 21.23.02.png" alt="截屏2023-07-19 21.23.02"></li></ul></li><li>资源管理思想：每个block，打包Heightfield、植被、贴图等 <ul><li><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-20 00.11.41.png" alt="截屏2023-07-20 00.11.41"></li></ul></li></ul><h4 id="T-Junctions-1"><a href="#T-Junctions-1" class="headerlink" title="T - Junctions"></a><strong>T - Junctions</strong></h4><ul><li>解决思路： 吸附</li></ul><p><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-20 00.17.13.png" alt="截屏2023-07-20 00.17.13"></p><ul><li>退化三角形（面积为0的三角形）渲染问题</li></ul><h3 id="Triangulated-Irregular-Network-TIN"><a href="#Triangulated-Irregular-Network-TIN" class="headerlink" title="Triangulated Irregular Network (TIN)"></a>Triangulated Irregular Network (TIN)</h3><ul><li>通过Heightfield生成不规则三角面组成的地形，节约平缓地区的三角形消耗。</li><li>应用面片简化，节省不必要的顶点，并将必要的顶点align to feature</li><li>Cons<ul><li>需要进行预处理</li><li>Rumtime时很难进行调整</li></ul></li></ul><h2 id="GPU-based-Tessellation"><a href="#GPU-based-Tessellation" class="headerlink" title="GPU based Tessellation"></a>GPU based Tessellation</h2><h3 id="Hardware-Tessellation"><a href="#Hardware-Tessellation" class="headerlink" title="Hardware Tessellation"></a><strong>Hardware Tessellation</strong></h3><p><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-30 15.05.08.png" alt="截屏2023-07-30 15.05.08"></p><p><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-30 15.07.16.png" alt="截屏2023-07-30 15.07.16"></p><ul><li>Hull shader：生成后续subdivision所 要用到的patch，向Tessellator传递细分数据</li><li>Domain shader：根据Displacement map，形成高度起伏</li><li>Geometry shader：再次计算Vertex shader（e.g. 如Texture UV，每个像素的数据）</li></ul><h3 id="Mesh-Shader-Pipeline"><a href="#Mesh-Shader-Pipeline" class="headerlink" title="Mesh Shader Pipeline"></a><strong>Mesh Shader Pipeline</strong></h3><p><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-30 15.19.09.png" alt="截屏2023-07-30 15.19.09"></p><ul><li>将所有shader合为一体，Tessellator使用新的算法。DX12以上支持</li></ul><h3 id="Real-Time-Deformable-Terrain"><a href="#Real-Time-Deformable-Terrain" class="headerlink" title="Real-Time Deformable Terrain"></a>Real-Time Deformable Terrain</h3><p><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-30 15.22.37.png" alt="截屏2023-07-30 15.22.37"></p><ul><li>利用GPU高计算性能，和近处Terrain细分度高，实现地形实时交互 </li></ul><h3 id="Dig-a-Hole-in-Terrain"><a href="#Dig-a-Hole-in-Terrain" class="headerlink" title="Dig a Hole in Terrain"></a><strong>Dig a Hole in Terrain</strong></h3><ul><li><p>Dig hole：将隧道用到的顶点参数设置为无效数，GPU处理时会kill到这些三角面。会出现锯齿</p><ul><li><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-30 15.41.54.png" alt="截屏2023-07-30 15.41.54"></li></ul></li><li><p>Add tunnel：将预先制作好的隧道模型置入其中（直接解决锯齿）</p></li></ul><h3 id="Crazy-Idea-Volumetric-Representation"><a href="#Crazy-Idea-Volumetric-Representation" class="headerlink" title="Crazy Idea - Volumetric Representation"></a><strong>Crazy Idea - Volumetric Representation</strong></h3><ul><li>Terrain体素化表达</li><li>三维空间，每一个点都存储一个权重值，表示该空间物质密度</li></ul><h4 id="Marching-Cubes"><a href="#Marching-Cubes" class="headerlink" title="Marching Cubes"></a><strong>Marching Cubes</strong></h4><ul><li>寻找等值面，在cube中切割（切割方式满足所列出的14种方法）<ul><li><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-30 17.19.53.png" alt="截屏2023-07-30 17.19.53"></li></ul></li></ul><h4 id="Transition-Cell-Lookup-Table：在表格中查找"><a href="#Transition-Cell-Lookup-Table：在表格中查找" class="headerlink" title="Transition Cell Lookup Table：在表格中查找"></a><strong>Transition Cell Lookup Table</strong>：在表格中查找</h4><ul><li><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-30 17.24.56.png" alt="截屏2023-07-30 17.24.56"></li></ul><h2 id="Paint-Terrain-Materials"><a href="#Paint-Terrain-Materials" class="headerlink" title="Paint Terrain Materials"></a>Paint Terrain Materials</h2><h3 id="Terrain-Materials"><a href="#Terrain-Materials" class="headerlink" title="Terrain Materials"></a><strong>Terrain Materials</strong></h3><h4 id="Texture-Splatting"><a href="#Texture-Splatting" class="headerlink" title="Texture Splatting"></a><strong>Texture Splatting</strong></h4><p><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-30 17.30.42.png" alt="截屏2023-07-30 17.30.42"></p><ul><li><p>混合贴图：每一个channel对应一种material的权重</p></li><li><p><strong>Simple Texture Splatting</strong></p><ul><li>问题：混合不真实</li><li><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-30 17.32.31.png" alt="截屏2023-07-30 17.32.31"></li></ul></li><li><p><strong>Advanced Texture Splatting</strong></p><ul><li>利用Height map解决</li><li>问题：相机移动时，分界线抖动</li><li><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-30 17.33.54.png" alt="截屏2023-07-30 17.33.54"></li></ul></li><li><p><strong>Advanced Texture Splatting - Biased</strong></p><ul><li>设置一定的Bias混合范围，对Height插值后blend</li><li><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-30 17.40.18.png" alt="截屏2023-07-30 17.40.18"></li></ul></li></ul><h4 id="Sampling-from-Material-Texture-Array"><a href="#Sampling-from-Material-Texture-Array" class="headerlink" title="Sampling from Material Texture Array"></a>Sampling from Material Texture Array</h4><p><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-30 17.47.31.png" alt="截屏2023-07-30 17.47.31"></p><ul><li>将每一种贴图，都打包成一个Array，每一个Texture为于一个index。混合时，index✖️权重，再叠加</li></ul><h4 id="Parallax-and-Displacement-Mapping"><a href="#Parallax-and-Displacement-Mapping" class="headerlink" title="Parallax and Displacement Mapping"></a><strong>Parallax and Displacement Mapping</strong></h4><p><img src="/2023/07/04/Games104/Games104-P6-7/截屏2023-07-30 18.01.14.png" alt="截屏2023-07-30 18.01.14"></p>]]></content>
      
      
      <categories>
          
          <category> Games104 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games104 </tag>
            
            <tag> 现代游戏引擎 </tag>
            
            <tag> 引擎渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P21-22 Animation</title>
      <link href="/2023/06/21/Games101/Games101-P21-22/"/>
      <url>/2023/06/21/Games101/Games101-P21-22/</url>
      
        <content type="html"><![CDATA[<ul><li><p>P21 Preview</p><ul><li>Keyframe animation</li><li>Physical animation</li><li>Kinematics</li><li>Rigging</li></ul></li><li><p>P22 Preview</p><ul><li><p>Single particle simulation</p><ul><li><p>Explicit Euler method</p></li><li><p>Instability and improvements</p></li></ul></li><li><p>Rigid body simulation</p></li><li><p>Fluid simulation</p></li></ul></li></ul><span id="more"></span><h1 id="P21-Animation"><a href="#P21-Animation" class="headerlink" title="P21 Animation"></a>P21 Animation</h1><ul><li>帧率按需求设定；VR至少90fps</li></ul><h2 id="Keyframe"><a href="#Keyframe" class="headerlink" title="Keyframe"></a>Keyframe</h2><ul><li>给定一系列不同的帧，中间的帧通过插值（linear/non-linear）得到<ul><li><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 14.19.17.png" alt="截屏2023-06-23 14.19.17"></li></ul></li></ul><h2 id="Physical-Simulation"><a href="#Physical-Simulation" class="headerlink" title="Physical Simulation"></a>Physical Simulation</h2><ul><li>牛顿定律 $F = ma$</li></ul><h3 id="Physically-Based-Animation"><a href="#Physically-Based-Animation" class="headerlink" title="Physically Based Animation"></a>Physically Based Animation</h3><p><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 14.35.59.png" alt="截屏2023-06-23 14.35.59"></p><h4 id="质点弹簧系统-Mass-Spring-System"><a href="#质点弹簧系统-Mass-Spring-System" class="headerlink" title="质点弹簧系统 Mass Spring System"></a>质点弹簧系统 Mass Spring System</h4><ul><li>Examples<ul><li>hair</li><li>cloth<img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 14.41.18.png" alt="截屏2023-06-23 14.41.18"></li><li></li></ul></li></ul><h5 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h5><ul><li>模型基础：相互连接的质点和弹簧，考虑弹力和摩擦 </li><li>胡克定律<img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 14.46.16.png" alt="截屏2023-06-23 14.46.16"><ul><li>问题：没有能量损耗，无限振动</li></ul></li><li>添加能量损失<ul><li><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 14.51.03.png" alt="截屏2023-06-23 14.51.03"></li><li>问题：该方法所添加的摩擦力只适用于外部力，对于弹簧内部相互作用力造成的损耗无法模拟</li></ul></li><li>添加内部相互作用力的能量损耗<ul><li><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 14.54.48.png" alt="截屏2023-06-23 14.54.48"></li><li>摩擦力延ab方向（投影</li><li>圆周运动，$f_b = 0$</li></ul></li></ul><h5 id="弹簧的结构"><a href="#弹簧的结构" class="headerlink" title="弹簧的结构"></a>弹簧的结构</h5><p><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 15.04.22.png" alt="截屏2023-06-23 15.04.22"></p><ul><li>上图结构无法模拟 &amp; 如何解决<ul><li>对角线拉扯：出现切变的形变<ul><li>解决：添加蓝色Spring，出现切变时，以提供对伉力；力较强<img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 15.10.06.png" alt="截屏2023-06-23 15.10.06"></li></ul></li><li>Out-of-plane：布料因受力而形变至不在同一平面<ul><li>解决：添加Skip connection；力较弱，只起到辅助作用<img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 15.10.44.png" alt="截屏2023-06-23 15.10.44"></li></ul></li></ul></li></ul><h5 id="Aside-FEM-Finite-Element-Method-Instead-of-Springs"><a href="#Aside-FEM-Finite-Element-Method-Instead-of-Springs" class="headerlink" title="Aside: FEM (Finite Element Method) Instead of Springs"></a>Aside: FEM (Finite Element Method) Instead of Springs</h5><ul><li>考虑力的传导</li></ul><h4 id="Particle-Systems"><a href="#Particle-Systems" class="headerlink" title="Particle Systems"></a>Particle Systems</h4><ul><li><p><strong style="color:red;">本质</strong>：定义个体与群体的关系</p></li><li><p>将动力学系统的模型定义为大量粒子的集合，每个粒子的运动都是由一组物理（或非物理）力来定义的</p></li><li><p>挑战</p><ul><li>需要大量粒子（e.g. fluids</li><li>需要考虑粒子间相互作用力（e.g. 碰撞、吸引力etc（实现困难</li></ul></li><li>对于每一帧动画<ul><li>（if needed）生成新的粒子</li><li>计算每一个粒子间作用力</li><li>更新粒子的位置和速度</li><li>（if needed）根据粒子存活时间，remove the dead</li><li>渲染</li></ul></li><li>粒子间的相互作用力<ul><li><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 15.29.29.png" alt="截屏2023-06-23 15.29.29"></li></ul></li></ul><h5 id="群体模拟"><a href="#群体模拟" class="headerlink" title="群体模拟"></a>群体模拟</h5><ul><li>鸟群<ul><li><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 15.34.44.png" alt="截屏2023-06-23 15.34.44"></li></ul></li><li>人群<ul><li><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 15.37.31.png" alt="截屏2023-06-23 15.37.31"></li></ul></li></ul><h2 id="Kinematics-运动学"><a href="#Kinematics-运动学" class="headerlink" title="Kinematics 运动学"></a>Kinematics 运动学</h2><h3 id="Forward-Kinematics-FK"><a href="#Forward-Kinematics-FK" class="headerlink" title="Forward Kinematics (FK)"></a>Forward Kinematics (FK)</h3><ul><li>定义关节，形成骨骼结构</li><li>关节分类<ul><li><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 15.39.56.png" alt="截屏2023-06-23 15.39.56"></li></ul></li><li>计算：通过 $\theta_1 \&amp; \theta_2$ 计算 $p$ 的位置<ul><li><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 15.43.53.png" alt="截屏2023-06-23 15.43.53"></li></ul></li></ul><h3 id="Inverse-Kinematics-IK"><a href="#Inverse-Kinematics-IK" class="headerlink" title="Inverse Kinematics (IK)"></a>Inverse Kinematics (IK)</h3><ul><li>计算<ul><li><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 15.49.41.png" alt="截屏2023-06-23 15.49.41"></li></ul></li><li>问题：解不唯一<ul><li>解决方法：梯度下降<img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 16.01.46.png" alt="截屏2023-06-23 16.01.46"></li></ul></li></ul><h2 id="Rigging"><a href="#Rigging" class="headerlink" title="Rigging"></a>Rigging</h2><p><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 16.05.54.png" alt="截屏2023-06-23 16.05.54"></p><ul><li><p>对于形状的控制</p></li><li><p>Blend Shapes</p><ul><li>两个不同的动作间，插值控制<img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 16.08.15.png" alt="截屏2023-06-23 16.08.15"></li></ul></li></ul><h2 id="Motion-Capture-Facial-Motion-Capture"><a href="#Motion-Capture-Facial-Motion-Capture" class="headerlink" title="Motion Capture / Facial Motion Capture"></a>Motion Capture / Facial Motion Capture</h2><p><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 16.19.10.png" alt="截屏2023-06-23 16.19.10"></p><p><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 16.20.44.png" alt="截屏2023-06-23 16.20.44"></p><p><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 16.21.38.png" alt="截屏2023-06-23 16.21.38"></p><h1 id="P22"><a href="#P22" class="headerlink" title="P22"></a>P22</h1><h2 id="Single-Particle-Simulation"><a href="#Single-Particle-Simulation" class="headerlink" title="Single Particle Simulation"></a>Single Particle Simulation</h2><ul><li>已知初始位置和速度，解一段时间后的位置和速度</li></ul><h3 id="速度场"><a href="#速度场" class="headerlink" title="速度场"></a>速度场</h3><ul><li><p>速度场——理想情况</p><ul><li>给定位置$x$和时间$t$，都能知道速度；先考虑一个粒子，而后推广<img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 16.38.34.png" alt="截屏2023-06-23 16.38.34"></li></ul></li><li><p>Ordinary Differential Equation (ODE) 常微分方程</p><ul><li><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 16.50.17.png" alt="截屏2023-06-23 16.50.17"></li></ul></li></ul><ul><li>需求：给定位置，求某一时刻的速度</li><li>方法👇</li></ul><h3 id="Euler’s-Method-欧拉方法"><a href="#Euler’s-Method-欧拉方法" class="headerlink" title="Euler’s Method 欧拉方法"></a>Euler’s Method 欧拉方法</h3><p><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 16.54.22.png" alt="截屏2023-06-23 16.54.22"></p><ul><li>缺点<ul><li>误差。缩小步长可提高准确度<img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 16.58.37.png" alt="截屏2023-06-23 16.58.37"></li><li>稳定性；出现正反馈，问题无限放大。如速度场为同心圆，理论上质点做圆周运动。但欧拉方法下无论步长多大，质点都会偏移圆周轨迹<img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 17.03.57.png" alt="截屏2023-06-23 17.03.57"></li></ul></li></ul><h3 id="误差和稳定性"><a href="#误差和稳定性" class="headerlink" title="误差和稳定性"></a>误差和稳定性</h3><ul><li>误差<ul><li>每个时间步长上的误差都会累积。精度随着模拟的进行而降低</li><li>准确性在图形学中可能并不重要</li></ul></li><li><p>稳定性</p><ul><li>错误可能会加剧，导致模拟发散(<strong>diverge</strong>)，即使底层系统没有</li><li>缺乏稳定性是仿真中的一个基本问题，不容忽视</li></ul></li><li><p>Combating Instability</p><ul><li>Midpoint method：$\Delta t$ 时间，应运动到a。计算中点b的速度。对于起始点，应用中点b的速度，得到c<ul><li><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 17.21.26.png" alt="截屏2023-06-23 17.21.26"></li></ul></li><li>Modified Euler：中点法展开式<ul><li>$\Delta t^2$ 二次项，达到模拟抛物线的效果；泰勒展开</li><li><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 17.28.51.png" alt="截屏2023-06-23 17.28.51"></li></ul></li><li>Adaptive step size：通过误差比较（$x_T$和$x_{T/2}$的差距），选择步长大小（是否还需继续二分）<ul><li><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 17.35.13.png" alt="截屏2023-06-23 17.35.13"></li></ul></li><li>Implicit methods：使用下一个时间的速度和加速度进行求解<ul><li><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 17.42.58.png" alt="截屏2023-06-23 17.42.58"></li><li><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 17.46.32.png" alt="截屏2023-06-23 17.46.32"></li><li>补：龙哥库塔方法<img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 18.53.25.png" alt="截屏2023-06-23 18.53.25"></li></ul></li><li>Position-based / Verlet integration：不基于物理<ul><li><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 18.58.37.png" alt="截屏2023-06-23 18.58.37"></li></ul></li></ul></li></ul><h2 id="Rigid-Body-Simulation-刚体模拟"><a href="#Rigid-Body-Simulation-刚体模拟" class="headerlink" title="Rigid Body Simulation 刚体模拟"></a>Rigid Body Simulation 刚体模拟</h2><p><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 19.01.27.png" alt="截屏2023-06-23 19.01.27"></p><ul><li>刚体：不发生形变</li><li>刚体内部运动完全一致，因而刚体可看成一个粒子</li></ul><h2 id="Fluid-Simulation"><a href="#Fluid-Simulation" class="headerlink" title="Fluid Simulation"></a>Fluid Simulation</h2><ul><li>A Simple Position-Based Method<ul><li>通过模拟组成流体的小球的位置，模拟流体的运动</li><li><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 19.06.11.png" alt="截屏2023-06-23 19.06.11"></li></ul></li></ul><h2 id="Eulerian-vs-Lagrangian"><a href="#Eulerian-vs-Lagrangian" class="headerlink" title="Eulerian vs. Lagrangian"></a>Eulerian vs. Lagrangian</h2><p><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 19.17.04.png" alt="截屏2023-06-23 19.17.04"></p><ul><li>Material Point Method (MPM)<ul><li><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 19.20.55.png" alt="截屏2023-06-23 19.20.55"></li></ul></li></ul><h1 id="OVER"><a href="#OVER" class="headerlink" title="OVER!"></a>OVER!</h1><p><img src="/2023/06/21/Games101/Games101-P21-22/截屏2023-06-23 19.37.48.png" alt="截屏2023-06-23 19.37.48"></p>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
            <tag> Animation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games104-P4-5 Rendering</title>
      <link href="/2023/06/21/Games104/Games104-P4-7/"/>
      <url>/2023/06/21/Games104/Games104-P4-7/</url>
      
        <content type="html"><![CDATA[<p><img src="/2023/06/21/Games104/Games104-P4-7/IMG_0937 2.jpg" alt="IMG_0937 2" style="zoom: 25%;"></p><p><img src="/2023/06/21/Games104/Games104-P4-7/IMG_0956.JPG" alt="IMG_0956"></p><span id="more"></span><h1 id="Lecture4-Rendering-硬件"><a href="#Lecture4-Rendering-硬件" class="headerlink" title="Lecture4 Rendering (硬件)"></a>Lecture4 Rendering (硬件)</h1><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 12.25.43.png" alt="截屏2023-06-24 12.25.43"></p><ul><li>游戏渲染的挑战<ul><li>成千上万的objects，需要不同的效果</li><li>计算机硬件复杂，需适配硬件</li><li>帧率需稳定，不能场景变复杂帧率下降</li><li>限制CPU资源的使用，一般10%-20%，需将更多资源留给Gameplay等</li></ul></li></ul><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 12.31.40.png" alt="截屏2023-06-24 12.31.40"></p><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 12.32.05.png" alt="截屏2023-06-24 12.32.05"></p><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 12.39.35.png" alt="截屏2023-06-24 12.39.35"></p><h2 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h2><h3 id="SIMD-amp-SIMT"><a href="#SIMD-amp-SIMT" class="headerlink" title="SIMD&amp;SIMT"></a>SIMD&amp;SIMT</h3><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 13.09.16.png" alt="截屏2023-06-24 13.09.16"></p><ul><li><p>SIMD</p><ul><li>实现单指令多线程的运算</li></ul></li><li><p>SIMT——应用于现代GPU</p><ul><li>一个计算内核，分成小的很多个</li><li>同一个操作在每一个小的core上都进行</li></ul></li></ul><h3 id="GPU架构"><a href="#GPU架构" class="headerlink" title="GPU架构"></a>GPU架构</h3><ul><li><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 13.14.48.png" alt="截屏2023-06-24 13.14.48"></p></li><li><p>CPU GPU间数据尽可能单向传输</p><ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 13.17.54.png" alt="截屏2023-06-24 13.17.54"></li></ul></li><li><p>cache</p><ul><li>cache hit：数据在缓存中，速度快</li><li>cache miss：数据不在缓存而在内存，速度慢</li></ul></li><li>Tile - based GPU<ul><li>应用于移动端，一小块Tile的渲染</li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 13.25.37.png" alt="截屏2023-06-24 13.25.37"></li></ul></li></ul><h2 id="Renderable"><a href="#Renderable" class="headerlink" title="Renderable"></a>Renderable</h2><h3 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h3><ul><li>Mesh primitive<ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 13.29.39.png" alt="截屏2023-06-24 13.29.39"></li></ul></li><li>使用索引的方式存储</li></ul><h3 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h3><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 13.38.52.png" alt="截屏2023-06-24 13.38.52"></p><h3 id="Texture"><a href="#Texture" class="headerlink" title="Texture"></a>Texture</h3><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 13.39.19.png" alt="截屏2023-06-24 13.39.19"></p><h3 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h3><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 13.39.58.png" alt="截屏2023-06-24 13.39.58"></p><h2 id="Render-Objects-in-Engine"><a href="#Render-Objects-in-Engine" class="headerlink" title="Render Objects in Engine"></a>Render Objects in Engine</h2><ul><li><p>变换</p><ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 13.43.33.png" alt="截屏2023-06-24 13.43.33"></li></ul></li><li><p>Submesh</p><ul><li>对于一个GO，根据材质不同，切分成submesh</li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 13.45.04.png" alt=" "></li></ul></li><li><p>针对submesh，相同的材质shader等数据造成资源浪费；解决方法👇</p></li></ul><h3 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h3><ul><li>Resource Pool<ul><li>指引pool中所需的到mesh</li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 13.48.59.png" alt="截屏2023-06-24 13.48.59"></li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 13.50.11.png" alt="截屏2023-06-24 13.50.11"></li></ul></li><li><p>Sort by Material</p><ul><li>目的是尽量不改变显卡的状态设置，一次性做完所有相同材质的渲染</li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 13.53.22.png" alt="截屏2023-06-24 13.53.22"></li></ul></li><li><p>GPU Batch Rendering</p><ul><li>减少Drawcal</li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 13.55.23.png" alt="截屏2023-06-24 13.55.23"></li></ul></li></ul><h2 id="Visibility-Culling-可见性裁剪"><a href="#Visibility-Culling-可见性裁剪" class="headerlink" title="Visibility Culling 可见性裁剪"></a>Visibility Culling 可见性裁剪</h2><ul><li><p>Culling基础思想：计算包围盒是否在事件锥内</p><ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 13.58.40.png" alt="截屏2023-06-24 13.58.40"></li></ul></li><li><p>补：关于包围盒</p><ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 13.59.18.png" alt="截屏2023-06-24 13.59.18"></li></ul></li><li><p>BVH结构，降低Culling的计算复杂度</p><ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 15.17.07.png" alt="截屏2023-06-24 15.17.07"></li></ul></li><li><p>PVS (Potential Visibility Set)</p><ul><li>用于可见性，也可用于资源加载（理解为LOD设置</li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 15.27.11.png" alt="截屏2023-06-24 15.27.11"></li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 15.27.27.png" alt="截屏2023-06-24 15.27.27"></li></ul></li><li><p>now：GPU - Based Culling</p><ul><li>early-z获取深度</li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 15.31.31.png" alt="截屏2023-06-24 15.31.31"></li></ul></li></ul><h2 id="Texture-Compression"><a href="#Texture-Compression" class="headerlink" title="Texture Compression"></a>Texture Compression</h2><ul><li><p>引擎中对图片重新编码——用于实现随机访问</p><ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 19.22.55.png" alt="截屏2023-06-24 19.22.55"></li></ul></li><li><p>Block Compression：将图片切成小块进行压缩</p><ul><li>4*4，找到最亮&amp;最暗，插值压缩</li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 19.26.53.png" alt="截屏2023-06-24 19.26.53"></li></ul></li></ul><h2 id="Cluster-Based-Mesh-Pipeline"><a href="#Cluster-Based-Mesh-Pipeline" class="headerlink" title="Cluster - Based Mesh Pipeline"></a>Cluster - Based Mesh Pipeline</h2><ul><li><p>新的模型管线</p></li><li><p>概述：将许多小面片合成一个cluster，每一个cluster都交给一个gpu的core，做一致的操作</p></li></ul><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 19.39.24.png" alt="截屏2023-06-24 19.39.24"></p><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 19.46.41.png" alt="截屏2023-06-24 19.46.41"></p><ul><li>cluster culling：每一个cluster都有一个Bounding</li></ul><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 19.49.42.png" alt="截屏2023-06-24 19.49.42"></p><p>现代引擎的应用👇</p><h3 id="Nanite"><a href="#Nanite" class="headerlink" title="Nanite"></a>Nanite</h3><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-24 19.45.16.png" alt="截屏2023-06-24 19.45.16"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>现代引擎的设计深度依赖硬件</li><li>submesh的设计支持了拥有不同材质的模型</li><li>用culling算法尽可能少的绘制GO</li><li>GPU Driven：随着GPU越来越强大，更多的工作会转移到GPU进行</li></ul><h1 id="Lecture5-Rendering-光、材质、着色器"><a href="#Lecture5-Rendering-光、材质、着色器" class="headerlink" title="Lecture5 Rendering (光、材质、着色器)"></a>Lecture5 Rendering (光、材质、着色器)</h1><ul><li>参与渲染<ul><li>Lighting：光子被发射、反射、吸收、反弹，the origin of rendering</li><li>Material：光子和物体如何反应</li><li>Shader：光子和物质间反映的复杂运算</li></ul></li></ul><h2 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h2><h3 id="渲染方程-amp-挑战"><a href="#渲染方程-amp-挑战" class="headerlink" title="渲染方程 &amp; 挑战"></a>渲染方程 &amp; 挑战</h3><ul><li><p><a href="https://mattinatalau.github.io/2023/04/23/Games101/Games101-P13-16/#Rendering-Equation-渲染方程">渲染方程 (Games101)</a></p><ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 13.38.17.png" alt="截屏2023-06-25 13.38.17"></li></ul></li><li><p>渲染的挑战<img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 13.47.19.png" alt="截屏2023-06-25 13.47.19"></p><ul><li>阴影</li><li>光源的复杂度</li><li>真实世界中，所有物质都是光源<img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 13.46.13.png" alt="截屏2023-06-25 13.46.13"></li></ul></li></ul><h3 id="基础光照的解决方法"><a href="#基础光照的解决方法" class="headerlink" title="基础光照的解决方法"></a>基础光照的解决方法</h3><ul><li><p>主要光和环境光 —— 解决阴影和所有物质都是光源</p><ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 14.06.10.png" alt="截屏2023-06-25 14.06.10"></li></ul></li><li><p>Blinn - Phong —— 用经验模型解决复杂光源问题</p><ul><li>问题：可能出现能量不守恒；无法表达物理细节</li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 14.08.28.png" alt="截屏2023-06-25 14.08.28"></li></ul></li><li><p>Shadow</p><ul><li>场景中任何一个点，是否从光源可见</li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 14.14.42.png" alt="截屏2023-06-25 14.14.42"></li></ul></li><li>shadow map —— 解决阴影<ul><li>从光看去的深度图</li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 14.15.45.png" alt="截屏2023-06-25 14.15.45"></li><li>问题：从光源出形成Shadow map的采样率和相机观察的采样率不同，造成artifacts<img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 14.20.53.png" alt="截屏2023-06-25 14.20.53"></li></ul></li></ul><h3 id="基于预计算的全局光照GI"><a href="#基于预计算的全局光照GI" class="headerlink" title="基于预计算的全局光照GI"></a>基于预计算的全局光照GI</h3><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 14.32.31.png" alt="截屏2023-06-25 14.32.31"></p><ul><li>如何展现全局光照<ul><li>球面采样，通过BRDF和蒙特卡洛进行卷积运算</li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 14.37.06.png" alt="截屏2023-06-25 14.37.06"></li></ul></li><li><p><a href="https://mattinatalau.github.io/2023/03/27/Games101/Games101-P5-6/?highlight=卷积核#前置知识-信号处理">信号处理前置知识</a></p></li><li><p>球面调和函数 (<a href="https://www.bilibili.com/video/BV1J3411n7WT?t=2465.0">视频具体位置</a>)</p><ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 14.45.11.png" alt="截屏2023-06-25 14.45.11"></li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 14.48.30.png" alt="截屏2023-06-25 14.48.30"></li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 14.49.17.png" alt="截屏2023-06-25 14.49.17"></li></ul></li><li>应用球面调和函数对所得对光照球面展开进行压缩<ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 14.58.25.png" alt="截屏2023-06-25 14.58.25"></li><li>（前置知识在202-6</li></ul></li></ul><h4 id="Lightmap-光照贴图"><a href="#Lightmap-光照贴图" class="headerlink" title="Lightmap 光照贴图"></a>Lightmap 光照贴图</h4><ul><li><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 15.02.24.png" alt="截屏2023-06-25 15.02.24"></p></li><li><p>如何生成光照贴图</p><ul><li>对几何进行简化，降低参数化复杂度，使如下图UV格子分布均匀<img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 15.10.18.png" alt="截屏2023-06-25 15.10.18"></li></ul></li><li><p>Lightmap</p><ul><li>实现 bouncing &amp; 软阴影</li><li>Lighting：<img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 15.13.41.png" alt="截屏2023-06-25 15.13.41"></li><li>Lighting + Direct Lighting<img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 15.14.15.png" alt="截屏2023-06-25 15.14.15"></li><li>Final：（combined with materials<img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 15.13.18.png" alt="截屏2023-06-25 15.13.18"></li></ul></li><li><p>优缺点</p><ul><li>优点<ul><li>runtime下效率高</li><li>可烘焙很多细节</li></ul></li><li>缺点<ul><li>预计算时间长</li><li>只可以处理静态物体和静态光</li><li>占用存储空间——空间换时间的策略</li></ul></li></ul></li></ul><h4 id="Probe"><a href="#Probe" class="headerlink" title="Probe"></a>Probe</h4><h5 id="Light-Probe"><a href="#Light-Probe" class="headerlink" title="Light Probe"></a>Light Probe</h5><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 15.21.54.png" alt="截屏2023-06-25 15.21.54"></p><ul><li>对于游戏场景中的每个Probe，采样一个光场。移动时，寻找周围的Probe，进行插值得出最终结</li><li>空间体素化</li></ul><h5 id="Reflection-Probe"><a href="#Reflection-Probe" class="headerlink" title="Reflection Probe"></a>Reflection Probe</h5><ul><li>针对反射的Probe，密度低但采样精度高（原因：反射对高频敏感）<h5 id="Light-Probe-Reflection-Probe-的优缺点"><a href="#Light-Probe-Reflection-Probe-的优缺点" class="headerlink" title="Light Probe + Reflection Probe 的优缺点"></a>Light Probe + Reflection Probe 的优缺点</h5></li><li>优点<ul><li>runtime下效率高</li><li>静态、动态场景都可以用，runtime可更新</li><li>handle both diffuse and specular shading</li></ul></li><li>缺点<ul><li>为了稳定帧率，更新会选择相对空闲的帧内</li><li>采样率远低于GI，没有GI那种完美的阴影</li></ul></li></ul><h3 id="Image-Based-Lighting-IBL-基于图像的光照"><a href="#Image-Based-Lighting-IBL-基于图像的光照" class="headerlink" title="Image - Based Lighting (IBL) 基于图像的光照"></a>Image - Based Lighting (IBL) 基于图像的光照</h3><p>具体看202，真的没太明白T^T</p><ul><li>核心思想：对真实的环境光照提前做预处理，提前算出环境光照和材质作用的卷积结果</li><li>实时计算变为事实查表，空间换时间</li></ul><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 21.37.15.png" alt="截屏2023-06-25 21.37.15"></p><ul><li><p>回顾BRDF</p><ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 16.06.35.png" alt="截屏2023-07-02 16.06.35"></li><li><p>Diffuse Irradiance Map</p><ul><li>提前算出$L_d$。diffuse结果</li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 16.06.50.png" alt="截屏2023-07-02 16.06.50"></li></ul></li><li><p>Specular</p><ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 16.15.01.png" alt="截屏2023-07-02 16.15.01"></li><li>针对不同roughness，采取mipmap的存储方式存储<img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 16.15.56.png" alt="截屏2023-07-02 16.15.56"></li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 16.21.10.png" alt="截屏2023-07-02 16.21.10"></li></ul></li></ul></li><li><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 16.25.25.png" alt="截屏2023-07-02 16.25.25"></p></li></ul><h3 id="经典阴影方法"><a href="#经典阴影方法" class="headerlink" title="经典阴影方法"></a>经典阴影方法</h3><h4 id="Cascade-Shadow"><a href="#Cascade-Shadow" class="headerlink" title="Cascade Shadow"></a>Cascade Shadow</h4><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 16.30.55.png" alt="截屏2023-07-02 16.30.55"></p><ul><li>由远到近， 精度变高<ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 16.33.19.png" alt="截屏2023-07-02 16.33.19"></li></ul></li><li>难点：不同采样间的插值<ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 16.35.15.png" alt="截屏2023-07-02 16.35.15"></li></ul></li><li>cascade shadow的优缺点<ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 16.40.29.png" alt="截屏2023-07-02 16.40.29"></li></ul></li></ul><h4 id="Hard-Shadow-V-S-Realistic-Shadow"><a href="#Hard-Shadow-V-S-Realistic-Shadow" class="headerlink" title="Hard Shadow V.S. Realistic Shadow"></a>Hard Shadow V.S. Realistic Shadow</h4><p>详见202</p><ul><li>软阴影算法<ul><li>PCF<ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 16.42.17.png" alt="截屏2023-07-02 16.42.17"></li><li>PCSS<ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 16.43.17.png" alt="截屏2023-07-02 16.43.17"></li></ul></li></ul></li><li>Variance Soft Shadow Map (VSSM)<ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 16.46.36.png" alt="截屏2023-07-02 16.46.36"></li></ul></li></ul></li></ul><h2 id="Material-1"><a href="#Material-1" class="headerlink" title="Material"></a>Material</h2><h3 id="Physical-Based-Material"><a href="#Physical-Based-Material" class="headerlink" title="Physical - Based Material"></a>Physical - Based Material</h3><ul><li><p>微表面模型</p><ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 16.43.20.png" alt="截屏2023-06-25 16.43.20"></li></ul></li><li><p><a href="https://mattinatalau.github.io/2023/05/05/Games101/Games101-P17/#Microfacet-BRDF">微表面的BRDF</a></p><ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 16.54.58.png" alt="截屏2023-06-25 16.54.58"></li></ul></li><li><p>GGX</p><ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-29 12.57.40.png" alt="截屏2023-07-29 12.57.40"></li><li>金属的电子捕获光子，无次表面散射</li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 16.52.58.png" alt="截屏2023-06-25 16.52.58"></li></ul></li><li><p>关于DFG都是什么</p><ul><li>D：法线分布<ul><li>GGX绿色的线以拟合<img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 16.51.47.png" alt="截屏2023-06-25 16.51.47"></li></ul></li><li>G：微表面间遮挡<ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 16.58.44.png" alt="截屏2023-06-25 16.58.44"></li></ul></li><li>F：菲涅尔项<ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 17.02.59.png" alt="截屏2023-06-25 17.02.59"></li></ul></li></ul></li></ul><ul><li>迪士尼BRDF原则<ul><li>艺术家的直觉，而不是物理</li><li>参数尽可能少</li><li>参数归一化，特殊情况允许</li><li>所有参数的组合都有意义（plausible and robust</li><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 21.10.31.png" alt="截屏2023-06-25 21.10.31" style="zoom:33%;"></li></ul></li></ul><h4 id="常见的PBR模型"><a href="#常见的PBR模型" class="headerlink" title="常见的PBR模型"></a>常见的PBR模型</h4><h5 id="PBR-Specular-Glossiness"><a href="#PBR-Specular-Glossiness" class="headerlink" title="PBR Specular Glossiness"></a>PBR Specular Glossiness</h5><ul><li>利用图片描述材质，而非参数</li><li>Specular表示菲涅尔项，有RGB三通道，不同颜色菲涅尔不同</li></ul><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 21.12.09.png" alt="截屏2023-06-25 21.12.09"></p><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 21.14.23.png" alt="截屏2023-06-25 21.14.23"></p><h5 id="PBR-Metallic-Roughness"><a href="#PBR-Metallic-Roughness" class="headerlink" title="PBR Metallic Roughness"></a>PBR Metallic Roughness</h5><ul><li>解决Specular易出错而导致菲涅尔出错</li></ul><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 21.25.27.png" alt="截屏2023-06-25 21.25.27"></p><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 21.26.24.png" alt="截屏2023-06-25 21.26.24"></p><h5 id="MR-V-S-SG"><a href="#MR-V-S-SG" class="headerlink" title="MR V.S. SG"></a>MR V.S. SG</h5><ul><li>MR<ul><li>优点<ul><li>更容易被理解，灵活度虽然低但F0（菲涅尔项）不易出错</li><li>贴图存储占据更少空间，metallic和roughness都是灰度图</li></ul></li><li>缺点<ul><li>没太看懂这个T^T</li><li>非金属和金属过渡处，易产生白边</li></ul></li></ul></li><li>SG<ul><li>优点<ul><li>specular直接控制菲涅尔</li></ul></li><li>缺点（MG的优点的反义）</li></ul></li></ul><p><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-06-25 21.30.38.png" alt="截屏2023-06-25 21.30.38"></p><h2 id="Shader管理"><a href="#Shader管理" class="headerlink" title="Shader管理"></a>Shader管理</h2><ul><li>不同现象排列组合，会产生许许多多的shader<ul><li>Uber Shader：一个全方面的shader，通过宏定义去细分情况<ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 17.06.58.png" alt="截屏2023-07-02 17.06.58"></li></ul></li></ul></li><li>跨平台Shader编译 SPIRV<ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 17.11.47.png" alt="截屏2023-07-02 17.11.47"></li></ul></li></ul><h2 id="Summary-of-Popular-AAA-Rendering"><a href="#Summary-of-Popular-AAA-Rendering" class="headerlink" title="Summary of Popular AAA Rendering"></a>Summary of Popular AAA Rendering</h2><ul><li>解决光：Lightmap + Lightprobe</li><li>解决材质：PBR + IBL</li><li>解决阴影：Cascade Shadow + VSSM</li></ul><h2 id="前沿技术"><a href="#前沿技术" class="headerlink" title="前沿技术"></a>前沿技术</h2><ul><li>硬件进步<ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 16.58.31.png" alt="截屏2023-07-02 16.58.31"></li></ul></li><li><p>实时光追</p><ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 16.58.59.png" alt="截屏2023-07-02 16.58.59"></li></ul></li><li><p>实时全局光照</p><ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 17.00.18.png" alt="截屏2023-07-02 17.00.18"></li></ul></li><li><p>复杂材质渲染</p><ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 17.01.53.png" alt="截屏2023-07-02 17.01.53"></li></ul></li><li><p>Virtual Shadow Map</p><ul><li><img src="/2023/06/21/Games104/Games104-P4-7/截屏2023-07-02 17.03.41.png" alt="截屏2023-07-02 17.03.41"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Games104 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games104 </tag>
            
            <tag> 现代游戏引擎 </tag>
            
            <tag> 引擎渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games104-P1-3 基础架构</title>
      <link href="/2023/06/12/Games104/Games104-P1-3/"/>
      <url>/2023/06/12/Games104/Games104-P1-3/</url>
      
        <content type="html"><![CDATA[<p><img src="/2023/06/12/Games104/Games104-P1-3/IMG_0933.jpg" alt="IMG_0933"></p><p><img src="/2023/06/12/Games104/Games104-P1-3/IMG_0935.JPG" alt="IMG_0935"></p><span id="more"></span><h1 id="Lecture2-游戏引擎的分层架构"><a href="#Lecture2-游戏引擎的分层架构" class="headerlink" title="Lecture2 游戏引擎的分层架构"></a>Lecture2 游戏引擎的分层架构</h1><h2 id="引擎分层"><a href="#引擎分层" class="headerlink" title="引擎分层"></a>引擎分层</h2><h3 id="工具层"><a href="#工具层" class="headerlink" title="工具层"></a>工具层</h3><p>构成完整游戏生态体系</p><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-19 14.04.42.png" alt="截屏2023-06-19 14.04.42"></p><ul><li>引擎内：⬆️</li><li>引擎外：DCC</li></ul><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-19 14.07.37.png" alt="截屏2023-06-19 14.07.37"></p><ul><li>Asset conditioning pipeline：各种import&amp;output</li><li>数据间互导需要统一格式</li></ul><h3 id="功能层"><a href="#功能层" class="headerlink" title="功能层"></a>功能层</h3><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-18 20.45.47.png" alt="截屏2023-06-18 20.45.47" style="zoom:33%;"></p><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-18 20.46.31.png" alt="截屏2023-06-18 20.46.31"></p><ul><li>Gametick<ul><li>游戏里的“普朗克时间”，1/30s</li><li>tickLogic：逻辑帧，对于世界tick内的物理模拟</li><li>tickRender：渲染帧，tick内进行渲染</li></ul></li><li>区分引擎&amp;游戏的功能代码：功能层提供引擎功能，部分功能隶属游戏而非游戏引擎</li></ul><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-19 13.28.41.png" alt="截屏2023-06-19 13.28.41"></p><ul><li>多线程架构：如将tickLogic、tickRender、Render放入三个线程</li><li>未来引擎使用多核架构，JOB System更先进，但Dependency的管理困难</li></ul><h3 id="资源层"><a href="#资源层" class="headerlink" title="资源层"></a>资源层</h3><p>资源层管理游戏运行时，生态资源池的分配；管理资产生命周期</p><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-18 17.17.33.png" alt="截屏2023-06-18 17.17.33"></p><ul><li><p>数据引擎化</p><ul><li><p>原因：DCC生成的文件包含大量无效信息</p></li><li><p>做法：Importing时，将Sources转为Assets，使用引擎高效数据</p></li></ul></li><li><p>GUID</p><ul><li>资产的唯一识别号，资产的ID</li><li>通过XML文件，完成数据间关联</li></ul></li></ul><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-18 17.23.33.png" alt="截屏2023-06-18 17.23.33"></p><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-18 20.38.12.png" alt="截屏2023-06-18 20.38.12"></p><ul><li>运行时资源管理——游戏优化<ul><li>handle系统：和GUID一起负责资产的生命周期。类比GC（垃圾回收）系统。例如切换关卡时，部分资产失效，需要加载新的资产</li><li>延迟加载：指的是希望人走到哪，这些资源再加载。例如，玩虚幻引擎做的游戏的时候经常有个细节<em>（不知道最新版本有没有修改）</em>：一个角色出现在你的面前，一开始看到那个贴图很模糊，然后一点点变得更清晰</li></ul></li></ul><h3 id="核心层"><a href="#核心层" class="headerlink" title="核心层"></a>核心层</h3><p>游戏引擎的基础</p><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-19 13.34.23.png" alt="截屏2023-06-19 13.34.23"></p><ul><li>引擎数学库：更适用于引擎，提升效率</li></ul><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-19 13.44.56.png" alt="截屏2023-06-19 13.44.56"></p><ul><li>内存管理<ul><li>尽可能将数据放到一起</li><li>数据按顺序排列</li><li>数据修改时，一次修改一批而非一个</li></ul></li></ul><h3 id="平台层"><a href="#平台层" class="headerlink" title="平台层"></a>平台层</h3><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-19 13.56.01.png" alt="截屏2023-06-19 13.56.01"></p><ul><li><p>平台无关性</p><ul><li>去除平台间差异（系统路径和API）</li></ul></li><li><p>Render Hardware Interface (RHI) </p><ul><li>重新定义API，将SDK封装使用以消除差异</li></ul></li></ul><h2 id="为什么引擎要分层"><a href="#为什么引擎要分层" class="headerlink" title="为什么引擎要分层"></a>为什么引擎要分层</h2><ul><li>降低复杂度<ul><li>下层提供基础服务，每一层各司其职</li></ul></li><li>层层封装<ul><li>底层尽量不改动</li><li>底层稳定，上层灵活</li><li>上层调用下层功能，下层禁止调用上层功能</li></ul></li></ul><h2 id="Piccolo逻辑"><a href="#Piccolo逻辑" class="headerlink" title="Piccolo逻辑"></a>Piccolo逻辑</h2><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-20 18.21.36.png" alt="截屏2023-06-20 18.21.36"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>游戏引擎架构分层</li><li>底层稳定，上层灵活</li><li>tick驱动</li></ol><h1 id="Lecture3-如何构建游戏世界"><a href="#Lecture3-如何构建游戏世界" class="headerlink" title="Lecture3 如何构建游戏世界"></a>Lecture3 如何构建游戏世界</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul><li>Game Object<ul><li>Dynamic 可交互</li><li>Static</li></ul></li><li><p>环境</p><ul><li>Sky</li><li>Vegetation</li><li>Terrain</li></ul></li><li><p>Other</p><ul><li><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-20 18.48.01.png" alt="截屏2023-06-20 18.48.01"></li></ul></li></ul><h2 id="Game-Object"><a href="#Game-Object" class="headerlink" title="Game Object"></a>Game Object</h2><p>属性：Property</p><p>行为：Behavior</p><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-20 18.52.07.png" alt="截屏2023-06-20 18.52.07"></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-20 18.53.32.png" alt="截屏2023-06-20 18.53.32"></li><li><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-20 18.53.52.png" alt="截屏2023-06-20 18.53.52"></li></ul><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>适用于，游戏自定义</p><p>解决继承中，谁是爷爷（？）的问题</p><p>将对象拆分为不同组建</p><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-20 18.58.30.png" alt="截屏2023-06-20 18.58.30"></p><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-20 19.02.54.png" alt="截屏2023-06-20 19.02.54"></p><p>组件化后：</p><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-20 19.03.41.png" alt="截屏2023-06-20 19.03.41"></p><h3 id="商业引擎中的Component"><a href="#商业引擎中的Component" class="headerlink" title="商业引擎中的Component"></a>商业引擎中的Component</h3><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-20 19.05.40.png" alt="截屏2023-06-20 19.05.40"></p><h2 id="如何让世界动起来"><a href="#如何让世界动起来" class="headerlink" title="如何让世界动起来"></a>如何让世界动起来</h2><h3 id="Object-based-Tick"><a href="#Object-based-Tick" class="headerlink" title="Object-based Tick"></a>Object-based Tick</h3><p>按照GO，对GO中Component依此进行tick</p><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-20 19.23.54.png" alt="截屏2023-06-20 19.23.54"></p><h3 id="Component-based-Tick"><a href="#Component-based-Tick" class="headerlink" title="Component-based Tick"></a>Component-based Tick</h3><p>按照Component，针对一个系统tick</p><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-20 19.18.00.png" alt="截屏2023-06-20 19.18.00"></p><h3 id="tick对比"><a href="#tick对比" class="headerlink" title="tick对比"></a>tick对比</h3><p>高效的做法——流水线</p><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-20 19.22.12.png" alt="截屏2023-06-20 19.22.12"></p><h3 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h3><p>eg：如何实现爆炸</p><p>早期：Hardcode；无法解决复杂游戏世界中问题</p><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-21 17.11.16.png" alt="截屏2023-06-21 17.11.16"></p><p>衍生出事件机制；解耦合</p><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-21 17.12.52.png" alt="截屏2023-06-21 17.12.52"></p><p>发出Event给到对应的GO，由GO进一步处理</p><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-21 17.14.07.png" alt="截屏2023-06-21 17.14.07"></p><p>现代游戏引擎设有自定义机制的接口（add custom event</p><h2 id="场景管理"><a href="#场景管理" class="headerlink" title="场景管理"></a>场景管理</h2><p>每一个GO都有一个ID，用于被标识和定位</p><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-21 19.18.31.png" alt="截屏2023-06-21 19.18.31"></p><p>对于非均匀场景，根据GO分布，进行八叉树（空间）划分</p><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-21 19.23.29.png" alt="截屏2023-06-21 19.23.29"></p><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-21 19.25.58.png" alt="截屏2023-06-21 19.25.58"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-21 19.28.20.png" alt="截屏2023-06-21 19.28.20"></p><h2 id="其他需要解决的难题"><a href="#其他需要解决的难题" class="headerlink" title="其他需要解决的难题"></a>其他需要解决的难题</h2><p><img src="/2023/06/12/Games104/Games104-P1-3/截屏2023-06-21 19.35.50.png" alt="截屏2023-06-21 19.35.50"></p><ul><li><p>绑定：运动联动</p><ul><li>父节点先于子节点tick</li></ul></li><li><p>时序问题</p><ul><li>eventTick和posTick解决</li><li>消息分发，引擎优化</li></ul></li><li><p>循环依赖（图片左下角</p><ul><li>物理和动画互相影响，通过插值处理</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Games104 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games104 </tag>
            
            <tag> 现代游戏引擎 </tag>
            
            <tag> 引擎架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P19-20 Camera &amp; Color</title>
      <link href="/2023/05/17/Games101/Games101-P19-20/"/>
      <url>/2023/05/17/Games101/Games101-P19-20/</url>
      
        <content type="html"><![CDATA[<ul><li><p>P19 Preview</p><ul><li>Cameras, Lenses and Light Fields</li></ul></li><li><p>P20 Preview</p><ul><li>Color and Perception</li></ul></li></ul><span id="more"></span><h1 id="P19-Cameras-Lenses-and-Light-Fields"><a href="#P19-Cameras-Lenses-and-Light-Fields" class="headerlink" title="P19 Cameras, Lenses and Light Fields"></a>P19 Cameras, Lenses and Light Fields</h1><h2 id="Field-of-View-FOV"><a href="#Field-of-View-FOV" class="headerlink" title="Field of View (FOV)"></a>Field of View (FOV)</h2><ul><li>定义 $FOV$<ul><li>$h$ 定义为传感器高度</li><li><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-05-28 10.52.29.png" alt="截屏2023-05-28 10.52.29" style="zoom:35%;"></li><li>由于历史原因，通常是指在35mm格式的胶片（36 x 24mm）上使用的镜头的焦距的角度视场</li></ul></li><li>影响FOV<ul><li>传感器大小（全画幅和APS-C）</li><li>焦距</li></ul></li></ul><h2 id="Expose"><a href="#Expose" class="headerlink" title="Expose"></a>Expose</h2><p><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-05-28 11.01.56.png" alt="截屏2023-05-28 11.01.56" style="zoom:35%;"></p><h2 id="Defocus-Blur"><a href="#Defocus-Blur" class="headerlink" title="Defocus Blur"></a>Defocus Blur</h2><p><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-05-28 11.51.30.png" alt="截屏2023-05-28 11.51.30" style="zoom:33%;"></p><ul><li>相对孔径的计算<ul><li><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-05-28 11.55.07.png" alt="截屏2023-05-28 11.55.07" style="zoom:33%;"></li></ul></li></ul><h2 id="Ray-Tracing-Ideal-Thin-Lenses"><a href="#Ray-Tracing-Ideal-Thin-Lenses" class="headerlink" title="Ray Tracing Ideal Thin Lenses"></a>Ray Tracing Ideal Thin Lenses</h2><p><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-05-28 11.59.54.png" alt="截屏2023-05-28 11.59.54" style="zoom:33%;"></p><p><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-05-28 12.02.06.png" alt="截屏2023-05-28 12.02.06" style="zoom:33%;"></p><h2 id="Depth-of-Field"><a href="#Depth-of-Field" class="headerlink" title="Depth of Field"></a>Depth of Field</h2><ul><li>recall最小弥散圆<ul><li><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-05-28 12.10.16.png" alt="截屏2023-05-28 12.10.16" style="zoom:33%;"></li></ul></li><li>模拟：<a href="http://graphics.stanford.edu/courses/cs178/applets/dof.html">http://graphics.stanford.edu/courses/cs178/applets/dof.html</a></li></ul><h2 id="Light-Field-Lumigraph-光场"><a href="#Light-Field-Lumigraph-光场" class="headerlink" title="Light Field / Lumigraph 光场"></a>Light Field / Lumigraph 光场</h2><ul><li>类似虚拟现实<ul><li><img src="/2023/05/17/Games101/Games101-P19-20/IMG_3727.JPG" alt="IMG_3727" style="zoom:30%;"></li></ul></li></ul><h3 id="The-Plenoptic-Function-全光函数"><a href="#The-Plenoptic-Function-全光函数" class="headerlink" title="The Plenoptic Function (全光函数)"></a>The Plenoptic Function (全光函数)</h3><ul><li>$P(\theta,\phi,\lambda,t,V_X,V_Y,V_Z)$ 记录七维光的信息 <ul><li>极坐标表示，向任何方向看<img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-05-28 12.54.47.png" alt="截屏2023-05-28 12.54.47" style="zoom:40%;"></li><li>引入波长 $\lambda$ ，时间 $t$ <img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-05-28 12.57.23.png" alt="截屏2023-05-28 12.57.23" style="zoom:40%;"></li><li>在三维空间中位置任意位置移动，引入 $V_X,V_Y,V_Z$ <img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-05-28 13.01.06.png" alt="截屏2023-05-28 13.01.06" style="zoom:40%;"></li></ul></li><li>光场：任何一个位置，去往任何一个方向的光照强度<ul><li>物体所在的包围盒，向任何一个位置辐射的光线；已知包围盒上被观察点的位置和光线方向（紫色线），进而通过查询光场（黑色线）得到最终结果<ul><li><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-05-28 16.38.58.png" alt="截屏2023-05-28 16.38.58" style="zoom:50%;"></li><li><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-05-28 17.35.28.png" alt="截屏2023-05-28 17.35.28" style="zoom:33%;"></li></ul></li></ul></li><li><p>两个平面可定义一个光场；参数化表示：$u v s t$ 四维参数</p><ul><li><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-05-28 17.46.30.png" alt="截屏2023-05-28 17.46.30" style="zoom:33%;"></li></ul></li><li><p>Uv固定一点看向st；st固定一点看向uv（所有uv都看向st固定的一点，得到该点不同方向的画面，通过这种方式，将cmos接收到的irradiance展开为radiance）</p><ul><li><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-05-28 17.52.39.png" alt="截屏2023-05-28 17.52.39" style="zoom:33%;"></li></ul></li><li><p><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-06-09 11.40.59.png" alt="截屏2023-06-09 11.40.59" style="zoom:50%;"></p></li></ul><h3 id="Light-Field-Camera"><a href="#Light-Field-Camera" class="headerlink" title="Light Field Camera"></a>Light Field Camera</h3><ul><li><strong>特点：可重新聚焦</strong><ul><li><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-06-09 11.46.17.png" alt="截屏2023-06-09 11.46.17" style="zoom:33%;"></li></ul></li><li>理解<ul><li>将原本cmos的像素换成微透镜，将不同方向的光分散后再记录</li><li><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-06-09 11.49.13.png" alt="截屏2023-06-09 11.49.13"></li></ul></li><li>得到一张正常照片的方法<ul><li><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-06-09 11.54.36.png" alt="截屏2023-06-09 11.54.36"></li></ul></li></ul><h1 id="P20-Color-and-Perception"><a href="#P20-Color-and-Perception" class="headerlink" title="P20 Color and Perception"></a>P20 Color and Perception</h1><h2 id="Spectral-Power-Distribution-SPD-谱功率密度"><a href="#Spectral-Power-Distribution-SPD-谱功率密度" class="headerlink" title="Spectral Power Distribution (SPD) 谱功率密度"></a>Spectral Power Distribution (SPD) 谱功率密度</h2><ul><li>描述不同波长光的能量分布<ul><li><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-06-12 16.54.01.png" alt="截屏2023-06-12 16.54.01"></li></ul></li><li>具有线性性质，针对不同波长，intensity可直接叠加</li></ul><h2 id="Biological-Basis-of-Color"><a href="#Biological-Basis-of-Color" class="headerlink" title="Biological Basis of Color"></a>Biological Basis of Color</h2><h3 id="Retinal-Photoreceptor-Cells-Rods视杆细胞-and-Cones视锥细胞"><a href="#Retinal-Photoreceptor-Cells-Rods视杆细胞-and-Cones视锥细胞" class="headerlink" title="Retinal Photoreceptor Cells: Rods视杆细胞 and Cones视锥细胞"></a>Retinal Photoreceptor Cells: Rods视杆细胞 and Cones视锥细胞</h3><p><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-06-12 17.02.24.png" alt="截屏2023-06-12 17.02.24"></p><ul><li>视杆细胞<ul><li>感光</li></ul></li><li>视锥细胞<ul><li>感知颜色，分SML三种类型</li></ul></li></ul><h2 id="Tristimulus-Theory-of-Color"><a href="#Tristimulus-Theory-of-Color" class="headerlink" title="Tristimulus Theory of Color"></a>Tristimulus Theory of Color</h2><p><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-06-12 17.10.35.png" alt="截屏2023-06-12 17.10.35"></p><ul><li>对响应曲线和SPD积分</li></ul><p><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-06-12 17.11.42.png" alt="截屏2023-06-12 17.11.42"></p><h2 id="Metamerism-同色异谱"><a href="#Metamerism-同色异谱" class="headerlink" title="Metamerism 同色异谱"></a>Metamerism 同色异谱</h2><h2 id="Color-Reproduction-Matching-颜色匹配"><a href="#Color-Reproduction-Matching-颜色匹配" class="headerlink" title="Color Reproduction / Matching 颜色匹配"></a>Color Reproduction / Matching 颜色匹配</h2><p><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-06-12 17.15.35.png" alt="截屏2023-06-12 17.15.35"></p><ul><li>加色混合，系数可为负值</li></ul><p><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-06-12 17.16.25.png" alt="截屏2023-06-12 17.16.25"></p><ul><li>以此发明了CIE RGB</li></ul><p><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-06-12 17.18.46.png" alt="截屏2023-06-12 17.18.46"></p><h2 id="Color-Spaces"><a href="#Color-Spaces" class="headerlink" title="Color Spaces"></a>Color Spaces</h2><h3 id="Standard-RGB-sRGB"><a href="#Standard-RGB-sRGB" class="headerlink" title="Standard RGB (sRGB)"></a>Standard RGB (sRGB)</h3><ul><li>广泛应用，但色域有限</li></ul><h3 id="A-Universal-Color-Space-CIE-XYZ"><a href="#A-Universal-Color-Space-CIE-XYZ" class="headerlink" title="A Universal Color Space: CIE XYZ"></a>A Universal Color Space: CIE XYZ</h3><ul><li>非实验测得</li><li>Y对应G，光谱上分布均匀，用来表示亮度</li></ul><p><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-06-12 17.26.22.png" alt="截屏2023-06-12 17.26.22"></p><ul><li>固定Y为1，对x和y进行可视化制作马蹄图</li></ul><p><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-06-12 17.28.14.png" alt="截屏2023-06-12 17.28.14"></p><ul><li>区分：马蹄形-色域；三角形-色彩空间</li></ul><h3 id="Perceptually-Organized-Color-Spaces"><a href="#Perceptually-Organized-Color-Spaces" class="headerlink" title="Perceptually Organized Color Spaces"></a>Perceptually Organized Color Spaces</h3><ul><li><p>HSV</p><ul><li><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-06-12 17.35.50.png" alt="截屏2023-06-12 17.35.50"></li></ul></li><li><p>Lab</p><ul><li><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-06-12 17.37.32.png" alt="截屏2023-06-12 17.37.32"></li></ul></li><li><p>CMYK - 减色系统</p><ul><li>直射为加色，反射为减色</li><li><img src="/2023/05/17/Games101/Games101-P19-20/截屏2023-06-12 17.42.30.png" alt="截屏2023-06-12 17.42.30"></li><li>K为黑色：节约CMY混合得到黑色的消耗</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
            <tag> Camera </tag>
            
            <tag> Color </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P18 Advanced Topics in Rendering</title>
      <link href="/2023/05/08/Games101/Games101-P18/"/>
      <url>/2023/05/08/Games101/Games101-P18/</url>
      
        <content type="html"><![CDATA[<ul><li>P18 Preview<ul><li>Advanced Light Transport: <img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-08 13.32.40.png" alt="截屏2023-05-08 13.32.40" style="zoom: 33%;">A</li><li>Advanced Appearance Modeling: <img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-08 18.54.53.png" alt="截屏2023-05-08 18.54.53" style="zoom: 33%;"></li></ul></li></ul><span id="more"></span><h1 id="P18-Advanced-Topics-in-Rendering"><a href="#P18-Advanced-Topics-in-Rendering" class="headerlink" title="P18 Advanced Topics in Rendering"></a>P18 Advanced Topics in Rendering</h1><h2 id="Advanced-Light-Transport"><a href="#Advanced-Light-Transport" class="headerlink" title="Advanced Light Transport"></a>Advanced Light Transport</h2><ul><li>概述<ul><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-08 13.32.40.png" alt="截屏2023-05-08 13.32.40" style="zoom:40%;"></li><li>Unbiased 无偏的</li></ul></li></ul><h3 id="Biased-vs-Unbiased-Monte-Carlo-Estimators"><a href="#Biased-vs-Unbiased-Monte-Carlo-Estimators" class="headerlink" title="Biased vs. Unbiased Monte Carlo Estimators"></a>Biased vs. Unbiased Monte Carlo Estimators</h3><ul><li>对比<ul><li>Unbiased 无偏：无论使用多少样本，无偏估计量的期望值总是正确</li><li>否则，为Biased有偏的（一种特殊情况，样本数无限多，期望值收敛于正确的值，这种情况称作consistent）</li></ul></li></ul><h3 id="Bidirectional-Path-Tracing-BDPT"><a href="#Bidirectional-Path-Tracing-BDPT" class="headerlink" title="Bidirectional Path Tracing (BDPT)"></a>Bidirectional Path Tracing (BDPT)</h3><p>跟踪来自照相机和光线的子路径，从两个子路径中连接端点</p><p><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-08 13.50.19.png" alt="截屏2023-05-08 13.50.19" style="zoom:50%;"></p><ul><li>应用场景：在光源由漫反射形成的场景中效果较好<ul><li>从相机出发的光线若为漫反射，则不容易达到光源处，因而BDPT效果会好</li><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-08 13.55.09.png" alt="截屏2023-05-08 13.55.09" style="zoom:40%;"></li></ul></li></ul><h3 id="Metropolis-Light-Transport-MLT"><a href="#Metropolis-Light-Transport-MLT" class="headerlink" title="Metropolis Light Transport (MLT)"></a>Metropolis Light Transport (MLT)</h3><ul><li><p>思想：利用统计学采样工具“马尔可夫链” + 蒙特卡洛积分，生成与被积分函数形状一致的函数为PDF进行采样（当PDF函数和被采样函数形状一致时，采样方差最小）</p></li><li><p>局部的操作，采样（产生路径）时，通过一定的概率扰动路径的传播，以已有路径作为种子，生成与已有路径相似的路径</p></li><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-08 14.05.38.png" alt="截屏2023-05-08 14.05.38" style="zoom:40%;"></li><li><p>优：适用于光线复杂的场景</p><ul><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-08 14.14.44.png" alt="截屏2023-05-08 14.14.44" style="zoom:40%;"></li></ul></li><li><p>劣：难以理论分析收敛（渲染完成的）速度；画面效果可能比较脏</p><ul><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-08 14.20.35.png" alt="截屏2023-05-08 14.20.35" style="zoom:40%;"></li></ul></li></ul><h3 id="Photon-Mapping-光子映射"><a href="#Photon-Mapping-光子映射" class="headerlink" title="Photon Mapping 光子映射"></a>Photon Mapping 光子映射</h3><p>解释参考知乎：<a href="https://zhuanlan.zhihu.com/p/208356944">光子映射总结（1/4）：基本全局光子映射（Basic Photon Mapping）</a></p><p>适用于caustics</p><p><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-08 14.21.49.png" alt="截屏2023-05-08 14.21.49" style="zoom:40%;"></p><ul><li>步骤<ul><li>STEP1: 光线向各个方向出射光子，进行反射/折射，直到打到Diffuse的表面才停止（构建一张光子图，存储从光源发射的所有光子的通量信息）</li><li>STEP2: 从相机出发，进行反射/折射，直到打到Diffuse的表面才停止（从相机出发，进行传统的路径追踪（path tracing），在追踪到漫反射表面的时候，统计附近的光子信息，并根据这些信息计算出最终的辐射率（radiance））</li><li>STEP3: 局部密度估算<ul><li>想法：有更多光子的区域应该会更亮</li><li>对于每个着色点，找到最近的 $N$ 个光子。取这 $N$ 个光子所占的表面积 $S$</li><li>计算密度（$N/S$）</li></ul></li><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-08 14.34.46.png" alt="截屏2023-05-08 14.34.46"></li></ul></li><li>问题：光子数少，Noise明显；光子数大，画面模糊</li><li>Why biased？<ul><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-08 14.40.22.png" alt="截屏2023-05-08 14.40.22" style="zoom:40%;"></li><li>But consistent: 射出光子无限多，无限趋向于真实</li></ul></li></ul><h3 id="Vertex-Connection-and-Merging-VCM"><a href="#Vertex-Connection-and-Merging-VCM" class="headerlink" title="Vertex Connection and Merging (VCM)"></a>Vertex Connection and Merging (VCM)</h3><ul><li>是BDPT和光子映射的结合<ul><li>两端使用BDPT后，对邻近的断点使用光子映射</li></ul></li><li>电影制作中广泛应用</li></ul><p><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-08 18.31.04.png" alt="截屏2023-05-08 18.31.04"></p><h3 id="Instant-Radiosity-IR-实时辐射度算法"><a href="#Instant-Radiosity-IR-实时辐射度算法" class="headerlink" title="Instant Radiosity (IR) 实时辐射度算法"></a>Instant Radiosity (IR) 实时辐射度算法</h3><ul><li>思想<ul><li>认为已经被照亮的面，都是光源</li><li>针对一个着色点，认为其被其他“光源”照亮——利用直接光照的方法，获取间接光照的结果</li></ul></li><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-08 18.41.02.png" alt="截屏2023-05-08 18.41.02"></li><li>优劣<ul><li>优：fast and usually gives good results on diffuse scenes</li><li>劣<ul><li>缝隙处出现亮点（原因：对渲染方程的积分换元时，从换成 $d\omega$ 光源面积 $dA$ ，分母出现 $|x’ - x|^2$ 。因此两点间距离极小时， $L_o$ 极大）</li><li>做不出glossy</li></ul></li><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-08 18.52.15.png" alt="截屏2023-05-08 18.52.15"></li></ul></li></ul><h2 id="Advanced-Appearance-Modeling"><a href="#Advanced-Appearance-Modeling" class="headerlink" title="Advanced Appearance Modeling"></a>Advanced Appearance Modeling</h2><ul><li>概述<ul><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-08 18.54.53.png" alt="截屏2023-05-08 18.54.53" style="zoom:50%;"></li></ul></li></ul><h3 id="Non-Surface-Models"><a href="#Non-Surface-Models" class="headerlink" title="Non-Surface Models"></a>Non-Surface Models</h3><h4 id="Participating-Media-散射介质"><a href="#Participating-Media-散射介质" class="headerlink" title="Participating Media 散射介质"></a>Participating Media 散射介质</h4><ul><li><p>举例：雾（有体积，不局限于表面）</p><ul><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-12 22.13.17.png" alt="截屏2023-05-12 22.13.17" style="zoom:33%;"></li><li>光可以穿过很多物体，不仅仅是雾这类，只是穿过不久会消失（次表面散射<ul><li>如，光穿过手：<img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-12 22.13.36.png" alt="截屏2023-05-12 22.13.36" style="zoom:50%;"></li></ul></li></ul></li><li><p><strong>光在行进过程中，穿过散射介质时，会发生吸收、散射</strong></p><ul><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-08 18.59.12.png" alt="截屏2023-05-08 18.59.12"></li></ul></li><li>Phase Function 相位函数：决定光线如何散射的函数（类比BRDF，决定光线如何反射）<ul><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-08 19.01.01.png" alt="截屏2023-05-08 19.01.01"></li></ul></li><li>Rendering<ul><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-12 22.10.03.png" alt="截屏2023-05-12 22.10.03"></li></ul></li></ul><h4 id="Hair-Appearance"><a href="#Hair-Appearance" class="headerlink" title="Hair Appearance"></a>Hair Appearance</h4><p>描述光线如何和一根曲线作用（写实）</p><h5 id="Kajiya-Kay-Model"><a href="#Kajiya-Kay-Model" class="headerlink" title="Kajiya-Kay Model"></a>Kajiya-Kay Model</h5><ul><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-12 22.19.59.png" alt="截屏2023-05-12 22.19.59" style="zoom: 40%;"></li><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-12 22.20.31.png" alt="截屏2023-05-12 22.20.31" style="zoom:33%;"></li></ul><h5 id="Marschner-Model-——-广泛应用"><a href="#Marschner-Model-——-广泛应用" class="headerlink" title="Marschner Model —— 广泛应用"></a>Marschner Model —— 广泛应用</h5><ul><li>R：表示反射</li><li>T：表示折射<ul><li>TT：两次折射穿出表面</li><li>TRT：头发内反射一次后，再折射出去</li></ul></li><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-12 22.22.02.png" alt="截屏2023-05-12 22.22.02" style="zoom:40%;"></li><li>将毛发看作玻璃柱<ul><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-12 22.25.19.png" alt="截屏2023-05-12 22.25.19"></li></ul></li><li><p><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-12 22.27.12.png" alt="截屏2023-05-12 22.27.12" style="zoom:50%;"></p></li><li><p>Human Hair vs Animal Fur</p><ul><li>动物毛发髓质部分所占体积大，导致光线在毛发内更易发生散射</li><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-12 22.42.57.png" alt="截屏2023-05-12 22.42.57" style="zoom:50%;"></li></ul></li></ul><h4 id="Granular-Material-颗粒材质"><a href="#Granular-Material-颗粒材质" class="headerlink" title="Granular Material 颗粒材质"></a>Granular Material 颗粒材质</h4><ul><li>渲染耗时长</li><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-16 19.44.22.png" alt="截屏2023-05-16 19.44.22"></li></ul><h3 id="Surface-Models"><a href="#Surface-Models" class="headerlink" title="Surface Models"></a>Surface Models</h3><h4 id="Translucent-Material"><a href="#Translucent-Material" class="headerlink" title="Translucent Material"></a>Translucent Material</h4><ul><li>概念：光进入物体表面后，在内部会发生吸收、散射，改变传播方向，最终射出（举例：人体皮肤、玉石、水母）</li><li>Subsurface Scattering<ul><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-16 19.58.51.png" alt="截屏2023-05-16 19.58.51"></li></ul></li><li>Scattering Functions<ul><li>BSSRDF（对BRDF的延伸）：不仅需考虑该点入射光的贡献，还需考虑周围其它点对该点的贡献。对方向和面积都需要进行积分</li><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-16 20.09.54.png" alt="截屏2023-05-16 20.09.54"></li><li><img src="/2023/05/08/Games101/Games101-P18/IMG_3434.JPG" alt="IMG_3434"></li></ul></li><li>Dipole Approximation（一种对次表面散射的模拟方法）<ul><li>近似为，材质里面一个</li><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-16 20.10.54.png" alt="截屏2023-05-16 20.10.54"></li></ul></li></ul><h4 id="Cloth"><a href="#Cloth" class="headerlink" title="Cloth"></a>Cloth</h4><ul><li><p>布料：Fiber纤维 ➡️ Ply股 ➡️ Yarn线</p><ul><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-16 21.01.51.png" alt="截屏2023-05-16 21.01.51"></li></ul></li><li><p>Rendering</p><ul><li><p>Render as Surface：当成整个表面渲染（BRDF，存在各向异性的局限性）</p><ul><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-16 21.08.35.png" alt="截屏2023-05-16 21.08.35"></li></ul></li><li><p>Render as Participating Media：微观层面，将布料当成反射介质（计算量大）</p><ul><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-16 21.13.53.png" alt="截屏2023-05-16 21.13.53"></li></ul></li><li>Render as Actual Fibers：渲染每一根纤维（计算量大）<ul><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-16 21.17.31.png" alt="截屏2023-05-16 21.17.31"></li></ul></li></ul></li></ul><h4 id="Detailed-Appearance"><a href="#Detailed-Appearance" class="headerlink" title="Detailed Appearance:"></a>Detailed Appearance:</h4><ul><li>更贴近真实世界：划痕<ul><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-16 21.23.16.png" alt="截屏2023-05-16 21.23.16"></li></ul></li><li>Recap: Microfacet BRDF<ul><li>$D(h)$ 为法线分布<img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-16 21.28.27.png" alt="截屏2023-05-16 21.28.27"></li><li>$D(h)$ 法线分布过于光滑时，无法模拟细节<img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-16 21.29.08.png" alt="截屏2023-05-16 21.29.08"></li></ul></li><li>法线分布不同的结果<ul><li><img src="/2023/05/08/Games101/Games101-P18/IMG_3437.JPG" alt="IMG_3437"></li><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-16 21.38.42.png" alt="截屏2023-05-16 21.38.42" style="zoom:33%;"></li></ul></li><li>Problem &amp; Solution<ul><li>Difficult path sampling problem<ul><li>每一个微表面都发生镜面反射，Path Tracing光线很难打到光源处<img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-16 21.35.04.png" alt="截屏2023-05-16 21.35.04"></li></ul></li><li>Solution: BRDF over a pixel<ul><li>考虑一个像素覆盖很多微表面，计算覆盖范围内微表面的法线分布<img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-16 21.37.29.png" alt="截屏2023-05-16 21.37.29"></li></ul></li></ul></li></ul><h4 id="Recent-Trend-Wave-Optics-波动光学"><a href="#Recent-Trend-Wave-Optics-波动光学" class="headerlink" title="Recent Trend: Wave Optics 波动光学"></a>Recent Trend: Wave Optics 波动光学</h4><ul><li>光的波动性——干涉、衍射<img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-17 15.28.01.png" alt="截屏2023-05-17 15.28.01"><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-17 15.28.43.png" alt="截屏2023-05-17 15.28.43"></li></ul><h3 id="Procedural-Appearance-程序化生成"><a href="#Procedural-Appearance-程序化生成" class="headerlink" title="Procedural Appearance 程序化生成"></a>Procedural Appearance 程序化生成</h3><ul><li>使用3D Noise函数定义三维纹理（如Perlin Noise；用于树木年轮等；切面纹理可见）<ul><li><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-17 17.17.27.png" alt="截屏2023-05-17 17.17.27"><img src="/2023/05/08/Games101/Games101-P18/截屏2023-05-17 17.19.16.png" alt="截屏2023-05-17 17.19.16"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
            <tag> 材质 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>补充资料存档</title>
      <link href="/2023/05/07/Others/others/"/>
      <url>/2023/05/07/Others/others/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>计算机图形学相关学习资料</strong></li></ul><p><a href="http://15462.courses.cs.cmu.edu/spring2023/">CMU Computer Graphic</a></p><p><a href="http://blog.showmeai.tech/cmu-15-462">CMU计算机图形学-学习资料</a> / 内涵很多国外大学CS、AI优质课</p><ul><li><strong>中文独立博客</strong></li></ul><p><a href="https://github.com/timqian/chinese-independent-blogs">整理合集</a></p><ul><li><strong>慢慢慢慢学</strong></li></ul><p><a href="https://advances.realtimerendering.com/">SIGGRAPH Advances in Real-Time Rendering</a></p><p><a href="https://www.gamedeveloper.com/">game developer</a></p>]]></content>
      
      
      <categories>
          
          <category> 补充 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 补充 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P17 Material</title>
      <link href="/2023/05/05/Games101/Games101-P17/"/>
      <url>/2023/05/05/Games101/Games101-P17/</url>
      
        <content type="html"><![CDATA[<ul><li>P17 Preview (Materials &amp; Appearances)<ul><li>Diffuse / Lambertian Material</li><li>Glossy material (BRDF)</li><li>Ideal reflective / refractive material (BSDF*)<ul><li>Fresnel Reflection / Term 菲涅尔项</li></ul></li><li>Microfacet Material 微表面模型<ul><li>Microfacet BRDF</li></ul></li><li>Isotropic / Anisotropic Materials (BRDFs) 各向同性/各向异性</li><li>BRDF性质</li></ul></li></ul><span id="more"></span><h1 id="P17-Materials-amp-Appearances"><a href="#P17-Materials-amp-Appearances" class="headerlink" title="P17 Materials &amp; Appearances"></a>P17 Materials &amp; Appearances</h1><p>外观 = 光线 + 材质；研究光照和材质的作用方式</p><p><strong>Material == BDRF</strong></p><h2 id="Diffuse-Lambertian-Material"><a href="#Diffuse-Lambertian-Material" class="headerlink" title="Diffuse / Lambertian Material"></a>Diffuse / Lambertian Material</h2><p><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-07 16.20.18.png" alt="截屏2023-05-07 16.20.18"></p><ul><li>该类材质特点：假设从各个方向射入的Radiance光线相同，则反射光同样为uniform(均匀)的；假设<strong>无能量吸收</strong>，由于能量守恒，则 $Iradiance_{入射} = Irradiance_{出射}$ ，进而可得出 $Radiance_{入射} = Radiance_{出射}$ （即 $L_O = Li$，进而得出 $f_r = \frac{1}{\pi}$ ）<ul><li><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-07 16.29.48.png" alt="截屏2023-05-07 16.29.48"><ul><li>定义albedo（反射率）来引入不同颜色的diffuse BRDF</li></ul></li></ul></li></ul><h2 id="Glossy-material-BRDF"><a href="#Glossy-material-BRDF" class="headerlink" title="Glossy material (BRDF)"></a>Glossy material (BRDF)</h2><p><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-07 16.36.33.png" alt="截屏2023-05-07 16.36.33"></p><h2 id="Ideal-reflective-refractive-material-BSDF"><a href="#Ideal-reflective-refractive-material-BSDF" class="headerlink" title="Ideal reflective / refractive material (BSDF*)"></a>Ideal reflective / refractive material (BSDF*)</h2><p>(BSDF，S表示散射)</p><p><strong>BSDF = BR(Reflect反射)DF + BT(Transmit折射)DF</strong></p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-07 16.39.11.png" alt="截屏2023-05-07 16.39.11"></p><ul><li><strong>计算镜面反射</strong>出射光 $w_o$：计算出 $\theta$ 和 $\phi$ 即可（方位角）<ul><li><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-07 16.45.43.png" alt="截屏2023-05-07 16.45.43" style="zoom:40%;"></li></ul></li></ul><h3 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h3><ul><li>折射（表现：色散、caustics）</li></ul><p><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-07 23.02.10.png" alt="截屏2023-05-07 23.02.10" style="zoom:40%;"></p><ul><li>caustics成因：光经海水表面折射，光线聚焦（渲染灾难）</li><li><p>Snell’s Law 斯内尔定律</p><ul><li><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-07 23.09.09.png" alt="截屏2023-05-07 23.09.09" style="zoom:40%;"></li><li>全反射发生条件：<img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-07 23.12.39.png" alt="截屏2023-05-07 23.12.39" style="zoom:40%;"></li></ul></li><li><p>Snell’s Window / Circle</p><ul><li><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-07 23.17.42.png" alt="截屏2023-05-07 23.17.42" style="zoom:40%;"></li></ul></li></ul><h3 id="Fresnel-Reflection-Term-菲涅尔项"><a href="#Fresnel-Reflection-Term-菲涅尔项" class="headerlink" title="Fresnel Reflection / Term 菲涅尔项"></a>Fresnel Reflection / Term 菲涅尔项</h3><p>（解释能量分别发生多少反射/折射）</p><p><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-07 23.39.21.png" alt="截屏2023-05-07 23.39.21"></p><ul><li><p>绝缘体</p><ul><li><p><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-07 23.39.33.png" alt="截屏2023-05-07 23.39.33" style="zoom:40%;"></p></li><li><p>上图</p><ul><li>红：菲涅尔效应</li><li>蓝、绿：光极化（偏振）</li></ul></li></ul></li><li><p>导体（折射率是复数）</p></li></ul><p><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-07 23.50.07.png" alt="截屏2023-05-07 23.50.07" style="zoom:40%;"></p><ul><li>计算菲涅尔项<ul><li><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-07 23.55.15.png" alt="截屏2023-05-07 23.55.15"></li></ul></li></ul><h2 id="Microfacet-Material-微表面模型"><a href="#Microfacet-Material-微表面模型" class="headerlink" title="Microfacet Material 微表面模型"></a>Microfacet Material 微表面模型</h2><p>Microfacet Material是基于物理的；被PBR所使用；可描述的材质很多</p><ul><li>如图：图中出现了一块完美的较光滑高光，而看不到地表的细节结构。说明从足够远处看，看不到表面的具体微小细节，只能观察到这些细节对光线作用后给表面带来的整体影响。<ul><li><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-08 00.08.14.png" alt="截屏2023-05-08 00.08.14"></li></ul></li><li>Microfacet Theory<ul><li>远看材质，近看几何</li><li><strong>每一个Microfacet都发生镜面反射，每一个Microfacet都有法线</strong></li><li><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-08 00.14.34.png" alt="截屏2023-05-08 00.14.34" style="zoom:40%;"></li></ul></li></ul><h3 id="Microfacet-BRDF"><a href="#Microfacet-BRDF" class="headerlink" title="Microfacet BRDF"></a>Microfacet BRDF</h3><ul><li><p>关键：微表面的法线分布</p><ul><li>通过微表面发现分布，来表示材质粗糙程度</li><li><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-08 00.17.18.png" alt="截屏2023-05-08 00.17.18" style="zoom:40%;"></li></ul></li><li><p><strong style="color:red;">Microfacet BRDF</strong></p><ul><li>$F(i, h)$：菲涅尔项，用于<strong>表示总共多少量被反射</strong></li><li>$D(h)$：法线分布，用于<strong>查询什么样的微表面才能将光线反射到某一特定方向</strong><ul><li>考虑half vector $h$ ，因为微表面发生镜面反射 </li></ul></li><li>$G(i,o,h)$：几何项，用于<strong>修护边界处因忽略遮挡导致的过亮 </strong>(决定性作用)<ul><li>考虑微表面间遮挡&amp;互相形成阴影，导致部分微表面失去作用</li><li>$i$ or $o$ 接近Grazing Angle(光几乎平行表面)时，易发生</li></ul></li><li><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-08 00.22.11.png" alt="截屏2023-05-08 00.22.11" style="zoom:40%;"></li></ul></li></ul><h2 id="Isotropic-Anisotropic-Materials-BRDFs"><a href="#Isotropic-Anisotropic-Materials-BRDFs" class="headerlink" title="Isotropic / Anisotropic Materials (BRDFs)"></a>Isotropic / Anisotropic Materials (BRDFs)</h2><p>各向同性/各向异性材质</p><p><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-08 12.21.20.png" alt="截屏2023-05-08 12.21.20" style="zoom:35%;"></p><ul><li>Isotropic vs. Anisotropic<ul><li>关键：微表面的方向性<ul><li>各向同性材质微表面方向性弱</li></ul></li><li><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-08 12.22.44.png" alt="截屏2023-05-08 12.22.44" style="zoom:40%;"></li></ul></li></ul><h3 id="Anisotropic-BRDFs"><a href="#Anisotropic-BRDFs" class="headerlink" title="Anisotropic BRDFs"></a>Anisotropic BRDFs</h3><ul><li>各向异性BRDF：不满足方位角旋转，受绝对方位角影响<ul><li><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-08 12.29.51.png" alt="截屏2023-05-08 12.29.51"></li></ul></li><li>例如：尼龙、天鹅绒</li></ul><h2 id="BRDF性质"><a href="#BRDF性质" class="headerlink" title="BRDF性质"></a>BRDF性质</h2><ul><li>非负<ul><li><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-08 12.39.38.png" alt="截屏2023-05-08 12.39.38" style="zoom:50%;"></li></ul></li><li>线性<ul><li><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-08 12.40.38.png" alt="截屏2023-05-08 12.40.38" style="zoom:50%;"></li></ul></li><li>可逆<ul><li><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-08 12.42.17.png" alt="截屏2023-05-08 12.42.17" style="zoom:50%;"></li></ul></li><li>能量守恒<ul><li><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-08 12.43.22.png" alt="截屏2023-05-08 12.43.22" style="zoom:50%;"></li></ul></li><li>各向同性/各向异性<ul><li>各向同性只用考虑方位角相对值</li><li><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-08 12.45.51.png" alt="截屏2023-05-08 12.45.51" style="zoom:50%;"></li></ul></li></ul><h2 id="Measuring-BRDFs-测量BRDF"><a href="#Measuring-BRDFs-测量BRDF" class="headerlink" title="Measuring BRDFs 测量BRDF"></a>Measuring BRDFs 测量BRDF</h2><p><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-08 12.59.23.png" alt="截屏2023-05-08 12.59.23" style="zoom:50%;"></p><ul><li>针对每一个入射、出射方向，都进行测量</li><li>实现方法：2D * 2D遍历<ul><li><img src="/2023/05/05/Games101/Games101-P17/截屏2023-05-08 13.00.09.png" alt="截屏2023-05-08 13.00.09" style="zoom:50%;"></li></ul></li><li>提升效率<ul><li>各向同性，减少一维 from <strong>4D to 3D</strong></li><li>可逆性 reduces # of measurements by <strong>half</strong></li><li>Clever optical systems…</li></ul></li><li>MERL BRDF Database：记录BRDF测量值的数据库</li></ul>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
            <tag> 材质 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P13-16 Ray Tracing</title>
      <link href="/2023/04/23/Games101/Games101-P13-16/"/>
      <url>/2023/04/23/Games101/Games101-P13-16/</url>
      
        <content type="html"><![CDATA[<ul><li>P13 Preview<ul><li>Recursive (Whitted-Style) Ray Tracing<ul><li>Ray-Surface Intersection 光线和面求交：球体、隐式表面、三角面，及缺点</li></ul></li><li>Accelerating Ray-Surface Intersection 加速<ul><li>Ray Intersection with Axis-Aligned Box</li></ul></li></ul></li><li><p>P14&amp;15 Preview</p><ul><li><p>Using AABBs to accelerate ray tracing</p><ul><li>Uniform grids</li><li>Spatial partitions 空间划分<ul><li>KD-Trees</li><li>BVHs<img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-26 23.54.20.png" alt="截屏2023-04-26 23.54.20" style="zoom: 33%;"></li></ul></li></ul></li><li><p>Basic radiometry</p><ul><li>Radiant Energy $Q$ and Flux(Power) $\Phi$</li><li>Intensity $I$：power <strong>per projected unit area</strong></li><li>Irradiance $E$：power <strong>per unit area</strong> </li><li>Radiance $L$：power <strong>per unit solid angle</strong> &amp; <strong>per projected unit area</strong><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 15.00.42.png" alt="截屏2023-05-03 15.00.42" style="zoom: 33%;"></li></ul></li></ul></li><li><p>BRDF：是针对一个方向，<strong style="color:red;">出射Radiance($dL_r(\omega_r)$)/入射Irradiance($dE(\omega _i)$)</strong>的<strong>比例</strong></p><ul><li><p>反射方程</p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 17.58.58.png" alt="截屏2023-05-03 17.58.58" style="zoom: 33%;"></li></ul></li><li><p>渲染方程</p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 18.29.34.png" alt="截屏2023-05-03 18.29.34" style="zoom:33%;"></li></ul></li></ul></li><li><p>概率论回顾</p></li></ul></li><li><p>P16 Overview</p><ul><li><p>Monte Carlo Integration</p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 20.45.43.png" alt="截屏2023-05-04 20.45.43" style="zoom: 25%;"></li></ul></li><li><p>Path Tracing</p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 22.05.41.png" alt="截屏2023-05-04 22.05.41" style="zoom:33%;"><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 23.35.12.png" alt="截屏2023-05-04 23.35.12" style="zoom:33%;"></li><li>PT 优化<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-05 21.41.12.png" alt="截屏2023-05-05 21.41.12" style="zoom:33%;"><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-05 22.30.26.png" alt="截屏2023-05-05 22.30.26" style="zoom:33%;"></li></ul></li></ul></li></ul></li></ul><span id="more"></span><h1 id="P13-Ray-Tracing-1"><a href="#P13-Ray-Tracing-1" class="headerlink" title="P13 Ray Tracing 1"></a>P13 Ray Tracing 1</h1><ul><li>Why ray tracing?<ul><li>光栅化渲染不能完美诠释global effects(下图都算global effect)<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-23 22.54.49.png" alt="截屏2023-04-23 22.54.49" style="zoom:50%;"></li></ul></li><li>光栅化速度快，可实现近似，但质量较低</li><li>光栅化是Real-time；光线追踪是Offline</li></ul></li><li>Features of ray-tracing<ul><li>accurate</li><li>slow </li></ul></li></ul><h2 id="Basic-Ray-Tracing-Algorithm"><a href="#Basic-Ray-Tracing-Algorithm" class="headerlink" title="Basic Ray-Tracing Algorithm"></a>Basic Ray-Tracing Algorithm</h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><ul><li>Light光线<ul><li>光线延直线传播（本课中）</li><li>光线相交时不会发生碰撞（本课中）</li><li>光线从光源发射出，经反射、折射后进入人眼</li></ul></li></ul><h3 id="Ray-Casting"><a href="#Ray-Casting" class="headerlink" title="Ray Casting"></a>Ray Casting</h3><p><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-23 23.15.03.png" alt="截屏2023-04-23 23.15.03" style="zoom:50%;"></p><ul><li>概述<ul><li>摄像机与屏幕像素连线，并穿透屏幕并打在红圈处</li><li>连接红圈和光源，判断红圈处点是否在阴影中</li><li>若不在阴影中，则该光线有效，可进行进一步计算该点处光的能量</li></ul></li></ul><h4 id="Generating-Eye-Rays"><a href="#Generating-Eye-Rays" class="headerlink" title="Generating Eye Rays"></a>Generating Eye Rays</h4><ul><li>Pinhole Camera Model 针孔相机模型<ul><li>Step1: 每一个像素的光线射入，与场景相交，求出最近交点<img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-23 23.23.10.png" alt="截屏2023-04-23 23.23.10" style="zoom: 40%;"><ul><li>对于光线和多个物体相交的情况：因遮挡，只考虑最近（直接避免光追中的深度测试）</li></ul></li><li>Step2: 交点与光源连线，若不在阴影中就计算着色<img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-23 23.25.16.png" alt="截屏2023-04-23 23.25.16" style="zoom:40%;"></li><li>Step3: 写入对应像素</li></ul></li></ul><h3 id="Recursive-Whitted-Style-Ray-Tracing"><a href="#Recursive-Whitted-Style-Ray-Tracing" class="headerlink" title="Recursive (Whitted-Style) Ray Tracing"></a>Recursive (Whitted-Style) Ray Tracing</h3><p><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-24 10.09.39.png" alt="截屏2023-04-24 10.09.39" style="zoom:33%;"></p><ul><li>对于透明物体，发生折射+反射<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-24 10.27.20.png" alt="截屏2023-04-24 10.27.20" style="zoom:50%;"></li><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-24 10.31.17.png" alt="截屏2023-04-24 10.31.17" style="zoom:50%;"></li></ul></li><li><p>过程</p><ul><li><p>生成眼睛到屏幕像素的primary ray</p></li><li><p>形成反射（镜面反射）or折射的多条secondary rays；若打到漫反射物体，反射/折射停止</p></li><li><p>作出shadow rays</p></li><li><p>若shadow rays未被物体遮挡，则计算对应红圈处的点的着色，相叠加，得出屏幕像素最终颜色</p></li></ul></li></ul><h4 id="Ray-Surface-Intersection-光线和面求交"><a href="#Ray-Surface-Intersection-光线和面求交" class="headerlink" title="Ray-Surface Intersection 光线和面求交"></a>Ray-Surface Intersection 光线和面求交</h4><h5 id="光线和球体求交"><a href="#光线和球体求交" class="headerlink" title="光线和球体求交"></a>光线和球体求交</h5><ul><li>光线：起点+方向<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-24 10.44.35.png" alt="截屏2023-04-24 10.44.35" style="zoom:33%;"></li></ul></li><li>联立方程求交点：<ul><li>光线：$r(t) = \boldsymbol o+t \boldsymbol d , (0 \leq t &lt; \infty)$</li><li>球：$\boldsymbol p: (\boldsymbol{p} -c)^2 - R^2 = 0$</li><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-24 13.30.30.png" alt="截屏2023-04-24 13.30.30" style="zoom:33%;"></li></ul></li></ul><h5 id="光线和隐式表面求交"><a href="#光线和隐式表面求交" class="headerlink" title="光线和隐式表面求交"></a>光线和隐式表面求交</h5><ul><li>将光线函数表示带入隐式表面公式<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-24 13.35.58.png" alt="截屏2023-04-24 13.35.58" style="zoom:33%;"></li></ul></li></ul><h5 id="与三角面求交"><a href="#与三角面求交" class="headerlink" title="与三角面求交"></a>与三角面求交</h5><p><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-24 13.49.32.png" alt="截屏2023-04-24 13.49.32"></p><ul><li>补：<strong>判断空间中任意点是否在（封闭）物体内</strong>：<ul><li>从该点向任意方向做一条光线，检测光线和该物体交点个数</li><li>若交点为奇数，则点在物体内；若交点为偶数，则点在物体外</li></ul></li><li><strong style="color:red;"><strong>光线与三角面求交计算过程</strong></strong><ul><li>光线和三角形所在面求交<ul><li>平面的定义：法向量$\boldsymbol N$+一个点$p’$</li><li>平面上的点$\boldsymbol p$和法线$\boldsymbol N$满足向量$\boldsymbol{p’p}\perp \boldsymbol N$，则点乘为0：<img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-25 19.23.25.png" alt="截屏2023-04-25 19.23.25"></li><li>联立光线&amp;平面方程求交：<img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-25 19.31.08.png" alt="截屏2023-04-25 19.31.08" style="zoom:33%;"></li></ul></li><li>判断交点在不在三角形内（叉乘）</li></ul></li><li>Möller Trumbore Algorithm：光线方程 = 重心坐标方程（可表示三角形平面内任意一点）<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-25 19.43.30.png" alt="截屏2023-04-25 19.43.30" style="zoom:33%;"></li></ul></li></ul><h5 id="缺点问题"><a href="#缺点问题" class="headerlink" title="缺点问题"></a>缺点问题</h5><ul><li>测试每一个三角形与光线的交点，找到最接近的交点（即最小t）</li><li>Naive algorithm = #pixels ⨉ # traingles，每一个像素都要遍历场景中所有三角面，慢</li></ul><h4 id="Accelerating-Ray-Surface-Intersection-加速"><a href="#Accelerating-Ray-Surface-Intersection-加速" class="headerlink" title="Accelerating Ray-Surface Intersection 加速"></a>Accelerating Ray-Surface Intersection 加速</h4><h5 id="Ray-Intersection-with-Axis-Aligned-Box"><a href="#Ray-Intersection-with-Axis-Aligned-Box" class="headerlink" title="Ray Intersection with Axis-Aligned Box"></a>Ray Intersection with Axis-Aligned Box</h5><ul><li>Bounding Volumes 包围体积(盒)<ul><li>思路：<strong style="color:red;">将复杂物体用简单物体包围，若光线不与包围盒相交，则肯定不会与物体相交</strong></li><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-25 20.00.10.png" alt="截屏2023-04-25 20.00.10" style="zoom:33%;"></li></ul></li><li>Axis-Aligned Bounding Box (AABB 轴对⻬包围盒)<ul><li>理解：三个对立面的交集<img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-25 20.03.53.png" alt="截屏2023-04-25 20.03.53" style="zoom:33%;"></li></ul></li><li><p><strong style="color:red;"><strong>光线与AABB求交</strong></strong></p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-25 20.13.40.png" alt="截屏2023-04-25 20.13.40" style="zoom:40%;"></li><li>Key Ideas <ul><li><strong style="color:red;">光线射入AABB：光线<strong>射入所有</strong>对立面</strong></li><li><strong style="color:red;">光线射出AABB：光线<strong>射出任意一个</strong>对立面</strong></li></ul></li><li>计算过程<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-25 20.23.43.png" alt="截屏2023-04-25 20.23.43" style="zoom:50%;"></li><li>有交点，当且仅当$t_{enter} &lt; t_{exit}$ &amp;&amp; $t_{exit} &gt;= 0$</li><li>若$t$为负<ul><li>$t_{exit} &lt; 0$：AABB在光线反方向，没有交点</li><li>$t_{enter} &lt; 0$ &amp;&amp; $t_{exit} &gt;= 0$：光线起点在AABB里</li></ul></li></ul></li></ul></li><li><p>Why Axis-Aligned? - 计算简单</p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-25 20.33.35.png" alt="截屏2023-04-25 20.33.35" style="zoom:50%;"></li></ul></li></ul><h1 id="P14-amp-15-Ray-Tracing-2-amp-3-Acceleration-amp-Radiometry-amp-BDRF-amp-Probability"><a href="#P14-amp-15-Ray-Tracing-2-amp-3-Acceleration-amp-Radiometry-amp-BDRF-amp-Probability" class="headerlink" title="P14&amp;15 Ray Tracing 2&amp;3 (Acceleration &amp; Radiometry &amp; BDRF &amp; Probability)"></a>P14&amp;15 Ray Tracing 2&amp;3 (Acceleration &amp; Radiometry &amp; BDRF &amp; Probability)</h1><h2 id="Using-AABBs-to-accelerate-ray-tracing"><a href="#Using-AABBs-to-accelerate-ray-tracing" class="headerlink" title="Using AABBs to accelerate ray tracing"></a>Using AABBs to accelerate ray tracing</h2><h3 id="Uniform-Spatial-Partitions-Grids"><a href="#Uniform-Spatial-Partitions-Grids" class="headerlink" title="Uniform Spatial Partitions (Grids)"></a>Uniform Spatial Partitions (Grids)</h3><ul><li><p>思路：将光线与物体求交换为光线与盒子求交</p></li><li><p>场景预处理</p><ul><li><p><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-25 22.18.54.png" alt="截屏2023-04-25 22.18.54" style="zoom:50%;"></p></li><li><p>进行<strong>光线追踪</strong><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-25 22.24.21.png" alt="截屏2023-04-25 22.24.21" style="zoom:50%;"></p></li><li><p>效率问题：寻找合适的格子数<img src="/2023/04/23/Games101/Games101-P13-16/pinjie01.jpg" alt="pinjie01"></p><p><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-25 22.33.59.png" alt="截屏2023-04-25 22.33.59" style="zoom:40%;"></p></li></ul></li><li><p>Grid可以很好地处理在大小和空间上均匀分布的大量对象集合，但是（<strong>问题</strong>）</p><ul><li>不适用于物体分布不均的场景，会存在“Teapot in a stadium” problem。为检测小物体则需要密集的格子，浪费性能</li></ul></li></ul><h3 id="Spatial-Partitions-空间划分-光线追踪前"><a href="#Spatial-Partitions-空间划分-光线追踪前" class="headerlink" title="Spatial Partitions 空间划分(光线追踪前)"></a>Spatial Partitions 空间划分(光线追踪前)</h3><ul><li>解决物体分布不均导致的格子需求不同的问题</li><li>Spatial Partitioning Examples<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-25 22.58.33.png" alt="截屏2023-04-25 22.58.33" style="zoom:50%;"></li></ul></li></ul><h4 id="KD-Trees"><a href="#KD-Trees" class="headerlink" title="KD-Trees"></a>KD-Trees</h4><p>（加速构造都在光追前进行）</p><ul><li><p>预处理：对空间进行划分，每个子空间每次只划分一次，横竖交替（1、2、3的划分在下图中省略）</p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-26 22.50.02.png" alt="截屏2023-04-26 22.50.02" style="zoom:50%;"></li><li>停止划分：划分出区域与光线无交点</li></ul></li><li><p>KD-Trees的数据结构</p><ul><li>Internal nodes<ul><li>划分轴：x、y（三维还有z轴）</li><li>分割的位置：平面上沿轴，具体规则还需计算</li><li>子节点的指针</li><li>不存储objects（与grid相交的三角形）</li></ul></li><li>Leaf nodes：存储objects</li></ul></li><li><p>计算过程（思路：判断光线是否与格子有交点，若无，则无后续操作；若有，则光线可能与其子节点有交点，继续划分，直到打到叶子节点，若有交点，再与叶子节点中所有三角面求交）</p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/IMG_2989.JPG" alt="IMG_2989"></li><li>Step1：判断光线与包围盒A相交，需对A划分</li><li>STEP2：针对划分后A。判断光线与叶子节点1相交（这里把1、2、3看成叶子节点），则光线与1中所有object求交；判断光线与B相交，需对B划分</li><li>STEP3：针对划分后B。判断光线与叶子节点2相交，则光线与2中所有object求交；判断光线与C相交，需对C划分</li><li><strong style="color:blue;">STEP4：针对划分后C。判断光线与叶子节点3相交，则光线与3中所有object求交，这里有交点，记录$t_{hit}$；判断光线与D相交，需对D划分。</strong></li><li>……</li><li>（判断光线与5无相交，则无须再求交并划</li></ul></li><li>缺点<ul><li>预处理阶段，三角面与网格求交难。如三维网格题穿过三角面内部，计算结果却为无交点</li><li>同一个object可存储在多个叶子节点中（？）</li></ul></li><li>补：KD-Trees缺点难解决，不怎么用了</li></ul><h4 id="Bounding-Volume-Hierarchy-BVH"><a href="#Bounding-Volume-Hierarchy-BVH" class="headerlink" title="Bounding Volume Hierarchy (BVH)"></a>Bounding Volume Hierarchy (BVH)</h4><p>（Kind of Object Partitions 一种物体划分，计算简单且效率高，应用更广泛）</p><ul><li><p>思路</p><ul><li>将空间中三角形分成两部分，并重计算包围盒</li><li>继续进行两部分的划分，停止条件根据规定or自设</li></ul></li><li><p>特征</p><ul><li>优点：解决KD-Trees缺点，一个object只会出现在一个格子里</li><li>缺点：包围盒有相交，存在空间冗余</li></ul></li><li><p>过程</p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-26 23.54.20.png" alt="截屏2023-04-26 23.54.20" style="zoom:50%;"></li><li>计算包围盒</li><li>递归地，将一个包围盒分成两部分，并同步将其内部objects也分成两部分</li><li>重新计算两部分的包围盒</li><li>Stop when necessary</li><li>实际物体记录在叶子节点，其他节点只用于做加速结构的划分判断</li></ul></li><li><p>如何划分</p><ul><li>xyz选择一个维度</li><li>技巧<ol><li>选择最长的axis进行划分</li><li>选择中间位置的object进行划分，确保两部分object数量接近平衡（快速排序，补数据结构）</li></ol></li><li>stop when node contains few elements</li></ul></li><li><p>BVHs的数据结构</p><ul><li>Internal nodes store<ul><li>Bounding box</li><li>子节点的指针，不存储objects</li></ul></li><li>Leaf nodes store<ul><li>Bounding box</li><li>List of objects</li></ul></li></ul></li><li><p><strong style="color:red;">计算光线与BVH相交的过程</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Intersect(Ray ray, BVH node)&#123;if (ray misses node.bbox) return;    if (node is a leaf node)     test intersection with all objs;     return closest intersection;    &#x2F;&#x2F; 递归hit1 &#x3D; Intersect(ray, node.child1);   hit2 &#x3D; Intersect(ray, node.child2);    return the closer of hit1, hit2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-27 13.26.58.png" alt="截屏2023-04-27 13.26.58" style="zoom:50%;"></li></ul><ul><li><p>Spatial vs Object Partitions</p><ul><li>Spatial partition (e.g.KD-tree)<img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-27 13.37.58.png" alt="截屏2023-04-27 13.37.58" style="zoom: 33%;"><ul><li>划分区域在空间上不相交</li><li>一个object可能被划分进多个子节点</li></ul></li><li>Object partition (e.g. BVH)<img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-27 13.38.25.png" alt="截屏2023-04-27 13.38.25" style="zoom:33%;"><ul><li>Bounding box在空间上可能重叠</li><li>object不会出现在多个包围盒中，也不用计算object和包围盒如何相交</li></ul></li></ul></li></ul><h2 id="Basic-radiometry-辐射度量学"><a href="#Basic-radiometry-辐射度量学" class="headerlink" title="Basic radiometry 辐射度量学"></a>Basic radiometry 辐射度量学</h2><p>（Whitted style ray tracing 并不是真实的基于物理的结果，引入了大量的完美假设，同时有很多错误的估计。而辐射度量学是精确的定义光线与物体的交互，进行真实的物理模拟。）</p><h3 id="Radiometry"><a href="#Radiometry" class="headerlink" title="Radiometry"></a>Radiometry</h3><p>新的概念：Radiant flux(power) 辐射通量 / intensity强度 / irradiance照度 / radiance</p><h4 id="Radiant-Energy-Q-and-Flux-Power-Phi"><a href="#Radiant-Energy-Q-and-Flux-Power-Phi" class="headerlink" title="Radiant Energy $Q$ and Flux(Power) $\Phi$"></a>Radiant Energy $Q$ and Flux(Power) $\Phi$</h4><ul><li>Radiant energy $Q$：辐射能，是电磁辐射的能量，辐射通量对时间的积分。单位 $J$ 焦耳</li><li><p>Radiant flux(power)：辐射通量or功率，是单位时间内释放、反射、投射或吸收的能量，简单理解可认为该值说明一个光源有多亮。单位流明$lm$ / 瓦特$W$。计算公式：$\Phi = \frac{dQ}{dt}$</p></li><li><p>Important Light Measurements of Interest</p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-27 22.35.43.png" alt="截屏2023-04-27 22.35.43"></li></ul></li></ul><h4 id="Intensity-I"><a href="#Intensity-I" class="headerlink" title="Intensity $I$"></a>Intensity $I$</h4><ul><li>Intensity：辐射强度，单位立体角所包含的辐射通量/功率(针对立体角的方向上)。单位是 $cd$ 坎德拉<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-27 22.44.55.png" alt="截屏2023-04-27 22.44.55" style="zoom:50%;"></li></ul></li></ul><h5 id="Angles-and-Solid-Angles-立体角"><a href="#Angles-and-Solid-Angles-立体角" class="headerlink" title="Angles and Solid Angles 立体角"></a>Angles and Solid Angles 立体角</h5><ul><li>单位立体角定义：在半径 $r$ 的球面上面积为 $r^2$ 的面元对球心的张角为 $1sr$ ，因为球面的面积是 $4 \pi r^2$ ，所以整个球面的立体角为 $4\pi sr$</li><li>立体角<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-27 22.52.20.png" alt="截屏2023-04-27 22.52.20" style="zoom: 33%;"></li><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-27 22.59.36.png" alt="截屏2023-04-27 22.59.36" style="zoom:33%;"></li><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-27 23.01.32.png" alt="截屏2023-04-27 23.01.32" style="zoom:33%;"></li></ul></li><li>辐射度量学中， $\omega$ 通常被用来表示三维空间中方向，由 $\theta$ 和 $\phi$ 来表示具体方向，并可进一步计算出单位立体角<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-27 23.09.39.png" alt="截屏2023-04-27 23.09.39" style="zoom:33%;"></li></ul></li><li>若空间中点光源，向四周均匀辐射能量，则辐射强度 $I$ 计算如下<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-04-27 23.14.44.png" alt="截屏2023-04-27 23.14.44" style="zoom:33%;"></li></ul></li></ul><h4 id="Irradiance-E"><a href="#Irradiance-E" class="headerlink" title="Irradiance $E$"></a>Irradiance $E$</h4><ul><li>Irradiance：辐照度，power <strong>per unit area</strong> incident on a surface point，单位面积上的功率<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 14.32.38.png" alt="截屏2023-05-03 14.32.38" style="zoom:50%;"></li><li>入射光需垂直于面，否则需进行投影</li></ul></li></ul><h5 id="重新理解-Lambert’s-Cosine-Law"><a href="#重新理解-Lambert’s-Cosine-Law" class="headerlink" title="重新理解 Lambert’s Cosine Law"></a>重新理解 Lambert’s Cosine Law</h5><ul><li>表面处的辐照度，与光方向和表面法线之间的夹角的余弦值成正比<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 14.38.40.png" alt="截屏2023-05-03 14.38.40" style="zoom:50%;"></li></ul></li></ul><h5 id="重新理解-Irradiance-Falloff"><a href="#重新理解-Irradiance-Falloff" class="headerlink" title="重新理解 Irradiance Falloff"></a>重新理解 Irradiance Falloff</h5><ul><li>在Blin-Phong模型中用到的光线强度随 r2 的衰减的正确理解：光线在传播过程中，irradiance衰减(面积增加)，intensity不变(立体角没变)</li></ul><p><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 14.42.41.png" alt="截屏2023-05-03 14.42.41" style="zoom:50%;"></p><h4 id="Radiance-L"><a href="#Radiance-L" class="headerlink" title="Radiance $L$"></a>Radiance $L$</h4><p><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 14.58.07.png" alt="截屏2023-05-03 14.58.07" style="zoom:50%;"></p><ul><li>为了描述光线在传播过程中能量的度量</li><li>Radiance：power，在单位角<strong>per unit solid angle</strong>，单位投影面积上<strong>per projected unit area</strong>，上发射、反射、投射、接受的量<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 15.00.42.png" alt="截屏2023-05-03 15.00.42" style="zoom:50%;"></li></ul></li></ul><h4 id="对比Irradiance、Intensity、Radiance"><a href="#对比Irradiance、Intensity、Radiance" class="headerlink" title="对比Irradiance、Intensity、Radiance"></a>对比Irradiance、Intensity、Radiance</h4><p><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 15.05.15.png" alt="截屏2023-05-03 15.05.15" style="zoom:50%;"></p><ul><li>Incident Radiance 入射<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 17.22.59.png" alt="截屏2023-05-03 17.22.59" style="zoom:50%;"></li><li>Incident radiance is the irradiance per unit solid angle arriving at the surface</li><li>是沿着给定光线（表面点和入射方向）到达表面的光</li></ul></li><li>Exiting Radiance<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 17.25.47.png" alt="截屏2023-05-03 17.25.47" style="zoom:50%;"></li><li>Exiting surface radiance is the intensity per unit projected area leaving the surface.</li><li>对于区域光，它是沿给定光线（表面上的点和出口方向）发射的光</li></ul></li><li>Irradiance vs. Radiance<ul><li>Irradiance $E$ ：$dA$ 收到的所能量</li><li>Radiance $L$ ：针对Irradiance作出特定方向立体角 $d\omega$ 的限制</li><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 17.31.40.png" alt="截屏2023-05-03 17.31.40" style="zoom:50%;"></li></ul></li></ul><h2 id="BRDF-Bidirectional-Reflectance-Distribution-Function-双向反射分布函数"><a href="#BRDF-Bidirectional-Reflectance-Distribution-Function-双向反射分布函数" class="headerlink" title="BRDF (Bidirectional Reflectance Distribution Function 双向反射分布函数)"></a>BRDF (Bidirectional Reflectance Distribution Function 双向反射分布函数)</h2><p>定义一个函数描述不同表面的反射特性——从某个方向入射的光线，反射到另一个特定方向上的能量是多少</p><ul><li>Reflection at a Point<ul><li>来自direction $\omega _i$方向的Radiance变成了 $dA$ 吸收的power $E$ ；而后power $E$ 变成了向 direction $\omega$ 的辐射的Radiance</li><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 17.47.01.png" alt="截屏2023-05-03 17.47.01"><h3 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h3></li><li>是针对一个方向，<strong style="color:red;">出射Radiance($dL_r(\omega_r)$)/入射Irradiance($dE(\omega _i)$)</strong>的<strong>比例</strong>。作用是将接收到的 $dE(\omega _i)$ <strong>分配</strong>到不同的立体角</li><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 17.58.58.png" alt="截屏2023-05-03 17.58.58" style="zoom: 40%;"></li><li>用于定义不同材质</li></ul></li></ul><h3 id="Reflection-Equation-反射方程"><a href="#Reflection-Equation-反射方程" class="headerlink" title="Reflection Equation 反射方程"></a>Reflection Equation 反射方程</h3><ul><li>考虑任何一个方向的入射光，对观察点反射光的贡献，叠加所有方向光的贡献，得到该点最终渲染效果</li><li>对每个方向的入射irradiance $dE(\omega _i)$ （也就是 $L_i(p,\omega_i)cos\theta_i d\omega_i$ ）都乘BRDF，而后对方向积分，得到出射Radiance $L_r(p,\omega_r)$ ，进而得出最终的观察结果<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 18.07.18.png" alt="截屏2023-05-03 18.07.18" style="zoom:40%;"></li></ul></li><li>Challenge: Recursive Equation 递归方程<ul><li>入射的Irradiance不只来自光源，也来自其他物体的反射（递归）</li><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 18.26.00.png" alt="截屏2023-05-03 18.26.00" style="zoom:50%;"></li></ul></li></ul><h3 id="Rendering-Equation-渲染方程"><a href="#Rendering-Equation-渲染方程" class="headerlink" title="Rendering Equation 渲染方程"></a>Rendering Equation 渲染方程</h3><h4 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h4><ul><li>上述Reflection Equation忽略了自发光，Rendering Equation添加了自发光项，可用于所有类型的光线传播</li></ul><p><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 18.29.34.png" alt="截屏2023-05-03 18.29.34" style="zoom:40%;"></p><h4 id="理解渲染方程"><a href="#理解渲染方程" class="headerlink" title="理解渲染方程"></a>理解渲染方程</h4><ul><li><p>一个方向的光$\rightarrow$多个方向的光：累加</p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/IMG_3131.JPG" alt="IMG_3131"></li></ul></li><li><p>引入面光源：积分面光源所占的立体角</p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 20.57.57.png" alt="截屏2023-05-03 20.57.57" style="zoom:50%;"></li></ul></li></ul><h4 id="渲染方程的递归简化求解"><a href="#渲染方程的递归简化求解" class="headerlink" title="渲染方程的递归简化求解"></a>渲染方程的递归简化求解</h4><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 21.01.10.png" alt="截屏2023-05-03 21.01.10"><ul><li>未知量：入射&amp;出射Radiance</li></ul></li><li>渲染方程的简化<ul><li>用 $l$ 表示不同位置辐射的Radiance，$u \&amp; v$ 表示不同位置，简化为线性积分<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 21.10.29.png" alt="截屏2023-05-03 21.10.29" style="zoom:40%;"></li></ul></li><li>线性积分进一步简化<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 21.12.55.png" alt="截屏2023-05-03 21.12.55" style="zoom:40%;"></li><li>简化为了求解渲染方程，即求解 $L$</li><li>$K$ 为反射算子，是矩阵形式</li></ul></li></ul></li><li><p>求解渲染方程</p><ul><li>其中 $I$ 为identity单位矩阵</li><li>通过一些类似泰勒展开的操作进行近似 $(1+x)^\alpha = 1+\alpha x + \frac{\alpha(\alpha -1)}{2!}x^2+\frac{\alpha(\alpha -1)(\alpha -2)}{3!}x^3+…$ （矩阵居然也可以！？？！）<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 21.30.51.png" alt="截屏2023-05-03 21.30.51" style="zoom:40%;"></li></ul></li><li>得到了！<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-03 21.32.50.png" alt="截屏2023-05-03 21.32.50" style="zoom:40%;"></li><li>所有光线弹射（直接+所有间接）相加，得到全局光照（Global illumination，GI）</li><li>注：光栅化一般只能做到直接光照；间接光照光追容易做</li></ul></li></ul></li><li><p>对比</p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/IMG_3138.JPG" alt="IMG_3138"></li><li>关于Two - bounce上方的灯为什么是黑色：从摄影机出发的光线，经过两次弹射还无法从灯中射出（两次弹射进入一个玻璃层，再经过两次弹射方可从另一玻璃层射出）</li><li>假设可以做无限次光线弹射：亮度收敛到最大值，不会无限增大（泰勒无限展开，无限逼近）</li></ul></li><li><p>路径追踪是解渲染方程的一种方式</p></li></ul><h2 id="概率论回顾-Probability-Review"><a href="#概率论回顾-Probability-Review" class="headerlink" title="概率论回顾 Probability Review"></a>概率论回顾 Probability Review</h2><p>苍天啊！！！！！！！！</p><ul><li>Random Variables 随机变量<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 15.52.54.png" alt="截屏2023-05-04 15.52.54"></li></ul></li><li>Probabilities<ul><li>$n$ 中情况：$x_i$</li><li>with probability：$p_i$</li><li>满足<ul><li>$p_i\geq 0$</li><li>$\sum_{i=1}^n p_i = 1$</li></ul></li></ul></li><li>Expected Value of a Random Variable 期望<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 16.05.53.png" alt="截屏2023-05-04 16.05.53"></li></ul></li><li>Continuous Case 连续情况下描述变量和分布<ul><li>概率密度函数 <strong style="color:red;">Probability Distribution Function (PDF)</strong><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 16.08.02.png" alt="截屏2023-05-04 16.08.02"></li></ul></li></ul></li><li>Function of a Random Variable 随机变量的函数<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 16.12.38.png" alt="截屏2023-05-04 16.12.38"></li></ul></li></ul><h1 id="P16-Ray-Tracing4-Monte-Carlo-Integration-amp-Path-Tracing"><a href="#P16-Ray-Tracing4-Monte-Carlo-Integration-amp-Path-Tracing" class="headerlink" title="P16 Ray Tracing4 (Monte Carlo Integration &amp; Path Tracing)"></a>P16 Ray Tracing4 (Monte Carlo Integration &amp; <strong style="color:red;">Path Tracing</strong>)</h1><h2 id="Monte-Carlo-Integration-蒙特卡洛积分"><a href="#Monte-Carlo-Integration-蒙特卡洛积分" class="headerlink" title="Monte Carlo Integration 蒙特卡洛积分"></a>Monte Carlo Integration 蒙特卡洛积分</h2><ul><li>如何使用：在积分域内，对样本不断随机采样，做平均，<strong>近似函数积分数值</strong><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 16.48.25.png" alt="截屏2023-05-04 16.48.25" style="zoom: 33%;"></li><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 17.16.16.png" alt="截屏2023-05-04 17.16.16" style="zoom:33%;"></li></ul></li><li><strong>特例情况：均与采样</strong>（a~b间均匀采样，则采样PDF为常函数）<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 20.38.54.png" alt="截屏2023-05-04 20.38.54"></li><li>上图已求解出了 $p(x)$ ，带入 $F_N$ <img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 20.41.54.png" alt="截屏2023-05-04 20.41.54"></li></ul></li><li><strong>通用情况：非均匀采样</strong>（PDF不为常函数）<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 20.45.43.png" alt="截屏2023-05-04 20.45.43"></li><li>注意<ul><li>样本越多，近似越准确</li><li>在 $x$ 积分，则对应在 $x$ 采样</li><li>除以 $p(X_i)$ 相当于为非均匀的采样加权（上述均匀采样权重相同，因此 $p(X_i)$ 就是常数）</li></ul></li></ul></li></ul><h2 id="Path-Tracing-路径追踪"><a href="#Path-Tracing-路径追踪" class="headerlink" title="Path Tracing 路径追踪"></a>Path Tracing 路径追踪</h2><h3 id="对比-Whitted-style-ray-tracing"><a href="#对比-Whitted-style-ray-tracing" class="headerlink" title="对比 Whitted-style ray tracing"></a>对比 Whitted-style ray tracing</h3><ul><li>回顾 Whitted-style ray tracing<ul><li>始终执行镜面反射/折射</li><li>在漫反射表面上停止反射</li></ul></li><li><strong>BUT!!!</strong> Whitted-style ray tracing is <strong>not totally based on physics</strong>, which needs to be improved!!!</li><li>Problems of Whitted-style ray tracing<ul><li>只可以镜面反射or折射——无法表现glossy reflection<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 21.09.26.png" alt="截屏2023-05-04 21.09.26"></li></ul></li><li>遇到漫反射物体，光线停止传播——忽略了漫反射物体间的光线传播(1)；无法表现Color Bleeding(2)<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 21.12.26.png" alt="截屏2023-05-04 21.12.26"></li></ul></li></ul></li><li>But!!! The <strong>rendering equation is correct</strong>!!!<ul><li>需要求出光照，则需求解渲染方程<img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 21.31.43.png" alt="截屏2023-05-04 21.31.43" style="zoom:50%;"></li><li>需要解决<ul><li>STEP1: 半球域内的定积分——蒙特卡洛积分</li><li>STEP2: 递归</li></ul></li></ul></li></ul><h3 id="A-Simple-Monte-Carlo-Solution-to-solve-the-rendering-equation"><a href="#A-Simple-Monte-Carlo-Solution-to-solve-the-rendering-equation" class="headerlink" title="A Simple Monte Carlo Solution(to solve the rendering equation)"></a>A Simple Monte Carlo Solution(to solve the rendering equation)</h3><ul><li>假设一种简单情况，即只渲染如图所示一个point<strong>的直接光照</strong><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 21.50.55.png" alt="截屏2023-05-04 21.50.55"></li></ul></li><li>直接光照条件下，$L_i$ 只可能来自光源</li><li>利用蒙特卡洛积分（暂且忽略渲染方程的自发光项）<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 22.01.09.png" alt="截屏2023-05-04 22.01.09"></li><li>$f(X_k)$ ：积分内函数整体</li><li>PDF：假设对半球进行平均的采样，则 $p(X_k)$ 为常数 $1/2\pi$</li></ul></li><li><p>将渲染方程写成蒙特卡洛积分后形式</p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 22.05.41.png" alt="截屏2023-05-04 22.05.41"></li><li>意义：得出一种正确的直接光照算法，可以算出着色点point出射的Radiance</li></ul></li><li><p><strong>只考虑直接光照的</strong>，<strong>path tracing</strong>的，$shade(p,wo)$ 伪代码</p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 23.13.00.png" alt="截屏2023-05-04 23.13.00"></li></ul></li></ul><h3 id="Global-Illumination-引入递归"><a href="#Global-Illumination-引入递归" class="headerlink" title="Global Illumination (引入递归)"></a>Global Illumination (引入递归)</h3><p><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 22.27.06.png" alt="截屏2023-05-04 22.27.06" style="zoom:40%;"></p><ul><li>$shade(p,wo)$ 伪代码<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 23.13.29.png" alt="截屏2023-05-04 23.13.29"></li></ul></li></ul><h4 id="Problems-amp-Solving-Problems-Ray-Generation-amp-Russian-Roulette"><a href="#Problems-amp-Solving-Problems-Ray-Generation-amp-Russian-Roulette" class="headerlink" title="Problems &amp; Solving Problems(Ray Generation &amp; Russian Roulette)"></a>Problems &amp; Solving Problems(Ray Generation &amp; Russian Roulette)</h4><ul><li><p>上述解决方法的问题</p><ul><li>Problem1: Explosion of #rays as #bounces go up （N为反射打出的光线数）<img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 22.32.52.png" alt="截屏2023-05-04 22.32.52" style="zoom:40%;"><ul><li>解决explosion的方法：N = 1（Path Tracing就是N=1时做蒙特卡洛积分）</li><li>$shade(p,wo)$ 伪代码<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 23.13.51.png" alt="截屏2023-05-04 23.13.51"></li></ul></li><li>N = 1会引起Noise，不过可以对一个像素trace more paths并求平均进行解决<ul><li>引入<a href="#lable">Ray Generation</a><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 22.46.32.png" alt="截屏2023-05-04 22.46.32" style="zoom: 40%;"></li></ul></li></ul></li><li>Problem2: 递归无法停止<ul><li>真实世界光线无限弹射</li><li>减少弹射次数 == 能量损失，因此不能强制终止</li><li>解决方法：引入<a href="#lable">Russian Roulette (RR)</a>俄罗斯轮盘赌——一定的概率停止继续追踪</li></ul></li></ul></li><li><p><span id="lable">Ray Generation</span>: 相机如何产生光线路径</p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 23.14.14.png" alt="截屏2023-05-04 23.14.14"></li></ul></li><li><span id="lable">Russian Roulette (RR)</span>俄罗斯轮盘赌<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 23.17.18.png" alt="截屏2023-05-04 23.17.18" style="zoom:40%;"></li><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 23.19.12.png" alt="截屏2023-05-04 23.19.12" style="zoom:40%;"><ul><li>通过计算期望 $E$，最后虽然有Noise，但结果 $L_o$ 一定正确</li></ul></li><li>$shade(p,wo)$ 伪代码<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 23.35.12.png" alt="截屏2023-05-04 23.35.12"></li></ul></li></ul></li></ul><h4 id="Path-Tracing-优化"><a href="#Path-Tracing-优化" class="headerlink" title="Path Tracing 优化"></a>Path Tracing 优化</h4><ul><li><p>SPP (samples per pixel) </p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-04 23.41.57.png" alt="截屏2023-05-04 23.41.57"></li><li>目的：提升Low SPP下效率</li></ul></li><li><p>效率低的原因：光源小、PDF为常数（均匀采样）时，假设每50000根光线才有1根达到光源，许多光线被浪费</p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-05 21.26.38.png" alt="截屏2023-05-05 21.26.38"></li></ul></li><li><p><strong style="color:red;">优化思路：Sampling the light</strong>（针对伪代码中“hit the light”的判断）</p><ul><li>采样的光路全分布在光源表面；对渲染方程的积分换元（改变积分域），从 $d\omega$ 换成光源面积 $dA$，<strong>PDF = 1/A</strong></li><li>注⚠️：该方法不好算点光源，建议将点光源换成小面光<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-05 21.37.21.png" alt="截屏2023-05-05 21.37.21"></li></ul></li><li>找到 $d\omega$ 和 $dA$ 的关系，并重写渲染方程<ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-05 21.41.12.png" alt="截屏2023-05-05 21.41.12"></li></ul></li></ul></li><li><p>进一步改进 $shade(p, wo)$ 伪代码</p><ul><li><p>将光源分成直接光照 &amp; 间接光照，分开计算（此处未考虑<a href="#lable">遮挡</a>）</p><ul><li><strong style="color:orange;">light source</strong> (direct直接光照, no need to have RR)</li><li><strong style="color:blue;">other reflectors</strong> (indirect间接光照, RR)<img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-05 22.02.39.png" alt="截屏2023-05-05 22.02.39" style="zoom:33%;"></li></ul></li><li><pre><code class="lang-c++">shade(p, wo)    // Contribution from the light source. 直接光照    Uniformly sample the light at x’ (pdf_light = 1 / A)    L_dir = L_i * f_r * cos θ * cos θ’ / |x’ - p|^2 / pdf_light //优化重写后的渲染方程    // Contribution from other reflectors. 间接光照    L_indir = 0.0    Test Russian Roulette with probability P_RR // 引入俄罗斯轮盘赌    Uniformly sample the hemisphere toward wi (pdf_hemi = 1 / 2pi)       Trace a ray r(p, wi)    If ray r hit a non-emitting object at q // 判断q需不为光源，才可以算进L_indir            L_indir = shade(q, -wi) * f_r * cos θ / pdf_hemi / P_RR       Return L_dir + L_indir</code></pre></li><li><p>若光源到 $p$ 有<span id="lable">遮挡</span>：作出 $x’$ 到 $p$ 线，判断直接光照有无遮挡</p><ul><li><img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-05 22.18.34.png" alt="截屏2023-05-05 22.18.34" style="zoom:40%;"></li></ul></li></ul></li><li><p>PATH TRACING is AWESOME</p><ul><li>PT vs. Photo <img src="/2023/04/23/Games101/Games101-P13-16/截屏2023-05-05 22.25.03.png" alt="截屏2023-05-05 22.25.03"></li><li>The Cornell box — <a href="http://www.graphics.cornell.edu/online/box/compare.html">http://www.graphics.cornell.edu/online/box/compare.html</a></li></ul></li><li><p>Further</p></li></ul><p><img src="/2023/04/23/Games101/Games101-P13-16/IMG_3262.JPG" alt="IMG_3262" style="zoom:40%;"></p>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
            <tag> 光线追踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P10-12 Geometry</title>
      <link href="/2023/04/15/Games101/Games101-P10-12/"/>
      <url>/2023/04/15/Games101/Games101-P10-12/</url>
      
        <content type="html"><![CDATA[<ul><li>P10&amp;11 Preview<ul><li>Introduce to geometry<ul><li>Examples of geometry</li><li>Various representations of geometry<ul><li>Implicit</li><li>Explicit</li></ul></li></ul></li></ul></li><li><p>P11 Preview</p><ul><li><p>Curves</p><ul><li>Bézier Curves</li><li>De Casteljau’s algorithm</li><li>B-splines, etc.</li></ul></li><li><p>Surfaces</p><ul><li>Bezier surfaces</li><li>Triangles &amp; quads<ul><li>Subdivision, simplification, regularization</li></ul></li></ul></li></ul></li><li><p>P12 Preview</p><ul><li>Mesh Subdivision (upsampling)</li><li>Mesh Simplification (downsampling)</li><li>Mesh Regularization (same #triangles)</li></ul></li></ul><span id="more"></span><h1 id="P10-amp-11-Geometry-Implicit-amp-Explicit"><a href="#P10-amp-11-Geometry-Implicit-amp-Explicit" class="headerlink" title="P10&amp;11 Geometry (Implicit&amp;Explicit)"></a>P10&amp;11 Geometry (Implicit&amp;Explicit)</h1><ul><li>难点：存储；渲染</li><li>过于精细不适宜三角面表示</li></ul><h2 id="几何的表示形式"><a href="#几何的表示形式" class="headerlink" title="几何的表示形式"></a>几何的表示形式</h2><p><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 13.29.06.png" alt="截屏2023-04-15 13.29.06" style="zoom:33%;"></p><h3 id="几何的隐式-Implicit-表示"><a href="#几何的隐式-Implicit-表示" class="headerlink" title="几何的隐式(Implicit)表示"></a>几何的隐式(Implicit)表示</h3><h4 id="Intro-隐式函数"><a href="#Intro-隐式函数" class="headerlink" title="Intro - 隐式函数"></a>Intro - 隐式函数</h4><ul><li>已知几何的点满足一定关系，未知点的具体位置<ul><li>eg：三维空间中单位球 $x^2+y^2+z^2=1$</li><li>通用：$f(x,y,z) = 0$</li><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 13.34.32.png" alt="截屏2023-04-15 13.34.32" style="zoom:40%;"></li></ul></li><li>缺点：采样难，所表现的形状不直观<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 13.37.00.png" alt="截屏2023-04-15 13.37.00" style="zoom:33%;"></li></ul></li><li>优点：便于检测点是否在物体表面上/内/外<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 13.37.52.png" alt="截屏2023-04-15 13.37.52" style="zoom:33%;"></li></ul></li></ul><h4 id="Algebraic-Surfaces"><a href="#Algebraic-Surfaces" class="headerlink" title="Algebraic Surfaces"></a>Algebraic Surfaces</h4><ul><li>可表述参数化模型，而无法表述复杂的又不可参数化描述的模型<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 13.55.20.png" alt="截屏2023-04-15 13.55.20" style="zoom: 50%;"></li></ul></li></ul><h4 id="Constructive-Solid-Geometry"><a href="#Constructive-Solid-Geometry" class="headerlink" title="Constructive Solid Geometry"></a>Constructive Solid Geometry</h4><ul><li>通过一系列基本几何的布尔运算，来定义新的几何<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 13.59.13.png" alt="截屏2023-04-15 13.59.13" style="zoom:50%;"></li></ul></li></ul><h4 id="Distance-Functions"><a href="#Distance-Functions" class="headerlink" title="Distance Functions"></a>Distance Functions</h4><ul><li>距离函数：对空间中任何一个点，到想要的几何形体表面的最小距离（内负外正）。将两个物体的空间函数blend后，推算出得到的新的函数所表示的几何形体<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 14.10.46.png" alt="截屏2023-04-15 14.10.46" style="zoom:50%;"></li></ul></li><li>理想：blend后得到二者位置的中间状态，SDF为0处表示物体边缘<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 14.54.33.png" alt="截屏2023-04-15 14.54.33" style="zoom:33%;"></li><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 15.12.26.png" alt="截屏2023-04-15 15.12.26"></li></ul></li><li>大神作品：<a href="https://iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm">https://iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm</a></li></ul><h4 id="Level-Set-Methods-水平集"><a href="#Level-Set-Methods-水平集" class="headerlink" title="Level Set Methods 水平集"></a>Level Set Methods 水平集</h4><ul><li><p>与距离函数类似，只是表示形式不同</p></li><li><p><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 15.30.03.png" alt="截屏2023-04-15 15.30.03" style="zoom:50%;"></p><ul><li><p>封闭形式的方程很难描述复杂的形状</p></li><li><p>替代方案：存储一个近似函数的值网格</p></li><li><p>表面处，值为0</p></li><li><p>提供对形状的更明确的控制（如纹理）</p></li></ul></li><li><p>水平集的三维应用</p><ul><li>Level Sets from Medical Data<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 15.36.59.png" alt="截屏2023-04-15 15.36.59" style="zoom:50%;"></li></ul></li><li>Level Sets in Physical Simulation，如水滴融合<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 15.38.52.png" alt="截屏2023-04-15 15.38.52" style="zoom:50%;"><ul><li><a href="http://physbam.stanford.edu">http://physbam.stanford.edu</a></li></ul></li></ul></li></ul></li></ul><h4 id="Fractals-分形"><a href="#Fractals-分形" class="headerlink" title="Fractals 分形"></a>Fractals 分形</h4><ul><li>自相似，理解为递归</li></ul><h4 id="Pros-amp-Cons-隐式表示利弊分析"><a href="#Pros-amp-Cons-隐式表示利弊分析" class="headerlink" title="Pros &amp; Cons 隐式表示利弊分析"></a>Pros &amp; Cons 隐式表示利弊分析</h4><ul><li>Pros<ul><li>函数描述几何形体，紧凑</li><li>容易查询，如inside object, distance to surface</li><li>good for ray-to-surface intersection</li><li>对于简单的物体，描述精确，且无采样造成的错误</li><li>容易处理拓扑结构的变化（例如，流体）</li></ul></li><li>Cons<ul><li>很难模拟复杂的形状</li></ul></li></ul><h3 id="几何的显式-Explicit-表示"><a href="#几何的显式-Explicit-表示" class="headerlink" title="几何的显式(Explicit)表示"></a>几何的显式(Explicit)表示</h3><h4 id="Intro-显式表示"><a href="#Intro-显式表示" class="headerlink" title="Intro - 显式表示"></a>Intro - 显式表示</h4><p><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 16.32.06.png" alt="截屏2023-04-15 16.32.06" style="zoom:33%;"></p><ul><li>所有点直接给出，或通过参数映射<ul><li>给出一个函数$f$，可将$uv$映射到$xyz$</li><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 13.39.50.png" alt="截屏2023-04-15 13.39.50" style="zoom:33%;"></li></ul></li><li>优点：采样简单，可直接通过已知的$uv$的出对应的$xyz$<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 13.48.06.png" alt="截屏2023-04-15 13.48.06" style="zoom:33%;"></li></ul></li><li>缺点：难以判断点是否在物体表面上/内/外<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 13.52.05.png" alt="截屏2023-04-15 13.52.05" style="zoom:33%;"></li></ul></li><li>按需选择表示方法</li></ul><h4 id="Point-Cloud-点云"><a href="#Point-Cloud-点云" class="headerlink" title="Point Cloud 点云"></a>Point Cloud 点云</h4><p><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 16.39.57.png" alt="截屏2023-04-15 16.39.57" style="zoom: 40%;"></p><h4 id="Polygon-Mesh"><a href="#Polygon-Mesh" class="headerlink" title="Polygon Mesh"></a>Polygon Mesh</h4><p><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 16.46.23.png" alt="截屏2023-04-15 16.46.23" style="zoom:40%;"></p><ul><li>如何表示用三角形面形成的物体：The Wavefront Object File (.obj) Format<ul><li>是一种存储vertices, normals, texture, coordinates和它们之间联系的文本文件<ul><li>如图，表示一个立方体的八个点（v点，vn法线，vt纹理坐标，f面联系 v/vt/vn）<img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 16.49.26.png" alt="截屏2023-04-15 16.49.26" style="zoom:50%;"></li></ul></li></ul></li></ul><h1 id="P11-Geometry-Curves-and-Surfaces"><a href="#P11-Geometry-Curves-and-Surfaces" class="headerlink" title="P11 Geometry (Curves and Surfaces)"></a>P11 Geometry (Curves and Surfaces)</h1><h2 id="Curves"><a href="#Curves" class="headerlink" title="Curves"></a>Curves</h2><ul><li>应用<ul><li>摄影机运动路径</li><li>动画路径</li><li>字体设计（矢量）</li></ul></li></ul><h3 id="Bézier-Curves"><a href="#Bézier-Curves" class="headerlink" title="Bézier Curves"></a>Bézier Curves</h3><ul><li>用一系列控制点，去定义一条曲线；属于显式的几何表示方法<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 17.07.15.png" alt="截屏2023-04-15 17.07.15" style="zoom:33%;"></li></ul></li></ul><h4 id="计算贝塞尔曲线：de-Casteljau-Algorithm德卡斯特里奥算法"><a href="#计算贝塞尔曲线：de-Casteljau-Algorithm德卡斯特里奥算法" class="headerlink" title="计算贝塞尔曲线：de Casteljau Algorithm德卡斯特里奥算法"></a>计算贝塞尔曲线：de Casteljau Algorithm德卡斯特里奥算法</h4><ul><li><p>计算思路：递归</p><ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 20.07.32.png" alt="截屏2023-04-15 20.07.32" style="zoom:40%;"></li></ul></li><li><p>计算步骤</p><ul><li><p>三个点：</p><ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 17.33.48.png" alt="截屏2023-04-15 17.33.48" style="zoom:40%;"></li><li><p>认为两个控制点间范围$(0,1)$</p></li><li><p>分别找到对应$t$的点的位置$b_0^1$和$b_1^1$，连接</p></li><li><p>再找到$b_0^1$$b_1^1$线段上$t$对应的点$b_0^2$</p></li><li><p>按上述方法，对$t$枚举，即可画出曲线</p></li></ul></li><li><p>四个点：</p><ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 20.06.24.png" alt="截屏2023-04-15 20.06.24" style="zoom:33%;"></li></ul></li></ul></li><li><p><strong>代数公式</strong></p><ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 20.16.38.png" alt="截屏2023-04-15 20.16.38" style="zoom:50%;"></li><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 20.12.16.png" alt="截屏2023-04-15 20.12.16" style="zoom:33%;"></li><li>$n+1$个控制点$(0,1,2,…,n)$可以得到$n$阶的贝塞尔曲线<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 20.21.57.png" alt="截屏2023-04-15 20.21.57" style="zoom:50%;"></li><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 20.22.12.png" alt="截屏2023-04-15 20.22.12" style="zoom:50%;"></li><li>$B_j^n(t) = C_n^i t^i (1-t)^{n-i}$：伯恩斯坦多项式<ul><li>其实是$[t+(1-t)]^n = 1^n$的二项式展开的每一项，因此下图y方向，和为1</li><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 20.31.19.png" alt="截屏2023-04-15 20.31.19" style="zoom:33%;"></li></ul></li></ul></li></ul></li><li><p>性质</p><ul><li><p><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 20.42.32.png" alt="截屏2023-04-15 20.42.32" style="zoom:40%;"></p></li><li><ol><li><p>必过起点和终点。则$t=0$时$b(0) = b_0$，$t=1$时$b(1) = b_3$</p></li><li><p>对三次控制点：切线$b’(0)=3(b_1-b_0)$，$b’(1) = 3(b_3-b_2)$。针对系数3，通过求导可知</p></li><li><p>对于仿射变换：针对控制点的变换，和针对曲线本身的变换，得到的结果相同</p></li><li><p>凸包性质：贝塞尔曲线在控制点所形成的凸包内</p><p><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-15 20.52.32.png" alt="截屏2023-04-15 20.52.32" style="zoom:33%;"></p></li></ol></li></ul></li></ul><h4 id="Piecewise-Bézier-Curves-逐段贝塞尔曲线"><a href="#Piecewise-Bézier-Curves-逐段贝塞尔曲线" class="headerlink" title="Piecewise Bézier Curves 逐段贝塞尔曲线"></a>Piecewise Bézier Curves 逐段贝塞尔曲线</h4><ul><li>思路<ul><li>问题：控制点难以直观控制曲线：<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-17 15.44.08.png" alt="截屏2023-04-17 15.44.08" style="zoom:33%;"></li></ul></li><li>解决：试图用四个控制点控制一段贝塞尔曲线：<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-17 15.46.42.png" alt="截屏2023-04-17 15.46.42" style="zoom:33%;"></li></ul></li></ul></li><li>连续情况<ul><li>$C^0$连续：前一段截止点 = 下一段起始点</li><li>$C^1$连续<img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-18 09.41.41.png" alt="截屏2023-04-18 09.41.41" style="zoom:33%;"></li><li>$C^n$连续：n阶导数连续</li></ul></li></ul><h3 id="其他曲线"><a href="#其他曲线" class="headerlink" title="其他曲线"></a>其他曲线</h3><ul><li>Spline 样条曲线</li></ul><p><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-18 09.52.00.png" alt="截屏2023-04-18 09.52.00" style="zoom:40%;"></p><ul><li>B-Spline<ul><li>Base spline</li><li>局部性</li></ul></li><li>Nurbs</li></ul><h2 id="Surfaces"><a href="#Surfaces" class="headerlink" title="Surfaces"></a>Surfaces</h2><ul><li>Bicubic Bézier Surface<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-18 18.05.13.png" alt="截屏2023-04-18 18.05.13" style="zoom:33%;"></li><li>思路：<ul><li>u方向控制点得出四条贝塞尔曲线，每一时刻t在四条曲线上的四个控制点为v方向对应贝塞尔曲线的控制点；v方向贝塞尔曲线扫过的面为对应曲面</li><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-18 18.05.43.png" alt="截屏2023-04-18 18.05.43" style="zoom:33%;"></li><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-18 18.09.04.png" alt="截屏2023-04-18 18.09.04" style="zoom:40%;"></li></ul></li></ul></li><li>Mesh Operations: Geometry Processing<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-18 18.16.05.png" alt="截屏2023-04-18 18.16.05" style="zoom:50%;"></li></ul></li></ul><h1 id="P12-Geometry"><a href="#P12-Geometry" class="headerlink" title="P12 Geometry"></a>P12 Geometry</h1><h2 id="Mesh-Subdivision-upsampling"><a href="#Mesh-Subdivision-upsampling" class="headerlink" title="Mesh Subdivision (upsampling)"></a>Mesh Subdivision (upsampling)</h2><p><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-18 23.23.18.png" alt="截屏2023-04-18 23.23.18" style="zoom:33%;"></p><h3 id="Loop-Subdivision"><a href="#Loop-Subdivision" class="headerlink" title="Loop Subdivision"></a>Loop Subdivision</h3><ul><li><p><strong>只适用于三角形网格</strong></p></li><li><p>步骤</p><ul><li>增加三角面，$\times 4$<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-18 23.32.35.png" alt="截屏2023-04-18 23.32.35" style="zoom:50%;"></li></ul></li><li>使模型表面变光滑（调整顶点位置）<ul><li>新/旧顶点已不同形式改变</li><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-18 23.35.13.png" alt="截屏2023-04-18 23.35.13" style="zoom: 50%;"></li></ul></li></ul></li><li><p>更新顶点位置的规则</p><ul><li>对于新的（不为边界的）点<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-18 23.39.23.png" alt="截屏2023-04-18 23.39.23" style="zoom:33%;"></li></ul></li><li>对于旧的点 (e.g. degree 6 vertices here)<ul><li>n：顶点的度，即为顶点所连接的边的个数</li><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-18 23.45.07.png" alt="截屏2023-04-18 23.45.07" style="zoom:33%;"></li></ul></li></ul></li></ul><h3 id="Catmull-Clark-Subdivision-General-Mesh"><a href="#Catmull-Clark-Subdivision-General-Mesh" class="headerlink" title="Catmull-Clark Subdivision (General Mesh)"></a>Catmull-Clark Subdivision (General Mesh)</h3><ul><li><strong>适用于三角面和四边面</strong><ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-20 21.50.02.png" alt="截屏2023-04-20 21.50.02" style="zoom:33%;"><ul><li>奇异点：度不为4的点</li></ul></li><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-20 21.53.45.png" alt="截屏2023-04-20 21.53.45" style="zoom:33%;"><ul><li>非四边形面消失并引入奇异点</li></ul></li><li><img src="/2023/04/15/Games101/Games101-P10-12/IMG_2892.JPG" alt="IMG_2892" style="zoom:70%;"></li></ul></li><li>新顶点位置的规则<ul><li><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-20 22.02.25.png" alt="截屏2023-04-20 22.02.25" style="zoom: 33%;"></li></ul></li></ul><h3 id="结果对比"><a href="#结果对比" class="headerlink" title="结果对比"></a>结果对比</h3><p><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-20 22.05.17.png" alt="截屏2023-04-20 22.05.17" style="zoom:40%;"></p><h2 id="Mesh-Simplification-downsampling"><a href="#Mesh-Simplification-downsampling" class="headerlink" title="Mesh Simplification (downsampling)"></a>Mesh Simplification (downsampling)</h2><p><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-18 23.23.41.png" alt="截屏2023-04-18 23.23.41" style="zoom:33%;"></p><ul><li>目标：减少面数的同时，保持物体原有的大致形状</li><li>联系Mipmap（也可以联系LOD），依据情况做simplification</li></ul><h3 id="简化方法"><a href="#简化方法" class="headerlink" title="简化方法"></a>简化方法</h3><h4 id="Collapsing-An-Edge-边坍缩"><a href="#Collapsing-An-Edge-边坍缩" class="headerlink" title="Collapsing An Edge 边坍缩"></a>Collapsing An Edge 边坍缩</h4><p><a href="http://graphics.stanford.edu/courses/cs468-10-fall/LectureSlides/08_Simplification.pdf">http://graphics.stanford.edu/courses/cs468-10-fall/LectureSlides/08_Simplification.pdf</a></p><p>（距离其中一种简化方法）</p><p><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-20 22.18.03.png" alt="截屏2023-04-20 22.18.03" style="zoom:33%;"></p><ul><li>如何判断坍缩的边：Quadric Error Metrics (QEM二次误差度量)<ul><li>对顶点进行局部平均不是一个好主意</li><li>二次误差度量：新的顶点需满足到其所联系的面的距离平方和最小</li></ul></li><li>如何坍缩对面影响最小——二次度量误差最小<ul><li>基本思想：算每一条边的二次度量误差，从最小的开始坍缩</li><li>问题：坍缩一条边，相连的边发生变化，二次度量误差随之变化<ul><li>解决：堆，优先排序，取QEM最小的坍缩，并动态更新所被影响的边的QEM</li></ul></li></ul></li></ul><h2 id="Mesh-Regularization-same-triangles"><a href="#Mesh-Regularization-same-triangles" class="headerlink" title="Mesh Regularization (same #triangles)"></a>Mesh Regularization (same #triangles)</h2><p><img src="/2023/04/15/Games101/Games101-P10-12/截屏2023-04-18 23.24.00.png" alt="截屏2023-04-18 23.24.00" style="zoom:33%;"></p>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
            <tag> 几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P7-9 Shading</title>
      <link href="/2023/04/02/Games101/Games101-P7-9/"/>
      <url>/2023/04/02/Games101/Games101-P7-9/</url>
      
        <content type="html"><![CDATA[<ul><li>P7 Preview<ul><li>Blinn - Phong Diffuse Reflection Model<ul><li>Diffuse：<img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-06 21.05.53.png" alt="截屏2023-04-06 21.05.53" style="zoom: 20%;"></li></ul></li></ul></li><li>P8 Preview<ul><li>Blinn - Phong Diffuse Reflection Model：<img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-07 10.01.33.png" alt="截屏2023-04-07 10.01.33" style="zoom: 20%;"><ul><li>Specular：<img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-07 09.43.05.png" alt="截屏2023-04-07 09.43.05" style="zoom:20%;"><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-07 09.55.47.png" alt="截屏2023-04-07 09.55.47" style="zoom:20%;"></li><li>Ambient：<img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-07 09.59.36.png" alt="截屏2023-04-07 09.59.36" style="zoom:20%;"></li></ul></li><li>Shading Frequencies</li><li>Graphics Pipeline</li></ul></li><li>P9 Preview<ul><li>Barycentric coordinate 重心插值：<img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 09.42.53.png" alt="截屏2023-04-13 09.42.53" style="zoom: 15%;"><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 09.48.47.png" alt="截屏2023-04-13 09.48.47" style="zoom:15%;"></li><li>Texture Magnification<ul><li>Bilinear Interpolation 双线性插值：<img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 10.39.27.png" alt="截屏2023-04-13 10.39.27" style="zoom: 25%;"></li></ul></li><li>Texture antialiasing (MIPMAP)</li><li>Application of texture </li></ul></li></ul><span id="more"></span><h1 id="P7-Shading-Illumination-Shading-and-Graphics-Pipeline"><a href="#P7-Shading-Illumination-Shading-and-Graphics-Pipeline" class="headerlink" title="P7 Shading (Illumination, Shading and Graphics Pipeline)"></a>P7 Shading (Illumination, Shading and Graphics Pipeline)</h1><ul><li>回顾：Model - View - Projection - Viewport - Rasterization<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-02 14.31.29.png" alt="截屏2023-04-02 14.31.29" style="zoom:33%;"></li></ul></li></ul><h2 id="Shading-Definition"><a href="#Shading-Definition" class="headerlink" title="Shading Definition"></a>Shading Definition</h2><ul><li>字典中：The darkening or coloring of an illustration or diagram with parallel lines or a block of color.</li><li>本课中：The process of <strong>applying a material</strong> to an object. // 不同材质和光线相互作用的方法不同</li></ul><h2 id="简单的着色例子：Blinn-Phong-Reflection-Model"><a href="#简单的着色例子：Blinn-Phong-Reflection-Model" class="headerlink" title="简单的着色例子：Blinn - Phong Reflection Model"></a>简单的着色例子：Blinn - Phong Reflection Model</h2><ul><li>Blinn - Phong Reflection Model是经验型模型，并不完全符合物理</li></ul><h3 id="Shading-in-Local"><a href="#Shading-in-Local" class="headerlink" title="Shading in Local"></a>Shading in Local</h3><ul><li>光——得出反射模型<img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-06 20.33.25.png" alt="截屏2023-04-06 20.33.25" style="zoom:25%;"><ul><li>Specular Highlight 高光</li><li>Diffuse Reflection 漫反射光</li><li>Ambient Light 环境光：不是直接接收到的光照，是通过物体反射接收到的光照</li></ul></li><li>Shading Point：相机所观察到的点<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-08 17.08.35.png" alt="截屏2023-04-08 17.08.35" style="zoom: 50%;"></li><li>input：（一下所有向量只表示方向，均为单位向量，由两点向量归一化得到）<ul><li>Viewer direction, v：观测方向，shading point向相机连线的方向</li><li>Surface normal, n：法线方向</li><li>Light direction, l：光照方向，shading point向光源连线的方向</li><li>Surface Parameter(color, shininess, …)：表面属性</li></ul></li></ul></li><li>注意⚠️：Shading in Local只关注该点自身着色，产生明暗变化，不产生阴影，与shadow无关<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-06 20.41.25.png" alt="截屏2023-04-06 20.41.25" style="zoom:33%;"></li></ul></li></ul><h3 id="Diffuse-Reflection-漫反射"><a href="#Diffuse-Reflection-漫反射" class="headerlink" title="Diffuse Reflection 漫反射"></a>Diffuse Reflection 漫反射</h3><ul><li>漫反射<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-06 20.43.27.png" alt="截屏2023-04-06 20.43.27" style="zoom:25%;"></li></ul></li><li>为什么光以不同的角度照射到物体表面，得到的明暗不同<ul><li><strong>Lambert’s cosine law（Lambert余弦定理）：物体表面单位面积接收到的光照和$cos\theta(=n \cdot l)$成正比</strong>，直射接收到所有能量</li><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-06 20.47.32.png" alt="截屏2023-04-06 20.47.32"></li></ul></li><li>Light Falloff<ul><li>能量守恒，远近球壳能量相等；平方反比</li><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-06 20.59.29.png" alt="截屏2023-04-06 20.59.29" style="zoom: 25%;"><ul><li>推广：<strong>已知光源能量 &amp; shading point与光源间距离，可知有多少光可传播到shading point；结合Lambert’s cosine law，可得出diffuse reflection的表示方法</strong></li></ul></li></ul></li><li>Lambertian (Diffuse) Shading —— 漫反射最终着色<ul><li>光源光强$I$，距离$r$，计算基于世界坐标</li><li>$max(0, n \cdot l)$：避免$cos\theta&lt;0$光照反向，无意义</li><li>$k_d$漫反射系数，表示吸收和反射的能量，1白0黑，表示明暗；若$k_d$是vector3，则RGB三通道可表示颜色<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-06 21.05.53.png" alt="截屏2023-04-06 21.05.53" style="zoom: 33%;"></li><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-06 21.20.04.png" alt="截屏2023-04-06 21.20.04" style="zoom:33%;"></li></ul></li></ul></li><li>漫反射理论上各个方向反射均匀，各个方向所观测到的着色应一致</li></ul><h1 id="P8-Shading-Pipeline-and-Texture-Mapping"><a href="#P8-Shading-Pipeline-and-Texture-Mapping" class="headerlink" title="P8 Shading (Pipeline and Texture Mapping)"></a>P8 Shading (Pipeline and Texture Mapping)</h1><h2 id="Blinn-Phong-Model"><a href="#Blinn-Phong-Model" class="headerlink" title="Blinn - Phong Model"></a>Blinn - Phong Model</h2><h3 id="Specular-Term-高光"><a href="#Specular-Term-高光" class="headerlink" title="Specular Term 高光"></a>Specular Term 高光</h3><ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-07 09.36.00.png" alt="截屏2023-04-07 09.36.00" style="zoom:33%;"><ul><li>$v$$和r$足够接近时，可得到高光项</li></ul></li><li>Blinn - Phong 模型中的trick<ul><li>​    <img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-07 09.43.05.png" alt="截屏2023-04-07 09.43.05" style="zoom:33%;"></li><li>备注：<ul><li><strong>$v$$和r$很接近$\iff$法线方向和半程向量($l$和$v$角平分线方向)很接近</strong>；$n\cdot h$越接近1，则观察到的镜面反射越强烈</li><li>镜面反射系数$k_s$通常认为是白色的</li><li>利用半程向量的Blinn - Phong模型是对计算反射方向$r$的简化计算。若直接$r\cdot v$，则是Phong模型。</li><li>$max(0, n \cdot h)^p$指数$p$的作用：限制高光范围<ul><li>下图最左，不做指数运算，则会看到很大的高光；$p$通常为100~200</li><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-07 09.52.26.png" alt="截屏2023-04-07 09.52.26" style="zoom:33%;"></li></ul></li></ul></li></ul></li><li>最终效果<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-07 09.55.47.png" alt="截屏2023-04-07 09.55.47" style="zoom:33%;"></li></ul></li></ul><h3 id="Ambient-Term-环境光"><a href="#Ambient-Term-环境光" class="headerlink" title="Ambient Term 环境光"></a>Ambient Term 环境光</h3><ul><li>假设所有点接收到的环境光相同，强度$I_a$，来自四面八方；假设是错的！<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-07 09.59.36.png" alt="截屏2023-04-07 09.59.36" style="zoom:33%;"></li></ul></li></ul><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><ul><li>叠加所有光效<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-07 10.01.33.png" alt="截屏2023-04-07 10.01.33" style="zoom: 50%;"></li></ul></li></ul><h2 id="Shading-Frequencies-着色频率"><a href="#Shading-Frequencies-着色频率" class="headerlink" title="Shading Frequencies 着色频率"></a>Shading Frequencies 着色频率</h2><ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-07 10.08.19.png" alt="截屏2023-04-07 10.08.19" style="zoom:33%;"><ul><li>利用法线插值</li></ul></li></ul><h3 id="Flat-Shading-shade-each-triangle"><a href="#Flat-Shading-shade-each-triangle" class="headerlink" title="Flat Shading: shade each triangle"></a>Flat Shading: shade each triangle</h3><ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-07 10.13.38.png" alt="截屏2023-04-07 10.13.38" style="zoom: 50%;"><ul><li>每一个面都是平的，只有一个本身的法线</li><li>针对以一个三角面进行着色</li></ul></li></ul><h3 id="Gouraud-Shading-shade-each-vertex"><a href="#Gouraud-Shading-shade-each-vertex" class="headerlink" title="Gouraud Shading: shade each vertex"></a>Gouraud Shading: shade each vertex</h3><ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-07 10.16.24.png" alt="截屏2023-04-07 10.16.24" style="zoom:50%;"><ul><li>求出顶点法线，针对每一个顶点进行着色</li><li>三个顶点所确定的三角形，根据三个顶点的颜色进行插值</li></ul></li></ul><h3 id="Phong-Shading-shade-each-pixel"><a href="#Phong-Shading-shade-each-pixel" class="headerlink" title="Phong Shading: shade each pixel"></a>Phong Shading: shade each pixel</h3><ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-07 10.20.37.png" alt="截屏2023-04-07 10.20.37" style="zoom:50%;"><ul><li>得出三个顶点的法线后，插值三个顶点间每一个像素的法线方向，针对每个像素着色</li></ul></li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-07 10.30.47.png" alt="截屏2023-04-07 10.30.47" style="zoom:50%;"><ul><li>效果好坏是相对的</li><li>当面数极高，高于像素数，Flat shading消耗少于Phong shading，而效果差异不大</li></ul></li></ul><h3 id="定义顶点法线方向"><a href="#定义顶点法线方向" class="headerlink" title="定义顶点法线方向"></a>定义顶点法线方向</h3><ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-07 10.37.34.png" alt="截屏2023-04-07 10.37.34" style="zoom: 50%;"><ul><li><mark>顶点法线</mark><strong>：相邻面的法线方向加权平均(根据面积)，再归一化</strong></li></ul></li></ul><h3 id="定义像素法线方向"><a href="#定义像素法线方向" class="headerlink" title="定义像素法线方向"></a>定义像素法线方向</h3><ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-07 10.41.34.png" alt="截屏2023-04-07 10.41.34" style="zoom:50%;"><ul><li><mark>逐像素的法线</mark><strong>：根据顶点法线，利用重心坐标(Barycentric interpolation)插值，而后归一化</strong></li></ul></li></ul><h2 id="Graphics-Real-time-Rendering-Pipeline-实时渲染-渲染管线"><a href="#Graphics-Real-time-Rendering-Pipeline-实时渲染-渲染管线" class="headerlink" title="Graphics (Real-time Rendering) Pipeline 实时渲染 渲染管线"></a>Graphics (Real-time Rendering) Pipeline 实时渲染 渲染管线</h2><h3 id="渲染管线概述"><a href="#渲染管线概述" class="headerlink" title="渲染管线概述"></a>渲染管线概述</h3><ul><li>概览<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-08 17.53.04.png" alt="截屏2023-04-08 17.53.04" style="zoom:50%;"></li></ul></li><li>attention<ul><li>MVP变换发生在顶点阶段<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-08 18.05.29.png" alt="截屏2023-04-08 18.05.29" style="zoom:50%;"></li></ul></li><li>光栅化<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-08 18.06.17.png" alt="截屏2023-04-08 18.06.17" style="zoom:50%;"></li></ul></li><li>深度缓存<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-08 18.12.15.png" alt="截屏2023-04-08 18.12.15" style="zoom:50%;"></li></ul></li><li>Shading可发生在不同阶段，<strong>顶点的着色发生在顶点阶段，像素着色发生在Fragment阶段</strong><ul><li>eg：Gouraud shading发生在顶点阶段；Phong shading发生在Fragment阶段（需像素产生后进行</li><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-08 18.15.07.png" alt="截屏2023-04-08 18.15.07" style="zoom:50%;"></li></ul></li><li>Texture Mapping 纹理映射<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-08 18.19.29.png" alt="截屏2023-04-08 18.19.29" style="zoom:50%;"></li></ul></li></ul></li></ul><h3 id="Shader-Programs"><a href="#Shader-Programs" class="headerlink" title="Shader Programs"></a>Shader Programs</h3><ul><li><p>关于shader</p><ul><li>本质是可以通过API在硬件上执行的语言</li><li>分顶点shader和fragment shader，每个顶点/fragment执行一次。shader程序对任何顶点/像素通用，不用for循环</li></ul></li><li><p>一个像素着色器的例子</p><ul><li><p>关于像素着色器：通过程序写出，如何计算出像素最终的颜色，并输出</p></li><li><p><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-08 18.23.56.png" alt="截屏2023-04-08 18.23.56" style="zoom: 50%;"></p></li><li><pre><code class="lang-glsl">uniform sampler2D myTexture;    // program parameter；纹理全局变量uniform vec3 lightDir;    // program parameter；光照方向全局变量varying vec2 uv;    // per fragment value (interp. by rasterizer)；插值varying vec3 norm;    // per fragment value (interp. by rasterizer)；插值void diffuseShader()&#123;    vec3 kd;    // 漫反射系数    kd = texture2d(myTexture, uv);    // material color from texture     // Phong模型漫反射计算    kd *= clamp(dot(–lightDir, norm), 0.0, 1.0);    // Lambertian shading model；认为入射方向向内，因而lightDir为负    gl_FragColor = vec4(kd, 1.0);    // output fragment color&#125;</code></pre></li></ul></li><li><p>IQ大神的shader：Inigo Quilez, <a href="http://shadertoy.com/view/ld3Gz2">http://shadertoy.com/view/ld3Gz2</a></p><ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-08 19.16.10.png" alt="截屏2023-04-08 19.16.10" style="zoom:50%;"></li><li>大神博客：<a href="https://iquilezles.org/">https://iquilezles.org/</a></li><li>大神油管：<a href="https://www.youtube.com/@InigoQuilez">https://www.youtube.com/@InigoQuilez</a></li></ul></li></ul><h2 id="Texture-Mapping-纹理映射"><a href="#Texture-Mapping-纹理映射" class="headerlink" title="Texture Mapping 纹理映射"></a>Texture Mapping 纹理映射</h2><ul><li><p><mark>注意</mark>⚠️：接下来的配图有点儿掉san🥵</p></li><li><p>思路：共用同一个模型，但漫反射系数发生了改变；需寻找一种方法，定义一个物体上任意一点的属性</p></li><li>Surfaces are 2D:  Every 3D surface point also has a place where it goes in the 2D image (texture).<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-10 11.21.37.png" alt="截屏2023-04-10 11.21.37" style="zoom:50%;"></li></ul></li><li>Texture Applied to Surface<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-10 11.24.22.png" alt="截屏2023-04-10 11.24.22" style="zoom:50%;"></li></ul></li><li>Visualization of Texture Coordinates<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-10 12.34.17.png" alt="截屏2023-04-10 12.34.17" style="zoom:50%;"></li><li>uv纹理范围在$(0,1)$</li></ul></li><li>Texture Applied to Surface<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-10 12.37.36.png" alt="截屏2023-04-10 12.37.36" style="zoom:50%;"></li></ul></li><li>纹理被重复利用<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-10 12.41.39.png" alt="截屏2023-04-10 12.41.39" style="zoom: 50%;"></li></ul></li><li>关于三角形内部点的uv值：通过顶点uv和重心坐标插值得出</li></ul><h1 id="P9-Shading-Texture-Mapping-cont"><a href="#P9-Shading-Texture-Mapping-cont" class="headerlink" title="P9 Shading (Texture Mapping cont.)"></a>P9 Shading (Texture Mapping cont.)</h1><h2 id="Interpolation-Across-Triangles-Barycentric-Coordinates-重心坐标"><a href="#Interpolation-Across-Triangles-Barycentric-Coordinates-重心坐标" class="headerlink" title="Interpolation Across Triangles: Barycentric Coordinates 重心坐标"></a>Interpolation Across Triangles: Barycentric Coordinates 重心坐标</h2><ul><li>三角形内部插值的作用：通过顶点的值，完成顶点间片元（像素）的平滑过度</li><li>插值的内容：texture coordinates, color, normal vectors…</li><li><strong>重心插值数学基础</strong><ul><li>重心坐标概念基础<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 09.42.53.png" alt="截屏2023-04-13 09.42.53" style="zoom: 33%;"></li><li>三角形<strong>内</strong>任意一点$(x,y)$都可以写成三个顶点的线性组合：$(x,y) = \alpha A+\beta B + \gamma C$；其中，$\alpha + \beta + \gamma = 1$，且$\alpha,\beta,\gamma &gt; 0$。重心坐标即为$(\alpha,\beta,\gamma)$</li><li>$\alpha + \beta + \gamma = 1$表明点在三角形所在平面内，$\alpha,\beta,\gamma &gt; 0$表明点在三角形内部</li></ul></li><li>重心坐标求法：利用面积<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 09.48.47.png" alt="截屏2023-04-13 09.48.47" style="zoom:33%;"></li></ul></li><li>三角形自身重心的性质：重心与三角形顶点连线所得的三角形面积相等。可得：<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 09.55.12.png" alt="截屏2023-04-13 09.55.12" style="zoom:33%;"></li></ul></li><li>导出公式<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 10.00.08.png" alt="截屏2023-04-13 10.00.08" style="zoom:33%;"></li></ul></li></ul></li><li>三角形内重心坐标的应用<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 10.02.36.png" alt="截屏2023-04-13 10.02.36" style="zoom:33%;"><ul><li><mark>注意</mark>⚠️：三角形投影后形状发生拉伸，重心坐标会改变。三维空间中三角形应在三维空间中插值，不能在二维投影屏面插值。</li></ul></li></ul></li></ul><h2 id="Applying-Textures-纹理应用"><a href="#Applying-Textures-纹理应用" class="headerlink" title="Applying Textures 纹理应用"></a>Applying Textures 纹理应用</h2><ul><li>纹理映射举例——Diffuse Color<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 10.13.15.png" alt="截屏2023-04-13 10.13.15" style="zoom:33%;"></li><li>通过对顶点插值，得出每一个片元(x, y)的uv坐标；</li><li>随后在纹理上查询该片元uv值，得出该片元的颜色texcolor；</li><li>将漫反射系数$k_d$设置为texcolor。</li></ul></li></ul><h3 id="Texture-Magnification-纹理分辨率小，需放大"><a href="#Texture-Magnification-纹理分辨率小，需放大" class="headerlink" title="Texture Magnification(纹理分辨率小，需放大)"></a>Texture Magnification(纹理分辨率小，需放大)</h3><ul><li>插值方法：Nearest, Bilinear, Bicubic<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 10.25.17.png" alt="截屏2023-04-13 10.25.17" style="zoom:33%;"></li></ul></li></ul><h4 id="Nearest"><a href="#Nearest" class="headerlink" title="Nearest"></a>Nearest</h4><ul><li>屏幕pixel颜色应用最近的纹理texel的颜色，导致多个相邻pixel被映射成一个texel</li></ul><h4 id="Bilinear-Interpolation-双线性插值"><a href="#Bilinear-Interpolation-双线性插值" class="headerlink" title="Bilinear Interpolation 双线性插值"></a>Bilinear Interpolation 双线性插值</h4><ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 10.39.27.png" alt="截屏2023-04-13 10.39.27" style="zoom: 50%;"></li><li>寻找一个pixel(红色)附近的四个texel(黑色)，定义$t$和$s$范围都为$(0,1)$</li><li>由此插值后，$u_{00},u_{01},u_{10},u_{11}$四个texel所围成的区域内，pixel可实现平滑过度</li></ul><h4 id="Bicubic-Interpolation"><a href="#Bicubic-Interpolation" class="headerlink" title="Bicubic Interpolation"></a>Bicubic Interpolation</h4><ul><li>利用pixel附近的十六个texel，进行三次的插值</li></ul><h3 id="Texture-Magnification-纹理分辨率大，需缩小"><a href="#Texture-Magnification-纹理分辨率大，需缩小" class="headerlink" title="Texture Magnification(纹理分辨率大，需缩小)"></a>Texture Magnification(纹理分辨率大，需缩小)</h3><ul><li>问题：产生摩尔纹和锯齿<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 16.57.04.png" alt="截屏2023-04-13 16.57.04" style="zoom:50%;"></li><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 16.59.38.png" alt="截屏2023-04-13 16.59.38" style="zoom:50%;"></li></ul></li><li>Antialiasing — Supersampling 超采样？<ul><li>可以，但消耗太大</li><li>当纹理严重缩小时，多个texel会集中在一个pixel中。一个pixel中，信号频率太快，而采样频率跟不上</li></ul></li><li>采样会引起走样，因此引入不采样的思路。<ul><li>理想：可直接得知像素覆盖的texel的平均值$\Rightarrow$给定任何一个texel区域即可得知平均值</li><li>引入Range Query范围查询</li></ul></li></ul><h2 id="Mipmap-Allowing-fast-approx-square-range-queries"><a href="#Mipmap-Allowing-fast-approx-square-range-queries" class="headerlink" title="Mipmap: Allowing (fast, approx., square) range queries"></a>Mipmap: Allowing (fast, approx., square) range queries</h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><ul><li>mipmap做近似的、正方形的查询</li><li>如下图，Level提升以及，分辨率减半</li></ul><p><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 20.07.23.png" alt="截屏2023-04-13 20.07.23" style="zoom: 50%;"></p><p><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 20.53.07.png" alt="截屏2023-04-13 20.53.07" style="zoom: 33%;"></p><ul><li>What is the storage overhead of a mipmap?<ul><li>原图存储量为1，而后每提高一个Level，存储量都变为前者的四分之一</li><li>$1+\frac 1 4++\frac 1 {16}+\frac 1 {64} + … = \frac 4 3$ 即变为原来的三分之四</li></ul></li></ul><h3 id="如何计算Mipmap的Level-D-得出范围查询的面积"><a href="#如何计算Mipmap的Level-D-得出范围查询的面积" class="headerlink" title="如何计算Mipmap的Level D(得出范围查询的面积)"></a>如何计算Mipmap的Level D(得出范围查询的面积)</h3><ul><li><p>思路</p><ul><li>计算一个像素在纹理上的覆盖面积，$D=log_2L$</li><li><strong>求出这个像素对应的纹理在第几Level会变到一个像素内</strong></li><li><strong>查找</strong>（提前算出Mipmap）对应Level的Mipmap，得出平均值</li></ul></li><li><p>将像素分别映射到纹理</p><ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 21.05.43.png" alt="截屏2023-04-13 21.05.43" style="zoom: 33%;"></li></ul></li><li>计算映射到纹理后，各个像素间的距离，$L$取距离的最大值。用正方形近似不规则四边形<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 21.09.22.png" alt="截屏2023-04-13 21.09.22" style="zoom:50%;"></li></ul></li><li>得出$D=log_2L$，在根据预先计算好的Mipmap进行对应D的范围查询<ul><li>举例：假如$L$为4（正方形$4 \times 4$），则该区域在$D=2$时，会变为一个像素（正方形$1 \times 1$）</li></ul></li><li>结果<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 21.29.28.png" alt="截屏2023-04-13 21.29.28" style="zoom:40%;"></li><li>问题：渐变不连续，D不为整数时接缝明显</li><li>解决：Trilinear Interpolation进行过渡</li></ul></li></ul><h3 id="Mipmap间过渡-Trilinear-Interpolation-三线形插值"><a href="#Mipmap间过渡-Trilinear-Interpolation-三线形插值" class="headerlink" title="Mipmap间过渡: Trilinear Interpolation 三线形插值"></a>Mipmap间过渡: <mark>Trilinear Interpolation 三线形插值</mark></h3><ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 21.34.22.png" alt="截屏2023-04-13 21.34.22" style="zoom:50%;"><ul><li>两层Level分别先做Bilinear Interpolation，所得的插值结果再进行一次插值</li></ul></li><li>结果<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-13 21.42.39.png" alt="截屏2023-04-13 21.42.39" style="zoom:40%;"></li></ul></li><li><p>三线形插值优点</p><ul><li>得到完全连续的过渡</li><li>开销小：做两次查询，一次插值</li></ul></li><li><p>三线形插值的局限性：远处overblur</p><ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-14 15.05.38.png" alt="截屏2023-04-14 15.05.38" style="zoom:33%;"></li></ul></li></ul><h3 id="Anisotropic-Filtering各向异性过滤；EWA-Fliter"><a href="#Anisotropic-Filtering各向异性过滤；EWA-Fliter" class="headerlink" title="Anisotropic Filtering各向异性过滤；EWA Fliter"></a>Anisotropic Filtering各向异性过滤；EWA Fliter</h3><ul><li>解决<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-14 15.08.08.png" alt="截屏2023-04-14 15.08.08" style="zoom:33%;"></li></ul></li><li>各向异性过滤可解决mipmap只能查询正方形的问题。（可对单一方向压缩剧烈的长条形区域进行范围查询，不必限制在正方形内）<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-14 15.11.13.png" alt="截屏2023-04-14 15.11.13" style="zoom:50%;"></li></ul></li><li>但是各向异性查询对如下对角线方向倾斜的矩形仍无法完美近似，因此也存在局限性<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-14 15.11.39.png" alt="截屏2023-04-14 15.11.39" style="zoom:50%;"></li></ul></li><li>解决：EWA filtering<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-14 15.17.18.png" alt="截屏2023-04-14 15.17.18" style="zoom:40%;"></li></ul></li></ul><h2 id="Application-of-texture"><a href="#Application-of-texture" class="headerlink" title="Application of texture"></a>Application of texture</h2><ul><li>纹理应用范围很广<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-14 16.53.31.png" alt="截屏2023-04-14 16.53.31" style="zoom:33%;"></li></ul></li></ul><h3 id="Environment-Map-环境光贴图"><a href="#Environment-Map-环境光贴图" class="headerlink" title="Environment Map 环境光贴图"></a>Environment Map 环境光贴图</h3><ul><li><p>运用环境光贴图的假设前提：光来自无限远处，贴图只记录方向信息，无实际深度意义</p><ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-14 16.54.12.png" alt="截屏2023-04-14 16.54.12" style="zoom:50%;"></li></ul></li><li><p>Spherical Environment Map</p><ul><li>环境光贴图被记录在球面上<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-14 21.59.21.png" alt="截屏2023-04-14 21.59.21" style="zoom:50%;"></li></ul></li><li>展开会产生扭曲，无法均匀描述<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-14 22.00.51.png" alt="截屏2023-04-14 22.00.51" style="zoom:50%;"></li></ul></li></ul></li><li>利用 Cube Map 解决扭曲问题<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-14 22.01.59.png" alt="截屏2023-04-14 22.01.59" style="zoom:50%;"></li><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-14 22.02.46.png" alt="截屏2023-04-14 22.02.46" style="zoom:50%;"></li></ul></li></ul><h3 id="Bump-Map-凹凸贴图"><a href="#Bump-Map-凹凸贴图" class="headerlink" title="Bump Map 凹凸贴图"></a>Bump Map 凹凸贴图</h3><ul><li><p>区分：高度贴图和法线贴图</p><ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-14 22.25.57.png" alt="截屏2023-04-14 22.25.57"><ul><li><ol><li>base color</li><li>base color + normal：法线贴图修改表面光照</li><li>base color + normal + height：高度贴图实现遮挡</li></ol></li></ul></li></ul></li><li><p><strong>Height map: 定义在法线基础上，上下位移的相对高度</strong></p><ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-14 22.25.06.png" alt="截屏2023-04-14 22.25.06" style="zoom:50%;"></li></ul></li><li><p>作用</p><ul><li>在不增加三角面的基础上，增加表面细节<ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-14 22.47.51.png" alt="截屏2023-04-14 22.47.51" style="zoom:33%;"></li></ul></li></ul></li><li><p><strong>法线的计算</strong></p><ul><li><p><strong>Case1: flatland</strong> 图中原本面为平面，蓝色面由凹凸贴图定义得到：<img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-14 22.59.32.png" alt="截屏2023-04-14 22.59.32" style="zoom:33%;"></p><ul><li><p>思路：</p><ol><li><p>平面上$p$点原本法线：$n(p) = (0,1)$</p></li><li><p>应用凹凸贴图后，$p$点切线方向：$dp = c*[h(p+1) - h(p)]$ (其中$c$为常数，用于表示凹凸贴图的影像大小)</p></li><li><p>由于法线垂直于切线，即可知：$n(p) = (-dp, 1).normalized()$</p></li></ol></li></ul></li><li><p><strong>Case2: 3D</strong></p><ul><li>思路：<ul><li>原平面表面法线：$n(p) = (0,0,1)$</li><li>对贴图在三维空间的$u$方向和$v$方向求偏导：<ul><li>$dp/du = c1 * [h(u+1) - h(u)]$</li><li>$dp/dv = c2 * [h(v+1) - h(v)]$</li></ul></li><li>得出切线方向：$n(p) = (-dp/du, -dp/dv, 1).normalized()$</li></ul></li><li>注意⚠️：以上计算均在切线空间、局部空间进行<mark>（记得去补这块内容！！）</mark></li></ul></li></ul></li><li><p><strong>Displacement Map 置换贴图</strong></p><ul><li><p>对顶点进行真实的位移</p><ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-15 00.24.27.png" alt="截屏2023-04-15 00.24.27" style="zoom:50%;"></li></ul></li><li><p>区分：bump vs. normal vs. displacement </p><ul><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-14 22.56.49.png" alt="截屏2023-04-14 22.56.49"></li></ul></li><li><p>代价：三角面数需足够多，需高于置换贴图的采样频率</p><ul><li>理想：根据置换贴图采样频率，按需规定模型细分精度</li><li>DX中解决方法：动态曲面细分Dynamic Tessellation</li></ul></li></ul></li></ul><h3 id="三维纹理"><a href="#三维纹理" class="headerlink" title="三维纹理"></a>三维纹理</h3><ul><li>3D Procedural Noise + Solid Modeling<ul><li>纹理是实心的球，可以定义三维空间中任意一点的纹理。</li><li>并没有生成对应的内部纹理图，但是定义了一个三维空间中的噪声函数(Perlin Noise)，可以通过解析式算出任意一点的噪声</li><li><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-15 00.38.39.png" alt="截屏2023-04-15 00.38.39" style="zoom:33%;"></li></ul></li></ul><h3 id="Provide-Precomputed-预先计算的-Shading"><a href="#Provide-Precomputed-预先计算的-Shading" class="headerlink" title="Provide Precomputed(预先计算的) Shading"></a>Provide Precomputed(预先计算的) Shading</h3><ul><li>eg：提前计算AO Map，与原有shader做multiple</li></ul><p><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-15 00.44.30.png" alt="截屏2023-04-15 00.44.30" style="zoom:50%;"></p><h3 id="3D-Textures-and-Volume-Rendering"><a href="#3D-Textures-and-Volume-Rendering" class="headerlink" title="3D Textures and Volume Rendering"></a>3D Textures and Volume Rendering</h3><ul><li>eg：医学CT影像，扫描出的数据处理成三维纹理以呈现</li></ul><p><img src="/2023/04/02/Games101/Games101-P7-9/截屏2023-04-15 00.49.03.png" alt="截屏2023-04-15 00.49.03" style="zoom:50%;"></p>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
            <tag> 着色 </tag>
            
            <tag> 渲染管线 </tag>
            
            <tag> 纹理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P5-6 Rasterization</title>
      <link href="/2023/03/27/Games101/Games101-P5-6/"/>
      <url>/2023/03/27/Games101/Games101-P5-6/</url>
      
        <content type="html"><![CDATA[<ul><li>P5 Preview<ul><li>Finishing up viewing<ul><li>Viewport transformation </li></ul></li><li>Rasterization<ul><li>Different raster displays</li><li>Rasterizing a triangle</li></ul></li></ul></li><li><p>P6 Preview</p><ul><li><p>Antialiasing</p><ul><li>采样简单理论</li><li>实际图形学中的反走样</li></ul></li><li><p>Visible /  Occlusion（讲解部分在P7开始处）</p><ul><li>Z - Buffer</li></ul></li></ul></li><li><p>补充！</p><ul><li>shadows</li></ul></li></ul><span id="more"></span><h1 id="P5-Rasterization-Triangles"><a href="#P5-Rasterization-Triangles" class="headerlink" title="P5 Rasterization(Triangles)"></a>P5 Rasterization(Triangles)</h1><h2 id="Finishing-up-viewing"><a href="#Finishing-up-viewing" class="headerlink" title="Finishing up viewing"></a>Finishing up viewing</h2><h3 id="Viewport-transformation-视口变换"><a href="#Viewport-transformation-视口变换" class="headerlink" title="Viewport transformation 视口变换"></a>Viewport transformation 视口变换</h3><h4 id="Intro-摄影机"><a href="#Intro-摄影机" class="headerlink" title="Intro - 摄影机"></a>Intro - 摄影机</h4><ul><li>定义视锥的两个概念<ul><li>长宽比</li><li>FOV</li></ul></li><li>用近平面lrbt表示fov<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-03-27 21.09.36.png" alt="截屏2023-03-27 21.09.36" style="zoom:33%;"></li></ul></li><li>What’s after MVP?<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-03-27 21.22.19.png" alt="截屏2023-03-27 21.22.19" style="zoom: 33%;"></li></ul></li></ul><h4 id="Intro-屏幕"><a href="#Intro-屏幕" class="headerlink" title="Intro - 屏幕"></a>Intro - 屏幕</h4><ul><li>什么是屏幕<ul><li>抽象地认为是二维数组，其中每个元素都是一个像素</li><li>数组的大小就是屏幕分辨率</li><li>一种典型的光栅化显示</li></ul></li><li>Raster光栅<ul><li>Rasterize == drawing onto the screen</li></ul></li><li><p>Pixel像素</p><ul><li>课程中简单地认为是一个个小方块</li><li>实际是RGB的空间混合</li></ul></li><li><p>定义屏幕空间</p><ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-03-27 21.28.54.png" alt="截屏2023-03-27 21.28.54" style="zoom: 33%;"><ul><li>（x，y）形式，每个像素坐标均为整数。蓝色坐标为（2，1），因为从0开始</li><li>屏幕上，像素坐标范围是（0，0）到（width - 1，height - 1）</li><li>像素中心坐标是（x+0.5，y+0.5）</li><li>屏幕范围（0，0）到（width，height）</li></ul></li></ul></li></ul><h4 id="视口变换：将-1-1-3-立方体转化到整个屏幕"><a href="#视口变换：将-1-1-3-立方体转化到整个屏幕" class="headerlink" title="视口变换：将$[-1, 1]^3$立方体转化到整个屏幕"></a>视口变换：将$[-1, 1]^3$立方体转化到整个屏幕</h4><ul><li>Transform xy plane: $[-1, 1]^2$ to  $[0 ,width] * [0, height]$，先不管$z$<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-03-27 21.42.23.png" alt="截屏2023-03-27 21.42.23" style="zoom:33%;"></li><li>视口转化矩阵<ul><li>$M_{viewport} = \begin{pmatrix} \frac{width}2 &amp; 0 &amp; 0 &amp; \frac{width}2\\  0&amp; \frac{height}2 &amp; 0 &amp; \frac{height}2 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0&amp; 1 \\ \end{pmatrix}$<ul><li>左上角矩阵缩放</li><li>缩放后原点是中心，需将左下角平移到原点</li></ul></li></ul></li></ul></li></ul><h2 id="光栅化-Rasterizing-Triangles-into-Pixels"><a href="#光栅化-Rasterizing-Triangles-into-Pixels" class="headerlink" title="光栅化 - Rasterizing Triangles into Pixels"></a>光栅化 - Rasterizing Triangles into Pixels</h2><h3 id="Frame-Buffer-Memory-of-a-Raster-Display"><a href="#Frame-Buffer-Memory-of-a-Raster-Display" class="headerlink" title="Frame Buffer: Memory of a Raster Display"></a>Frame Buffer: Memory of a Raster Display</h3><ul><li>内存空间的一块区域映射到屏幕上，成为显示的图像</li></ul><h3 id="Polygon-Mesh"><a href="#Polygon-Mesh" class="headerlink" title="Polygon Mesh"></a>Polygon Mesh</h3><ul><li>intro<ul><li>已完成：将三维空间顶点变换到屏幕空间中</li><li>下一步：将多边形拆成不同的像素（光栅化的过程</li></ul></li><li>Triangle Mesh<ul><li>基础性质<ul><li>最基础的多边形</li><li>任何其他多边形都可拆成三角形</li></ul></li><li>独特性质<ul><li>三角形三点必在同一平面</li><li>三角形内外定义清晰（可以通过叉积直接定义三角形内外</li><li>三角形内部的点，可根据已知三个点的信息进行渐变（lerp插值）</li></ul></li></ul></li><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-03-31 14.57.13.png" alt="截屏2023-03-31 14.57.13" style="zoom:33%;"></li></ul><h3 id="Sampling-采样"><a href="#Sampling-采样" class="headerlink" title="Sampling 采样"></a>Sampling 采样</h3><ul><li><p>采样函数（一维</p><ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-03-31 15.00.30.png" alt="截屏2023-03-31 15.00.30" style="zoom:33%;"></li></ul></li><li><p>判断像素中心是否在三角形内</p><ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 09.38.41.png" alt="截屏2023-04-01 09.38.41" style="zoom:25%;"></li></ul></li><li><p>二维采样</p><ul><li><pre><code class="lang-c++">for (int x = 0; x&lt; xmax; x++)  for (int y = 0; y &lt; ymax; y++)    image[x][y] = inside(tri, x + 0.5, y+ 0.5); //三角形中心要+0.5</code></pre></li></ul></li><li><p>inside(tri, x, y)具体如何实现：向量叉积</p><ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 09.46.23.png" alt="截屏2023-04-01 09.46.23" style="zoom:25%;"></li><li>$\overrightarrow{P_1P_2} \times \overrightarrow{P_1Q}$ 得到$Q$在$P_1P_2$左边，$P_0P_1$同理</li><li>$\overrightarrow{P_2P_0} \times \overrightarrow{P_2Q}$ 得到$Q$在$P_2P_0$右边</li><li>综上，$Q$在三角形外</li></ul></li><li><p>边界处理：OpenGL认为上左在内，下右在外</p></li></ul><h3 id="光栅化加速优化"><a href="#光栅化加速优化" class="headerlink" title="光栅化加速优化"></a>光栅化加速优化</h3><ul><li>包围盒Bounding Box（AABB）<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 10.03.48.png" alt="截屏2023-04-01 10.03.48" style="zoom:25%;"></li></ul></li><li>每一行只考虑最左和最右，相当于一行一个Bounding Box<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 10.04.55.png" alt="截屏2023-04-01 10.04.55" style="zoom:25%;"></li><li>适用于瘦长三角形</li></ul></li></ul><h3 id="实际屏幕的光栅化-Rasterization-on-Real-Displays"><a href="#实际屏幕的光栅化-Rasterization-on-Real-Displays" class="headerlink" title="实际屏幕的光栅化 Rasterization on Real Displays"></a>实际屏幕的光栅化 Rasterization on Real Displays</h3><ul><li>加色<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 10.23.06.png" alt="截屏2023-04-01 10.23.06" style="zoom:25%;"></li></ul></li><li>减色<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 10.23.30.png" alt="截屏2023-04-01 10.23.30" style="zoom:25%;"></li></ul></li></ul><h3 id="光栅化问题"><a href="#光栅化问题" class="headerlink" title="光栅化问题"></a>光栅化问题</h3><ul><li>锯齿<ul><li>像素有一定大小，采样率不够高，导致图像走样</li></ul></li></ul><h1 id="P6-Rasterization-Antialiasing-and-Z-Buffer-反走样和深度缓冲"><a href="#P6-Rasterization-Antialiasing-and-Z-Buffer-反走样和深度缓冲" class="headerlink" title="P6 Rasterization(Antialiasing and Z-Buffer 反走样和深度缓冲)"></a>P6 Rasterization(Antialiasing and Z-Buffer 反走样和深度缓冲)</h1><h2 id="采样理论"><a href="#采样理论" class="headerlink" title="采样理论"></a>采样理论</h2><ul><li>Artifact：黑话。泛指图形学中的error/mistake/inaccuracies<ul><li>锯齿</li><li>摩尔纹</li><li>车轮倒转效应</li></ul></li><li><strong>产生Artifact的本质原因：信号速度太快，而采样速度跟不上</strong></li></ul><h2 id="如何反走样"><a href="#如何反走样" class="headerlink" title="如何反走样"></a>如何反走样</h2><ul><li><strong>基本思想</strong>：前进行Blur，本质是滤(高频)波；再进行采样<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 10.48.46.png" alt="截屏2023-04-01 10.48.46" style="zoom:33%;"></li><li>不可以先采样，再滤波（先采样的话，混叠的信号已然存在，再进行滤波也无法消除）<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 10.52.16.png" alt="截屏2023-04-01 10.52.16" style="zoom:25%;"></li></ul></li></ul></li></ul><h2 id="Frequency-Domain-频域"><a href="#Frequency-Domain-频域" class="headerlink" title="Frequency Domain 频域"></a>Frequency Domain 频域</h2><h3 id="前置知识-信号处理"><a href="#前置知识-信号处理" class="headerlink" title="前置知识 - 信号处理"></a>前置知识 - 信号处理</h3><ul><li>傅里叶级数展开：任何一个周期函数都可以写成一系列sin和cos的线性组合，和常数项<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 11.07.27.png" alt="截屏2023-04-01 11.07.27" style="zoom:33%;"></li></ul></li><li>傅里叶变换和傅里叶级数展开<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 11.13.01.png" alt="截屏2023-04-01 11.13.01" style="zoom:33%;"><ul><li>通过傅里叶展开可知，上述函数可展开成不同频率的函数</li></ul></li></ul></li></ul><h3 id="走样"><a href="#走样" class="headerlink" title="走样"></a>走样</h3><ul><li>对于傅里叶展开后的函数采样，高频部分出现走样<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 11.17.29.png" alt="截屏2023-04-01 11.17.29" style="zoom:33%;"></li><li><strong>奈奎斯特采样定理</strong>：采样频率要大于信号最高频率的2倍，才能无失真的保留信号的完整信息</li></ul></li><li><strong>走样</strong>：同样的一种采样方法，采样两种不同频率的信号，得出的结果无法进行区分<ul><li>对高频信号通过低频采样出现的走样<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 11.27.15.png" alt="截屏2023-04-01 11.27.15" style="zoom:33%;"></li></ul></li></ul></li></ul><h3 id="Filtering-滤波"><a href="#Filtering-滤波" class="headerlink" title="Filtering 滤波"></a>Filtering 滤波</h3><ul><li>滤波：把某个特定频率抹去</li><li>对图像进行傅里叶变换（变成频域空间<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 16.19.46.png" alt="截屏2023-04-01 16.19.46"><ul><li>右图，中心为最低频。图像细节为高频信息</li><li>右图十字出现原因：图片在平面上平铺，左右边界和上下边界交界处信号变化剧烈，使得四个方向出现高频信号。</li></ul></li></ul></li><li>对图像进行高通滤波<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 16.25.55.png" alt="截屏2023-04-01 16.25.55"></li></ul></li><li>对图像进行低糖滤波<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 16.26.46.png" alt="截屏2023-04-01 16.26.46"></li></ul></li><li><p>中通滤波</p><ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 16.40.29.png" alt="截屏2023-04-01 16.40.29"></li><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 16.41.21.png" alt="截屏2023-04-01 16.41.21"><h4 id="Fliter-Convolution-卷积-Averaging"><a href="#Fliter-Convolution-卷积-Averaging" class="headerlink" title="Fliter = Convolution 卷积 ( = Averaging)"></a>Fliter = Convolution 卷积 ( = Averaging)</h4></li></ul></li><li><p>滤波器和卷积效果相近，但原理不同</p></li><li><p>卷积补充：<a href="https://www.zhihu.com/question/22298352/answer/228543288">如何通俗易懂地理解卷积</a></p><ul><li>卷积可帮助实现平滑算法<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 17.47.54.png" alt="截屏2023-04-01 17.47.54" style="zoom:50%;"></li><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 17.48.40.png" alt="截屏2023-04-01 17.48.40" style="zoom:50%;"></li><li>计算过程说明<img src="/2023/03/27/Games101/Games101-P5-6/卷积.gif" alt="卷积"></li><li>计算过程模拟<img src="/2023/03/27/Games101/Games101-P5-6/卷积2.gif" alt="卷积2"></li></ul></li></ul></li><li>图形学中Convolution：理解为加权平均<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 17.56.08.png" alt="截屏2023-04-01 17.56.08" style="zoom: 25%;"></li><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 17.56.42.png" alt="截屏2023-04-01 17.56.42" style="zoom:25%;"></li></ul></li></ul><ul><li><strong>卷积定理</strong>：两个信号时域上的卷积，是这两个信号频域上的乘积；反之，时域上的乘积，也等于频域上的卷积<ul><li>理解：时域和频域差一个傅里叶的叠加</li></ul></li><li><p>对图像进行滤波（有两种方法</p><ul><li>Option1: 在空域使用卷积进行滤波</li><li><p>Option2</p><ul><li>利用傅里叶变换将空域图片转到频域空间</li><li>图像在频域下，与<a href="https://blog.csdn.net/i_silence/article/details/116483732">卷积核</a>相乘</li><li>通过逆傅里叶变换重新变回空域</li></ul></li><li><p><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 18.10.54.png" alt="截屏2023-04-01 18.10.54" style="zoom:33%;"></p><ul><li>这个例子：一个像素* <script type="math/tex">\begin{bmatrix} \frac 1 9 & \frac 1 9 & \frac 1 9 \\ \frac 1 9 & \frac 1 9 & \frac 1 9 \\ \frac 1 9 & \frac 1 9 & \frac 1 9 \end{bmatrix} \tag{1}</script> = 一个像素和周围一圈像素求平均</li></ul></li></ul></li><li><p>卷积核Box Filter</p><ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 20.38.22.png" alt="截屏2023-04-01 20.38.22" style="zoom:25%;"></li></ul></li><li><p>Box Function = 低通滤波</p><ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 20.46.24.png" alt="截屏2023-04-01 20.46.24"></li></ul></li><li><p>Wider Filter Kernel = 更低的频率</p><ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 20.46.38.png" alt="截屏2023-04-01 20.46.38"><ul><li>理解：利用更大的卷积核进行卷积操作，得到的卷积频率会更低</li></ul></li></ul></li></ul><h3 id="Sampling采样-Repeating-Frequency-Contents"><a href="#Sampling采样-Repeating-Frequency-Contents" class="headerlink" title="Sampling采样 = Repeating Frequency Contents"></a>Sampling采样 = Repeating Frequency Contents</h3><p><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 20.56.53.png" alt="截屏2023-04-01 20.56.53" style="zoom:50%;"></p><ul><li>上图<ul><li>(e)是(a)和(c)在时域上的乘积</li><li>(f)是(b)和(d)在频域上的卷积</li><li>通过观察(b)和(f)，发现采样的过程是重复原始函数的频谱</li></ul></li><li>走样 = 频谱上的混叠<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 21.17.32.png" alt="截屏2023-04-01 21.17.32" style="zoom:33%;"><ul><li>冲激函数周期变大等于冲击函数频域周期变小，则相乘后函数频域也变小，因此“粘贴的函数图像”变密</li></ul></li></ul></li></ul><h2 id="反走样-Antialiasing"><a href="#反走样-Antialiasing" class="headerlink" title="反走样 Antialiasing"></a>反走样 Antialiasing</h2><h3 id="反走样原理"><a href="#反走样原理" class="headerlink" title="反走样原理"></a>反走样原理</h3><ul><li>Reduce Aliasing Error<ul><li><strong>Option1: 增加采样率</strong><ul><li>增大冲激信号在频域的间隔</li><li>更高分辨率的显示器<ul><li>缺点：成本高&amp;需要很高的很高的分辨率</li></ul></li></ul></li><li><strong>Option2: 进行反走样操作</strong><ul><li>采样前，让信号在频域变窄 = 滤高频 = 图像模糊处理</li></ul></li></ul></li><li>Antialiasing = Limiting, then repeating<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 21.33.11.png" alt="截屏2023-04-01 21.33.11"><ul><li>滤波后，避免上上图中的频域混叠</li></ul></li></ul></li><li>应用于图像处理中<ul><li>一般采样<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 21.36.02.png" alt="截屏2023-04-01 21.36.02" style="zoom:33%;"></li></ul></li><li>反走样——先对三角形模糊<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 21.36.30.png" alt="截屏2023-04-01 21.36.30" style="zoom:33%;"></li></ul></li></ul></li><li>上述的滤波操作？（如何将三角形变模糊）<ul><li>用一定大小的低通滤波器进行卷积</li><li>实际解决方法：对每个像素，把三角形求平均值，再采样<img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-01 21.40.10.png" alt="截屏2023-04-01 21.40.10" style="zoom: 33%;"><ul><li>卷积：$f(x, y)$ by a 1-pixel box-blur<ul><li>Recall: convolving = filtering = averaging</li></ul></li><li>Then 采样，at every pixel’s center</li></ul></li></ul></li><li>Antialiasing by Computing Average Pixel Value 通过计算像素平均值进行反走样<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-02 09.59.19.png" alt="截屏2023-04-02 09.59.19" style="zoom:33%;"></li></ul></li></ul><h3 id="MSAA-Antialiasing-By-Supersampling"><a href="#MSAA-Antialiasing-By-Supersampling" class="headerlink" title="MSAA: Antialiasing By Supersampling"></a>MSAA: Antialiasing By Supersampling</h3><ul><li><p>原理：超采样Supersampling</p><ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-02 10.04.46.png" alt="截屏2023-04-02 10.04.46" style="zoom:33%;"><ul><li><strong>注意</strong>：MSAA实际上是对Blur的一种近似，是对信号的模糊，并没有提高分辨率（屏幕分辨率没改变）</li></ul></li></ul></li><li>过程举例<ul><li>增加采样点，挨个判断是否在三角形内；四个采样点，覆盖率有$0\%, 25\%, 50\%,75\%,100\%$<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/Supersampling.JPG" alt="Supersampling"></li></ul></li></ul></li><li><p>MSAA的<strong>性能代价</strong>：计算量增大</p></li><li><p><strong>实际应用</strong>中以降低性能代价，像素不会被规则的划分为NxN，而是会用更加有效的划分方法，一些点还会被临近像素复用。</p></li></ul><h3 id="FXAA-Fast-Approximate-AA"><a href="#FXAA-Fast-Approximate-AA" class="headerlink" title="FXAA: Fast Approximate AA"></a>FXAA: Fast Approximate AA</h3><ul><li>与增加样本数无关，属于图像的后期处理。速度快</li><li>过程：得到有锯齿的图后，通过图像匹配的方法找到边界部分，将边界换成没有锯齿的边界</li></ul><h3 id="TAA-Temporal-AA"><a href="#TAA-Temporal-AA" class="headerlink" title="TAA: Temporal AA"></a>TAA: Temporal AA</h3><ul><li>理解：将MSAA对应样本，从空间分布改变为时间分布</li></ul><h3 id="补：Super-Resolution超分辨率-Super-Sampling"><a href="#补：Super-Resolution超分辨率-Super-Sampling" class="headerlink" title="补：Super Resolution超分辨率 / Super Sampling"></a>补：Super Resolution超分辨率 / Super Sampling</h3><ul><li><p>将小图放大，并避免锯齿的产生（举例：<a href="https://github.com/nagadomi/waifu2x">waifu2x</a>）</p></li><li><p>DLSS: Deep Learning Super Sampling</p><ul><li>通过深度学习，对放大后缺失的细节进行猜测</li></ul></li></ul><h2 id="Visible可见性-Occlusion遮挡"><a href="#Visible可见性-Occlusion遮挡" class="headerlink" title="Visible可见性 /  Occlusion遮挡"></a>Visible可见性 /  Occlusion遮挡</h2><h3 id="画家算法"><a href="#画家算法" class="headerlink" title="画家算法"></a>画家算法</h3><ul><li>对三角面排序，从远到近画，overwrite in the framebuffer</li><li>会出现错误遮挡<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-02 13.39.23.png" alt="截屏2023-04-02 13.39.23" style="zoom:25%;"></li></ul></li></ul><h3 id="Z-Buffer-深度缓存"><a href="#Z-Buffer-深度缓存" class="headerlink" title="Z-Buffer 深度缓存"></a>Z-Buffer 深度缓存</h3><ul><li>对<strong>像素内</strong>深度进行排序</li><li>Ideas：<ul><li>存储当先像素最小的深度</li><li>在生成最终图像的同时，<strong>同步生成</strong>另一张深度图（深度缓存）<img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-02 13.54.51.png" alt="截屏2023-04-02 13.54.51"><ul><li>frame buffer stores color values</li><li>depth buffer (z-buffer) stores depth</li></ul></li></ul></li><li>注意：<ul><li>视口变换中，相机放在原点，看向$-Z$方向</li><li>这里为了方便计算，Z-Buffer中规定$Z$均为正值。则$Z$越小表示越近，$Z$越大表示越远</li></ul></li><li>深度缓存实现步骤<ul><li>初始化每个像素的深度缓存值都为$\infty$</li><li>对每个像素进行Rasterization：遍历每一个三角形中的每一个像素，若该三角形中该像素[x,y]的深度值z于zbuffer[x,y]中的值，则更新zbuffer[x,y]的值为z，并且更新该像素[x,y]的颜色<img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-02 14.05.47.png" alt="截屏2023-04-02 14.05.47"></li></ul></li><li>举例<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-02 14.07.41.png" alt="截屏2023-04-02 14.07.41" style="zoom:33%;"></li></ul></li><li>Z-Buffer复杂度<ul><li><strong>看完数据结构回来<a href="https://www.bilibili.com/video/BV1X7411F744?t=1423.9&amp;p=7">填坑</a></strong></li><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-02 14.14.54.png" alt="截屏2023-04-02 14.14.54" style="zoom:25%;"></li></ul></li><li>假设没有像素在同一深度（实际情况中，浮点数几乎不可能相等），深度缓存画三角形的顺序将不影响结果</li><li>若结合MSAA，则需针对每一个采样点进行相应的Z-Buffer深度操作</li><li>Z-Buffer处理不了透明物体！</li></ul><h1 id="Shadows"><a href="#Shadows" class="headerlink" title="Shadows"></a>Shadows</h1><h2 id="Shadow-mapping"><a href="#Shadow-mapping" class="headerlink" title="Shadow mapping"></a>Shadow mapping</h2><p> （shadow mapping只能处理<strong>点光源</strong>的<strong>硬阴影</strong>）</p><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><ul><li>一种图片空间的算法<ul><li>计算阴影时，无需知道场景几何信息</li><li>需解决走样问题</li></ul></li><li><strong>Key idea：若点不在阴影里，则摄影机和光源都可看到该点</strong>（若在阴影中，摄影机可看到但光源看不到）</li></ul><h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h3><p><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-20 23.29.38.png" alt="截屏2023-04-20 23.29.38" style="zoom:40%;"></p><ul><li><p>Render from light：从光源看向场景，记录深度图</p></li><li><p>Render from eye：从眼睛（摄像机）处看向光源，记录深度和颜色信息图</p></li><li>Project to light：将眼睛所看见的点映射回光源所看到的深度图中对应的像素，计算该点在光源处看的深度，比较所得深度和第一步该点处深度。一致，则光源可以看到，该点不在阴影中；不一致，则光源看不到，该点在阴影中。</li><li>举例<ul><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-20 23.39.20.png" alt="截屏2023-04-20 23.39.20" style="zoom:50%;"></li><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-20 23.39.44.png" alt="截屏2023-04-20 23.39.44" style="zoom:50%;"></li><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-20 23.40.10.png" alt="截屏2023-04-20 23.40.10" style="zoom:50%;"></li><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-20 23.40.33.png" alt="截屏2023-04-20 23.40.33" style="zoom:50%;"><ul><li>问题：边缘不清晰——浮点数很难判断相等，边界处深度判断易出错；shadow map分辨率会引起相应采样问题</li></ul></li></ul></li></ul><h3 id="Problems-with-shadow-maps"><a href="#Problems-with-shadow-maps" class="headerlink" title="Problems with shadow maps"></a>Problems with shadow maps</h3><ul><li>Hard shadows (point lights only)<ul><li>补：软阴影<ul><li>光源有大小才可能出现软阴影</li><li>出现在Penumbra半影区。本质是本影、半影、影子外的过渡</li><li><img src="/2023/03/27/Games101/Games101-P5-6/截屏2023-04-20 23.52.49.png" alt="截屏2023-04-20 23.52.49" style="zoom:33%;"></li></ul></li></ul></li><li>阴影质量取决于shadow map分辨率（采样率低有锯齿，采样率高耗性能）(general problem with image-based techniques……)</li><li>涉及浮点深度值的相等比较，是指尺度、偏差、公差等问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
            <tag> 光栅化 </tag>
            
            <tag> 反走样 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P3-4 Transformation</title>
      <link href="/2023/03/21/Games101/Games101-P3-4/"/>
      <url>/2023/03/21/Games101/Games101-P3-4/</url>
      
        <content type="html"><![CDATA[<ul><li>P3 Preview<ul><li>Why study transformation </li><li>2D变换：rotation, scale, shear</li><li>其次坐标：增加一维表示平移变换</li><li>复合变换</li></ul></li><li>P4 Preview<ul><li>3D变换</li><li>Viewing(观测) Transformation<ul><li>View(视图)/Camera Transformation</li><li>Projection(投影) Transformation<ul><li>Orthographic(正交)</li><li>Perspective(透视)</li></ul></li></ul></li></ul></li></ul><span id="more"></span><h1 id="P3-4-Transformation"><a href="#P3-4-Transformation" class="headerlink" title="P3-4 Transformation"></a>P3-4 Transformation</h1><h2 id="P3"><a href="#P3" class="headerlink" title="P3"></a>P3</h2><h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><ul><li>Modeling模型变换</li><li>Viewing视图变换：（3D to 2D）projection</li></ul><h3 id="2D-Transformation"><a href="#2D-Transformation" class="headerlink" title="2D Transformation"></a>2D Transformation</h3><ul><li>Scale<ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-21 20.16.25.png" alt="截屏2023-03-21 20.16.25" style="zoom:25%;"></li></ul></li><li>Reflection<ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-21 20.18.45.png" alt="截屏2023-03-21 20.18.45" style="zoom:25%;"></li></ul></li><li>Shear(切变)<ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-21 20.24.18.png" alt="截屏2023-03-21 20.24.18" style="zoom:25%;"></li></ul></li><li>Rotation（特殊化点，推导（旋转绕原点<ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-21 20.27.31.png" alt="截屏2023-03-21 20.27.31" style="zoom:25%;"></li><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 10.12.13.png" alt="截屏2023-03-27 10.12.13" style="zoom:25%;"><ul><li>正交矩阵，转置 = 逆</li></ul></li></ul></li><li>线性变换（写成矩阵形式<ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-21 21.15.53.png" alt="截屏2023-03-21 21.15.53" style="zoom:25%;"></li></ul></li></ul><h4 id="其次坐标"><a href="#其次坐标" class="headerlink" title="其次坐标"></a>其次坐标</h4><ul><li><p>平移变换——非线性变换，上述矩阵无法满足</p><ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-26 21.13.00.png" alt="截屏2023-03-26 21.13.00" style="zoom:25%;"></li></ul></li><li><p>引入其次坐标</p><ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-26 21.18.19.png" alt="截屏2023-03-26 21.18.19" style="zoom:25%;"></li><li>1和0用于区分是点还是向量<ul><li>向量是0: 因为向量具有平移不变性</li></ul></li><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-26 21.27.22.png" alt="截屏2023-03-26 21.27.22" style="zoom:25%;"><ul><li>point + point得到两点间中点</li></ul></li></ul></li><li>Affine Transform 仿射变换<ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-26 21.29.32.png" alt="截屏2023-03-26 21.29.32" style="zoom:25%;"></li><li>$\begin{pmatrix}线 &amp; 性 &amp; 平\\ 变 &amp; 换 &amp; 移\\ 0&amp;0&amp;1 \\ \end{pmatrix}$</li></ul></li><li>逆变换</li><li>复合变换：分步左乘变换矩阵，不满足交换律<ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-26 21.42.15.png" alt="截屏2023-03-26 21.42.15" style="zoom:25%;"></li><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-26 21.43.20.png" alt="截屏2023-03-26 21.43.20" style="zoom: 33%;"><ul><li>先应用线性变换，再平移</li></ul></li></ul></li></ul><h3 id="3D-Transformation"><a href="#3D-Transformation" class="headerlink" title="3D Transformation"></a>3D Transformation</h3><ul><li>引入其次坐标<ul><li>$3D\quad point = (x, y, z, 1)^T$</li><li>$3D \quad vector = (x, y, z, 0)^T$</li></ul></li><li>仿射变换<ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 10.03.04.png" alt="截屏2023-03-27 10.03.04" style="zoom: 25%;"></li></ul></li></ul><h2 id="P4"><a href="#P4" class="headerlink" title="P4"></a>P4</h2><h3 id="3D-Transformation-1"><a href="#3D-Transformation-1" class="headerlink" title="3D Transformation"></a>3D Transformation</h3><ul><li>三维空间旋转<ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 10.27.29.png" alt="截屏2023-03-27 10.27.29" style="zoom:25%;"><ul><li>Y轴旋转相反：X ✖️ Z = -Y</li></ul></li><li>$R_{xyz}(\alpha, \beta ,\gamma) = R_x(\alpha)R_y(\beta)R_z(\gamma)$ 三维空间变换分解<ul><li>$\alpha$, $\beta$ ,$\gamma$ 为欧拉角</li><li>Yaw, Pitch, Roll描述三维空间变换<ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 10.37.26.png" alt="截屏2023-03-27 10.37.26" style="zoom:25%;"></li></ul></li></ul></li><li>罗德里格斯旋转公式：绕n轴旋转$\alpha$<ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 10.40.09.png" alt="截屏2023-03-27 10.40.09" style="zoom:25%;"></li></ul></li></ul></li></ul><h3 id="Viewing-Transformation-视图变换"><a href="#Viewing-Transformation-视图变换" class="headerlink" title="Viewing Transformation 视图变换"></a>Viewing Transformation 视图变换</h3><p><mark>得到$[-1, 1]^3$的立方体</mark></p><h4 id="View-Camera-Transformation"><a href="#View-Camera-Transformation" class="headerlink" title="View/Camera Transformation"></a>View/Camera Transformation</h4><ul><li><strong>MVP变换</strong><ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 10.52.32.png" alt="截屏2023-03-27 10.52.32" style="zoom: 33%;"></li></ul></li><li>How to perform view transformation? 得到<strong>$M_{view}$视图变换矩阵</strong><ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 10.56.48.png" alt="截屏2023-03-27 10.56.48" style="zoom: 33%;"><ul><li>Up Direction：用一个向量定义相机向上的方向</li></ul></li><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 10.57.15.png" alt="截屏2023-03-27 10.57.15" style="zoom:33%;"><ul><li>相机放在标准位置(0, 0, 0)，向-Z看，上方向为Y</li></ul></li><li>实现上一步的步骤<ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 11.03.25.png" alt="截屏2023-03-27 11.03.25" style="zoom:33%;"></li><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 11.05.16.png" alt="截屏2023-03-27 11.05.16" style="zoom:33%;"><ul><li>R~view~^-1^：将xy -z旋转到etg（代入<strong>X</strong>(1,0,0,0)^T^, <strong>Y</strong>(0,1,0,0)^T^, <strong>Z</strong>(0,0,1,0)^T^可以验证XYZ向量的旋转得到etg）<img src="/2023/03/21/Games101/Games101-P3-4/IMG_0776.jpg" alt="IMG_0776" style="zoom:25%;"></li><li>正交矩阵，逆 = 转置</li></ul></li></ul></li><li>总结<ul><li>$M_{view}$视图变换操作相机，其他物体跟着相机发生变换</li><li>得到的结果：相机在原点，朝向-Z，上方向为Y</li></ul></li><li>ModelView Transformation模型视图变换：移动相机模型跟着变换，Model和View可相提并论</li></ul></li></ul><h4 id="Projection-Transformation"><a href="#Projection-Transformation" class="headerlink" title="Projection Transformation"></a>Projection Transformation</h4><ul><li>Ortho vs. Persp<ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 14.02.28.png" alt="截屏2023-03-27 14.02.28" style="zoom: 50%;"></li></ul></li></ul><h5 id="Orthographic-Projection正交投影"><a href="#Orthographic-Projection正交投影" class="headerlink" title="Orthographic Projection正交投影"></a>Orthographic Projection正交投影</h5><ul><li>简单做法<ul><li>仍掉Z <img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 14.05.51.png" alt="截屏2023-03-27 14.05.51" style="zoom:33%;"></li></ul></li><li>正式做法<ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 14.14.53.png" alt="截屏2023-03-27 14.14.53" style="zoom:33%;"><ul><li>定义立方体（三个轴的范围）</li><li>将立方体中心移到原点</li><li>映射到$cube[-1, 1]^3$</li></ul></li></ul></li><li>$M_{ortho}$正交变换矩阵<ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 14.18.21.png" alt="截屏2023-03-27 14.18.21" style="zoom:33%;"><ul><li>先平移，再缩放</li></ul></li></ul></li><li>注意⚠️<ul><li>这里使用右手系。看向-Z方向，所以n平面(近处)的Z数值比f平面(远处)大</li></ul></li></ul><h5 id="Perspective-Projection-透视投影"><a href="#Perspective-Projection-透视投影" class="headerlink" title="Perspective Projection 透视投影"></a>Perspective Projection 透视投影</h5><ul><li>知识回顾<ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 14.32.51.png" alt="截屏2023-03-27 14.32.51" style="zoom:33%;"></li></ul></li><li>步骤<ul><li>概述：<img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 14.33.45.png" alt="截屏2023-03-27 14.33.45" style="zoom:33%;"><ul><li>将视锥远平面压缩到长方体中（$M_{persp-&gt;ortho}$）<ul><li>近平面永远不变</li><li>远平面中心点不变，Z不变</li></ul></li><li>长方体做正交投影（$M_{ortho}$）</li></ul></li><li>STEP1：将persp视锥远平面压缩到ortho长方体中，xy可通过相似三角形计算，z未知<ul><li>关于Y如何被挤压<img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 14.41.45.png" alt="截屏2023-03-27 14.41.45" style="zoom:33%;"></li><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 14.44.02.png" alt="截屏2023-03-27 14.44.02" style="zoom:33%;"></li><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 14.50.43.png" alt="截屏2023-03-27 14.50.43" style="zoom:33%;"><ul><li>利用近平面的点(x, y, n, 1)，特殊化求解第三行<ul><li>下图右上角：$(x,y,n,1)^T$经$M_{persp-&gt;ortho}$变换后，还是会得到自己本身。因此乘n，得到与左上角格式类似的矩阵（此时的z=n），可看到unknown的值在近平面为$n^2$</li><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 14.56.24.png" alt="截屏2023-03-27 14.56.24" style="zoom:33%;"><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 14.57.10.png" alt="截屏2023-03-27 14.57.10" style="zoom:33%;"></li></ul></li><li>利用远平面中点(0, 0, f, 1)不变<img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 14.58.40.png" alt="截屏2023-03-27 14.58.40" style="zoom:33%;"></li><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 15.14.45.png" alt="截屏2023-03-27 15.14.45" style="zoom: 33%;"></li><li>$M_{persp-&gt;ortho} = \begin{pmatrix}n &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; n &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; n+f &amp;-nf \\ 0 &amp; 0 &amp; 1&amp; 0 \\ \end{pmatrix}$</li></ul></li></ul></li><li>STEP2：对压缩后长方体进行$M_{ortho}$<ul><li><img src="/2023/03/21/Games101/Games101-P3-4/截屏2023-03-27 15.15.03.png" alt="截屏2023-03-27 15.15.03" style="zoom:33%;"></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
            <tag> MVP变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P2 Review Of Linear Algebra</title>
      <link href="/2023/03/20/Games101/Games101-P2/"/>
      <url>/2023/03/20/Games101/Games101-P2/</url>
      
        <content type="html"><![CDATA[<ul><li>Preview<ul><li>向量点乘、叉乘</li><li>矩阵</li></ul></li></ul><span id="more"></span><h1 id="P2-Review-Of-Linear-Algebra-向量与线性代数"><a href="#P2-Review-Of-Linear-Algebra-向量与线性代数" class="headerlink" title="P2 - Review Of Linear Algebra 向量与线性代数"></a>P2 - Review Of Linear Algebra 向量与线性代数</h1><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><h3 id="向量点乘"><a href="#向量点乘" class="headerlink" title="向量点乘"></a>向量点乘</h3><ul><li>快速得到两个向量的夹角：如，光照运算中，法线、光线夹角 / 投影<ul><li><img src="/2023/03/20/Games101/Games101-P2/截屏2023-03-21 18.45.34.png" alt="截屏2023-03-21 18.45.34" style="zoom:25%;"></li></ul></li><li>测量两个向量距离远近<ul><li>单位向量点乘范围[-1, 1]，1近，-1远</li><li>可用于镜面反射，金属高光：反射处附近看，高光明显</li></ul></li><li>判断向量方向，向前/向后<ul><li><img src="/2023/03/20/Games101/Games101-P2/截屏2023-03-21 19.07.09.png" alt="截屏2023-03-21 19.07.09" style="zoom:25%;"></li></ul></li><li>计算<ul><li><img src="/2023/03/20/Games101/Games101-P2/截屏2023-03-21 19.01.02.png" alt="截屏2023-03-21 19.01.02" style="zoom:25%;"></li></ul></li></ul><h3 id="向量叉乘"><a href="#向量叉乘" class="headerlink" title="向量叉乘"></a>向量叉乘</h3><ul><li><img src="/2023/03/20/Games101/Games101-P2/截屏2023-03-21 19.12.25.png" alt="截屏2023-03-21 19.12.25" style="zoom:33%;"></li><li>$\vec{x} \times \vec{y} = + \vec{z}$</li><li>==判断左右==（叉乘向内/外）==/内外==（三角形三边叉乘同向则在内部，光栅化基础）⭐️<ul><li><img src="/2023/03/20/Games101/Games101-P2/截屏2023-03-21 19.24.34.png" alt="截屏2023-03-21 19.24.34" style="zoom:25%;"></li></ul></li></ul><h3 id="直角坐标系便于向量分解"><a href="#直角坐标系便于向量分解" class="headerlink" title="直角坐标系便于向量分解"></a>直角坐标系便于向量分解</h3><ul><li><img src="/2023/03/20/Games101/Games101-P2/截屏2023-03-21 19.33.42.png" alt="截屏2023-03-21 19.33.42" style="zoom:25%;"></li></ul><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><ul><li>运算法则<ul><li>(AB)C = A(BC)</li><li>A(B+C) = AB + AC</li><li>(A+B)C = AC + AB</li></ul></li><li>矩阵转置<ul><li><img src="/2023/03/20/Games101/Games101-P2/截屏2023-03-21 19.43.16.png" alt="截屏2023-03-21 19.43.16" style="zoom:25%;"></li><li><img src="/2023/03/20/Games101/Games101-P2/截屏2023-03-21 19.45.50.png" alt="截屏2023-03-21 19.45.50" style="zoom:25%;"></li></ul></li><li>单位矩阵<ul><li>是对角阵</li><li>定义矩阵的逆<ul><li><img src="/2023/03/20/Games101/Games101-P2/截屏2023-03-21 19.47.38.png" alt="截屏2023-03-21 19.47.38" style="zoom:25%;"></li></ul></li></ul></li><li>向量点乘/叉乘写成矩阵形式<ul><li><img src="/2023/03/20/Games101/Games101-P2/截屏2023-03-21 19.49.52.png" alt="截屏2023-03-21 19.49.52" style="zoom:25%;"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-P1 Overview Of Computer Graphic</title>
      <link href="/2023/03/20/Games101/Games101-P1/"/>
      <url>/2023/03/20/Games101/Games101-P1/</url>
      
        <content type="html"><![CDATA[<ul><li>Preview<ul><li>应用</li><li>course topics</li></ul></li></ul><span id="more"></span><h1 id="P1-Overview-Of-Computer-Graphic"><a href="#P1-Overview-Of-Computer-Graphic" class="headerlink" title="P1 - Overview Of Computer Graphic"></a>P1 - Overview Of Computer Graphic</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>游戏<ul><li>判断画面质量：亮度（全局光照）</li></ul></li><li>电影<ul><li>特效：常见=难做</li></ul></li><li>动画：如毛发，以及和光线作用<ul><li>几何形体的表述</li><li>渲染</li><li>光线计算</li></ul></li><li>设计：如CAD<ul><li>几何</li><li>光照</li><li>物理模拟，如车辆碰撞测试</li></ul></li><li>可视化：将三维空间信息编程视觉信息<ul><li><img src="/2023/03/20/Games101/Games101-P1/截屏2023-03-20 14.22.25.png" alt="截屏2023-03-20 14.22.25" style="zoom:50%;"></li></ul></li><li>虚拟现实</li><li>数字图像绘制/处理</li><li>物理模拟</li><li>GUI：图形用户接口（UI设计</li><li>字体设计<ul><li><img src="/2023/03/20/Games101/Games101-P1/截屏2023-03-20 20.30.50.png" alt="截屏2023-03-20 20.30.50" style="zoom:25%;"></li></ul></li></ul><h2 id="Course-Topics"><a href="#Course-Topics" class="headerlink" title="Course Topics"></a>Course Topics</h2><ul><li>光栅化（rasterization）<ul><li>三维空间几何形体显示在屏幕上</li><li>广泛用于实时渲染（实时：&gt;30fps）</li></ul></li><li>曲线和曲面</li><li>光线追踪（ray tracing）<ul><li>动画/电影使用</li><li>实时光线追踪</li></ul></li><li>动画与模拟</li></ul>]]></content>
      
      
      <categories>
          
          <category> Games101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
